// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © scientificbest

//@version=5
indicator("Market Structure Mapper V5 (With S&D Zones) [SB]", "MSM V5 [SB]", overlay=true, max_lines_count=250, max_labels_count=250, max_boxes_count=500)

// Input settings
showHighLowLabels = input.bool(false, "Show High/Low Labels", group="Display")
showBosLabels = input.bool(true, "Show BOS Labels", group="Display")
lineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="Display")
showDebugLabel = input.bool(false, "Show Debug Info", group="Display")

// Higher Timeframe Settings
htfEnabled = input.bool(true, "Show HTF Structure", group="Higher Timeframe")
htfTimeframe = input.timeframe("60", "HTF Timeframe", group="Higher Timeframe")

// Zone Settings
showCtfZones = input.bool(true, "Show Zones", group="Zones")
showBrokenZones = input.bool(false, "Show Broken Zones", group="Zones")
maxZonesPerSide = input.int(20, "Max Zones Per Side", minval=10, maxval=250, group="Zones")

// Current Timeframe Colors
highColor = input.color(color.new(color.red, 0), "Valid High Color", group="Current TF Colors")
lowColor = input.color(color.new(color.green, 0), "Valid Low Color", group="Current TF Colors")
bosColor = input.color(color.new(color.black, 0), "BOS Color", group="Current TF Colors")
demandZoneColor = input.color(color.new(color.green, 85), "Demand Zone Color", group="Current TF Colors")
demandZoneBorderColorInput = input.color(color.new(color.green, 50), "Demand Zone Border Color", group="Current TF Colors")
supplyZoneColor = input.color(color.new(color.red, 85), "Supply Zone Color", group="Current TF Colors")
supplyZoneBorderColorInput = input.color(color.new(color.red, 50), "Supply Zone Border Color", group="Current TF Colors")

// Higher Timeframe Colors
htfHighColor = input.color(color.new(color.orange, 0), "HTF Valid High Color", group="HTF Colors")
htfLowColor = input.color(color.new(color.blue, 0), "HTF Valid Low Color", group="HTF Colors")
htfBosColor = input.color(color.new(color.black, 0), "HTF BOS Color", group="HTF Colors")

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

// Type for tracking high levels
type HighLevel
    float price
    int barIndex
    line levelLine
    string levelType  // "strong", "weak", "broken", "swept"

// Type for tracking low levels
type LowLevel
    float price
    int barIndex
    line levelLine
    string levelType  // "strong", "weak", "broken", "swept"

// Type for tracking supply/demand zones
type Zone
    float top
    float bottom
    int leftTime
    int rightTime
    bool broken

// ============================================================================
// ARRAYS TO STORE LEVELS AND ZONES
// ============================================================================

// Current Timeframe - All highs in one array, all lows in another
var array<HighLevel> highs = array.new<HighLevel>()
var array<LowLevel> lows = array.new<LowLevel>()

// Higher Timeframe
var array<HighLevel> htfHighs = array.new<HighLevel>()
var array<LowLevel> htfLows = array.new<LowLevel>()

// Zones
var array<Zone> demandZones = array.new<Zone>()
var array<Zone> supplyZones = array.new<Zone>()

// ============================================================================
// MARKET STRUCTURE STATE VARIABLES
// ============================================================================

// Current Timeframe
var float currentValidHigh = na
var float currentValidLow = na
var int currentValidHighBar = na
var int currentValidLowBar = na
var bool initialized = false
var bool lookingForLow = false
var bool lookingForHigh = false
var bool currentHighIsBroken = false
var bool currentLowIsBroken = false
var string lastBosDirection = "none"  // "bullish", "bearish", or "none"

// Track indices of most recent high/low
var int mostRecentHighIndex = -1
var int mostRecentLowIndex = -1

// Track previous valid levels to detect "clean" BOS (no intermediate levels)
var float previousValidHigh = na
var float previousValidLow = na
var int previousValidHighBar = na
var int previousValidLowBar = na

// Higher Timeframe
var float htfCurrentValidHigh = na
var float htfCurrentValidLow = na
var int htfCurrentValidHighBar = na
var int htfCurrentValidLowBar = na
var bool htfInitialized = false
var bool htfLookingForLow = false
var bool htfLookingForHigh = false
var bool htfCurrentHighIsBroken = false
var bool htfCurrentLowIsBroken = false
var string htfLastBosDirection = "none"

// HTF swing tracking
var float htfSwingLow = na
var int htfSwingLowBar = na
var float htfSwingHigh = na
var int htfSwingHighBar = na

// HTF Track indices
var int htfMostRecentHighIndex = -1
var int htfMostRecentLowIndex = -1

// HTF previous valid levels
var float htfPreviousValidHigh = na
var float htfPreviousValidLow = na
var int htfPreviousValidHighBar = na
var int htfPreviousValidLowBar = na

// Labels
var label currentHighLabel = na
var label currentLowLabel = na
var label htfCurrentHighLabel = na
var label htfCurrentLowLabel = na

var array<label> sweptHighLabels = array.new<label>()
var array<label> sweptLowLabels = array.new<label>()
var array<label> htfSweptHighLabels = array.new<label>()
var array<label> htfSweptLowLabels = array.new<label>()

// Debug counters
var int ctfBullishBOS = 0
var int ctfBearishBOS = 0
var int htfBullishBOS = 0
var int htfBearishBOS = 0
var int htfBullishLabels = 0  // BOS labels created by checkBrokenLevelsHTF
var int htfBearishLabels = 0  // BOS labels created by checkBrokenLevelsHTF
var int demandZonesCreated = 0
var int supplyZonesCreated = 0
var int demandZonesBlocked = 0
var int supplyZonesBlocked = 0
var int swingNaCount = 0
var int calcNaCount = 0

// ============================================================================
// NOTIFICATION FLAGS (for alerts)
// ============================================================================

// HTF Alert condition flags (set at HTF candle close, reset on next LTF bar)
var bool htfBosFlag = false
var bool htfBosLtfBosFlag = false
var bool htfSweptFlag = false
var bool htfSweptLtfBosFlag = false
var bool pullback50Flag = false

// LTF Alert condition flags (set when LTF conditions occur)
var bool ltfBosFlag = false
var bool ltfSweptFlag = false
var bool ltfBosAtExtremeFlag = false
var bool pullback25Flag = false

// State tracking for alert conditions
var bool ltfBosBullishSinceLastHTF = false
var bool ltfBosBearishSinceLastHTF = false
var float pullback50Level = na
var float pullback25Level = na

// Track HTF level state changes to detect when they become swept
var string htfMostRecentHighPrevType = "strong"
var string htfMostRecentLowPrevType = "strong"

// Track LTF level state changes to detect when they become swept
var string ltfMostRecentHighPrevType = "strong"
var string ltfMostRecentLowPrevType = "strong"

// Track HTF BOS for current bar (needed for alert logic)
var bool htfBosBullish = false
var bool htfBosBearish = false

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Check if current candle is bearish and closes below previous candle's low
isBearishBreakdown() =>
    close < open and close < low[1]

// Check if current candle is bullish and closes above previous candle's high
isBullishBreakout() =>
    close > open and close > high[1]

// Find lowest low between two bar indices
findLowestBetween(startBar, endBar) =>
    float lowestPrice = na
    int lowestBarIndex = na

    int start = startBar
    int end = endBar

    if start > end
        int temp = start
        start := end
        end := temp

    int currentBar = bar_index
    int lookbackStart = currentBar - end
    int lookbackEnd = currentBar - start - 1

    lookbackStart := math.max(lookbackStart, 0)
    lookbackEnd := math.min(lookbackEnd, 5000)

    if lookbackStart <= lookbackEnd
        for i = lookbackStart to lookbackEnd
            if not na(low[i])
                if na(lowestPrice) or low[i] < lowestPrice
                    lowestPrice := low[i]
                    lowestBarIndex := currentBar - i

    [lowestPrice, lowestBarIndex]

// Find highest high between two bar indices
findHighestBetween(startBar, endBar) =>
    float highestPrice = na
    int highestBarIndex = na

    int start = startBar
    int end = endBar

    if start > end
        int temp = start
        start := end
        end := temp

    int currentBar = bar_index
    int lookbackStart = currentBar - end
    int lookbackEnd = currentBar - start - 1

    lookbackStart := math.max(lookbackStart, 0)
    lookbackEnd := math.min(lookbackEnd, 5000)

    if lookbackStart <= lookbackEnd
        for i = lookbackStart to lookbackEnd
            if not na(high[i])
                if na(highestPrice) or high[i] > highestPrice
                    highestPrice := high[i]
                    highestBarIndex := currentBar - i

    [highestPrice, highestBarIndex]

// ============================================================================
// ZONE CALCULATION FUNCTIONS
// ============================================================================

// These functions use the CTF market structure arrays (highs/lows) to find
// the actual valid highs and lows around an HTF swing point.

// Calculate demand zone from an HTF swing low
// Uses the CTF lows array to find the nearest valid low
// Uses the CTF highs array to find valid highs on either side
// Zone bottom = the CTF valid low price
// Zone top = the LOWER of the two CTF valid highs (immediately before and after)
// Returns [zoneTop, zoneBottom, leftTime]
calculateZoneFromLow(int lowBarIndex) =>
    float zoneTop = na
    float zoneBottom = na
    int leftTime = na

    // Find the CTF valid low nearest to this bar index
    int nearestLowIdx = -1
    int nearestLowDistance = 999999

    if array.size(lows) > 0
        for i = 0 to array.size(lows) - 1
            lowLevel = array.get(lows, i)
            int distance = math.abs(lowLevel.barIndex - lowBarIndex)
            if distance < nearestLowDistance
                nearestLowDistance := distance
                nearestLowIdx := i

    if nearestLowIdx >= 0
        nearestLow = array.get(lows, nearestLowIdx)
        zoneBottom := nearestLow.price

        // Find the CTF valid high immediately BEFORE this low
        // This is the high from which price dropped to create the low
        // Search backwards through highs to find the first one before nearestLow
        float highBeforePrice = na
        int highBeforeBar = na
        int highBeforeIdx = -1

        if array.size(highs) > 0
            for i = array.size(highs) - 1 to 0
                highLevel = array.get(highs, i)
                if highLevel.barIndex <= nearestLow.barIndex
                    highBeforePrice := highLevel.price
                    highBeforeBar := highLevel.barIndex
                    highBeforeIdx := i
                    break

        // Find the CTF valid high immediately AFTER this low
        // This is the high that price rallied to after the low
        // Search forwards through highs to find the first one after nearestLow
        float highAfterPrice = na
        int highAfterBar = na

        if array.size(highs) > 0
            for i = 0 to array.size(highs) - 1
                highLevel = array.get(highs, i)
                if highLevel.barIndex >= nearestLow.barIndex
                    highAfterPrice := highLevel.price
                    highAfterBar := highLevel.barIndex
                    break

        // Use the LOWER of the two valid highs (creates smaller zone)
        // But always use the leftTime from the "before" high to ensure HTF pivot is included
        if not na(highBeforePrice) and not na(highAfterPrice)
            if highBeforePrice <= highAfterPrice
                zoneTop := highBeforePrice
            else
                zoneTop := highAfterPrice
            // Always start zone from the earlier (before) high
            leftTime := time[bar_index - highBeforeBar]
        else if not na(highBeforePrice)
            zoneTop := highBeforePrice
            leftTime := time[bar_index - highBeforeBar]
        else if not na(highAfterPrice)
            zoneTop := highAfterPrice
            // No high before, use the after high's time
            leftTime := time[bar_index - highAfterBar]
        else
            // Fallback: use the high at the low bar
            int barsBack = bar_index - lowBarIndex
            if barsBack >= 0 and barsBack < 5000
                zoneTop := high[barsBack]
                leftTime := time[barsBack]

    [zoneTop, zoneBottom, leftTime]

// Calculate supply zone from an HTF swing high
// Uses the CTF highs array to find the nearest valid high
// Uses the CTF lows array to find valid lows on either side
// Zone top = the CTF valid high price
// Zone bottom = the HIGHER of the two CTF valid lows (immediately before and after)
// Returns [zoneTop, zoneBottom, leftTime]
calculateZoneFromHigh(int highBarIndex) =>
    float zoneTop = na
    float zoneBottom = na
    int leftTime = na

    // Find the CTF valid high nearest to this bar index
    int nearestHighIdx = -1
    int nearestHighDistance = 999999

    if array.size(highs) > 0
        for i = 0 to array.size(highs) - 1
            highLevel = array.get(highs, i)
            int distance = math.abs(highLevel.barIndex - highBarIndex)
            if distance < nearestHighDistance
                nearestHighDistance := distance
                nearestHighIdx := i

    if nearestHighIdx >= 0
        nearestHigh = array.get(highs, nearestHighIdx)
        zoneTop := nearestHigh.price

        // Find the CTF valid low immediately BEFORE this high
        // This is the low from which price rallied to create the high
        // Search backwards through lows to find the first one before nearestHigh
        float lowBeforePrice = na
        int lowBeforeBar = na
        int lowBeforeIdx = -1

        if array.size(lows) > 0
            for i = array.size(lows) - 1 to 0
                lowLevel = array.get(lows, i)
                if lowLevel.barIndex <= nearestHigh.barIndex
                    lowBeforePrice := lowLevel.price
                    lowBeforeBar := lowLevel.barIndex
                    lowBeforeIdx := i
                    break

        // Find the CTF valid low immediately AFTER this high
        // This is the low that price dropped to after the high
        // Search forwards through lows to find the first one after nearestHigh
        float lowAfterPrice = na
        int lowAfterBar = na

        if array.size(lows) > 0
            for i = 0 to array.size(lows) - 1
                lowLevel = array.get(lows, i)
                if lowLevel.barIndex >= nearestHigh.barIndex
                    lowAfterPrice := lowLevel.price
                    lowAfterBar := lowLevel.barIndex
                    break

        // Use the HIGHER of the two valid lows (creates smaller zone)
        // But always use the leftTime from the "before" low to ensure HTF pivot is included
        if not na(lowBeforePrice) and not na(lowAfterPrice)
            if lowBeforePrice >= lowAfterPrice
                zoneBottom := lowBeforePrice
            else
                zoneBottom := lowAfterPrice
            // Always start zone from the earlier (before) low
            leftTime := time[bar_index - lowBeforeBar]
        else if not na(lowBeforePrice)
            zoneBottom := lowBeforePrice
            leftTime := time[bar_index - lowBeforeBar]
        else if not na(lowAfterPrice)
            zoneBottom := lowAfterPrice
            // No low before, use the after low's time
            leftTime := time[bar_index - lowAfterBar]
        else
            // Fallback: use the low at the high bar
            int barsBack = bar_index - highBarIndex
            if barsBack >= 0 and barsBack < 5000
                zoneBottom := low[barsBack]
                leftTime := time[barsBack]

    [zoneTop, zoneBottom, leftTime]

// ============================================================================
// LEVEL MANAGEMENT FUNCTIONS
// ============================================================================

// Add a new high level
addHigh(float price, int barIdx, string levelType, color lineColor) =>
    // Delete previous most recent high line if it's not broken or swept
    if mostRecentHighIndex >= 0
        prevHigh = array.get(highs, mostRecentHighIndex)
        if prevHigh.levelType != "broken" and prevHigh.levelType != "swept"
            line.delete(prevHigh.levelLine)

    // Create new line
    newLine = line.new(barIdx, price, barIdx + 1, price,
                       color=lineColor,
                       width=lineWidth,
                       extend=extend.right,
                       style=line.style_solid)

    // Create new HighLevel object
    newHigh = HighLevel.new(price, barIdx, newLine, levelType)
    array.push(highs, newHigh)

    // Create label if enabled
    if showHighLowLabels
        label.new(barIdx, price, "",
                 style=label.style_label_down,
                 color=lineColor,
                 textcolor=color.white,
                 size=size.tiny)

    true

// Add a new low level
addLow(float price, int barIdx, string levelType, color lineColor) =>
    // Delete previous most recent low line if it's not broken or swept
    if mostRecentLowIndex >= 0
        prevLow = array.get(lows, mostRecentLowIndex)
        if prevLow.levelType != "broken" and prevLow.levelType != "swept"
            line.delete(prevLow.levelLine)

    // Create new line
    newLine = line.new(barIdx, price, barIdx + 1, price,
                       color=lineColor,
                       width=lineWidth,
                       extend=extend.right,
                       style=line.style_solid)

    // Create new LowLevel object
    newLow = LowLevel.new(price, barIdx, newLine, levelType)
    array.push(lows, newLow)

    // Create label if enabled
    if showHighLowLabels
        label.new(barIdx, price, "",
                 style=label.style_label_up,
                 color=lineColor,
                 textcolor=color.white,
                 size=size.tiny)

    true

// HTF versions
addHighHTF(float price, int barIdx, string levelType, color lineColor) =>
    if htfMostRecentHighIndex >= 0
        prevHigh = array.get(htfHighs, htfMostRecentHighIndex)
        if prevHigh.levelType != "broken" and prevHigh.levelType != "swept"
            line.delete(prevHigh.levelLine)

    newLine = line.new(barIdx, price, barIdx + 1, price,
                       color=lineColor,
                       width=lineWidth + 1,  // Thicker for HTF
                       extend=extend.right,
                       style=line.style_solid)

    newHigh = HighLevel.new(price, barIdx, newLine, levelType)
    array.push(htfHighs, newHigh)

    if showHighLowLabels
        label.new(barIdx, price, "",
                 style=label.style_label_down,
                 color=lineColor,
                 textcolor=color.white,
                 size=size.small)

    true

addLowHTF(float price, int barIdx, string levelType, color lineColor) =>
    if htfMostRecentLowIndex >= 0
        prevLow = array.get(htfLows, htfMostRecentLowIndex)
        if prevLow.levelType != "broken" and prevLow.levelType != "swept"
            line.delete(prevLow.levelLine)

    newLine = line.new(barIdx, price, barIdx + 1, price,
                       color=lineColor,
                       width=lineWidth + 1,  // Thicker for HTF
                       extend=extend.right,
                       style=line.style_solid)

    newLow = LowLevel.new(price, barIdx, newLine, levelType)
    array.push(htfLows, newLow)

    if showHighLowLabels
        label.new(barIdx, price, "",
                 style=label.style_label_up,
                 color=lineColor,
                 textcolor=color.white,
                 size=size.small)

    true

// ============================================================================
// ZONE MANAGEMENT FUNCTIONS
// ============================================================================


// Check and update broken zones - just mark as broken, don't delete yet
checkBrokenZones() =>
    // Check demand zones (broken when price closes below zone bottom)
    if array.size(demandZones) > 0
        for i = 0 to array.size(demandZones) - 1
            zone = array.get(demandZones, i)
            if not zone.broken and close < zone.bottom
                zone.broken := true
                zone.rightTime := time

    // Check supply zones (broken when price closes above zone top)
    if array.size(supplyZones) > 0
        for i = 0 to array.size(supplyZones) - 1
            zone = array.get(supplyZones, i)
            if not zone.broken and close > zone.top
                zone.broken := true
                zone.rightTime := time

    true

// ============================================================================
// CHECK FOR BROKEN AND SWEPT LEVELS
// ============================================================================

checkBrokenLevels() =>
    // Check highs
    if array.size(highs) > 0
        for i = 0 to array.size(highs) - 1
            highLevel = array.get(highs, i)

            // Check for sweep (wick crosses but close doesn't)
            if highLevel.levelType != "swept" and highLevel.levelType != "broken" and high > highLevel.price and close <= highLevel.price
                highLevel.levelType := "swept"
                line.set_style(highLevel.levelLine, line.style_dashed)

            // Check for break (close crosses above)
            else if highLevel.levelType != "broken" and close > highLevel.price
                highLevel.levelType := "broken"

                // Only keep line visible if this is most recent high (valid BOS)
                if i == mostRecentHighIndex
                    line.set_x2(highLevel.levelLine, bar_index)
                    line.set_extend(highLevel.levelLine, extend.none)
                    line.set_style(highLevel.levelLine, line.style_dotted)
                    line.set_color(highLevel.levelLine, color.new(bosColor, 30))

                    if showBosLabels
                        centerBar = math.round((highLevel.barIndex + bar_index) / 2)
                        label.new(centerBar, highLevel.price, "BOS↑",
                                 style=label.style_label_center,
                                 color=color.white,
                                 textcolor=bosColor,
                                 size=size.tiny)
                else
                    line.delete(highLevel.levelLine)

    // Check lows
    if array.size(lows) > 0
        for i = 0 to array.size(lows) - 1
            lowLevel = array.get(lows, i)

            // Check for sweep
            if lowLevel.levelType != "swept" and lowLevel.levelType != "broken" and low < lowLevel.price and close >= lowLevel.price
                lowLevel.levelType := "swept"
                line.set_style(lowLevel.levelLine, line.style_dashed)

            // Check for break
            else if lowLevel.levelType != "broken" and close < lowLevel.price
                lowLevel.levelType := "broken"

                if i == mostRecentLowIndex
                    line.set_x2(lowLevel.levelLine, bar_index)
                    line.set_extend(lowLevel.levelLine, extend.none)
                    line.set_style(lowLevel.levelLine, line.style_dotted)
                    line.set_color(lowLevel.levelLine, color.new(bosColor, 30))

                    if showBosLabels
                        centerBar = math.round((lowLevel.barIndex + bar_index) / 2)
                        label.new(centerBar, lowLevel.price, "BOS↓",
                                 style=label.style_label_center,
                                 color=color.white,
                                 textcolor=bosColor,
                                 size=size.tiny)
                else
                    line.delete(lowLevel.levelLine)

    true

// HTF version - checks for broken levels AND creates zones
// Returns [bullishLabelsCreated, bearishLabelsCreated, demandZonesCreated, supplyZonesCreated]
checkBrokenLevelsHTF(htfHigh, htfLow, htfClose) =>
    int bullishLabels = 0
    int bearishLabels = 0
    int demandCreated = 0
    int supplyCreated = 0

    if array.size(htfHighs) > 0
        for i = 0 to array.size(htfHighs) - 1
            highLevel = array.get(htfHighs, i)

            if highLevel.levelType != "swept" and highLevel.levelType != "broken" and htfHigh > highLevel.price and htfClose <= highLevel.price
                highLevel.levelType := "swept"
                line.set_style(highLevel.levelLine, line.style_dashed)

            else if highLevel.levelType != "broken" and htfClose > highLevel.price
                highLevel.levelType := "broken"

                // Style the broken line
                line.set_x2(highLevel.levelLine, bar_index)
                line.set_extend(highLevel.levelLine, extend.none)
                line.set_style(highLevel.levelLine, line.style_dotted)
                line.set_color(highLevel.levelLine, color.new(htfBosColor, 30))

                // Create BOS label
                if showBosLabels
                    centerBar = math.round((highLevel.barIndex + bar_index) / 2)
                    label.new(centerBar, highLevel.price, htfTimeframe + " BOS↑",
                             style=label.style_label_center,
                             color=color.white,
                             textcolor=htfBosColor,
                             size=size.tiny)
                    bullishLabels := bullishLabels + 1

                // Bullish BOS (high broken) -> Create DEMAND zone
                // The demand zone is at the swing low that formed AFTER the high and led to this breakout
                // Find the lowest low between when this high was created and now
                [lowPrice, lowBar] = findLowestBetween(highLevel.barIndex, bar_index)
                if not na(lowBar)
                    [zoneTop, zoneBottom, zoneLeftTime] = calculateZoneFromLow(lowBar)
                    if not na(zoneTop) and not na(zoneBottom) and not na(zoneLeftTime)
                        // Check for duplicate zone at same location
                        bool isDuplicate = false
                        if array.size(demandZones) > 0
                            for j = array.size(demandZones) - 1 to math.max(0, array.size(demandZones) - 20)
                                existingZone = array.get(demandZones, j)
                                if existingZone.leftTime == zoneLeftTime and existingZone.top == zoneTop and existingZone.bottom == zoneBottom
                                    isDuplicate := true
                                    break
                        if not isDuplicate
                            newZone = Zone.new(zoneTop, zoneBottom, zoneLeftTime, time, false)
                            array.push(demandZones, newZone)
                            demandCreated := demandCreated + 1

    if array.size(htfLows) > 0
        for i = 0 to array.size(htfLows) - 1
            lowLevel = array.get(htfLows, i)

            if lowLevel.levelType != "swept" and lowLevel.levelType != "broken" and htfLow < lowLevel.price and htfClose >= lowLevel.price
                lowLevel.levelType := "swept"
                line.set_style(lowLevel.levelLine, line.style_dashed)

            else if lowLevel.levelType != "broken" and htfClose < lowLevel.price
                lowLevel.levelType := "broken"

                // Style the broken line
                line.set_x2(lowLevel.levelLine, bar_index)
                line.set_extend(lowLevel.levelLine, extend.none)
                line.set_style(lowLevel.levelLine, line.style_dotted)
                line.set_color(lowLevel.levelLine, color.new(htfBosColor, 30))

                // Create BOS label
                if showBosLabels
                    centerBar = math.round((lowLevel.barIndex + bar_index) / 2)
                    label.new(centerBar, lowLevel.price, htfTimeframe + " BOS↓",
                             style=label.style_label_center,
                             color=color.white,
                             textcolor=htfBosColor,
                             size=size.tiny)
                    bearishLabels := bearishLabels + 1

                // Bearish BOS (low broken) -> Create SUPPLY zone
                // The supply zone is at the swing high that formed AFTER the low and led to this breakdown
                // Find the highest high between when this low was created and now
                [highPrice, highBar] = findHighestBetween(lowLevel.barIndex, bar_index)
                if not na(highBar)
                    [zoneTop, zoneBottom, zoneLeftTime] = calculateZoneFromHigh(highBar)
                    if not na(zoneTop) and not na(zoneBottom) and not na(zoneLeftTime)
                        // Check for duplicate zone at same location
                        bool isDuplicate = false
                        if array.size(supplyZones) > 0
                            for j = array.size(supplyZones) - 1 to math.max(0, array.size(supplyZones) - 20)
                                existingZone = array.get(supplyZones, j)
                                if existingZone.leftTime == zoneLeftTime and existingZone.top == zoneTop and existingZone.bottom == zoneBottom
                                    isDuplicate := true
                                    break
                        if not isDuplicate
                            newZone = Zone.new(zoneTop, zoneBottom, zoneLeftTime, time, false)
                            array.push(supplyZones, newZone)
                            supplyCreated := supplyCreated + 1

    [bullishLabels, bearishLabels, demandCreated, supplyCreated]

// Determine level type based on BOS direction
getHighLevelType(string bosDirection) =>
    bosDirection == "bullish" ? "weak" : "strong"

getLowLevelType(string bosDirection) =>
    bosDirection == "bearish" ? "weak" : "strong"

// ============================================================================
// INITIALIZATION
// ============================================================================

if not initialized and bar_index > 0
    if isBearishBreakdown()
        float localHigh = high
        int localHighBar = bar_index

        for i = 1 to math.min(bar_index, 200)
            if high[i] > localHigh
                localHigh := high[i]
                localHighBar := bar_index - i

        currentValidHigh := localHigh
        currentValidHighBar := localHighBar
        initialized := true
        lookingForLow := true

        addHigh(localHigh, localHighBar, "strong", highColor)
        mostRecentHighIndex := array.size(highs) - 1

// ============================================================================
// MAIN LOGIC
// ============================================================================

if initialized
    // Check broken/swept levels and zones
    checkBrokenLevels()
    checkBrokenZones()

    bool bosBullish = false
    bool bosBearish = false

    // Check for Break of Structure
    if not na(currentValidHigh) and not na(currentValidLow) and close > currentValidHigh and lookingForLow
        bosBullish := true
        currentHighIsBroken := true
        lastBosDirection := "bullish"
        ctfBullishBOS := ctfBullishBOS + 1

        // First, find the new low that led to this BOS
        [newLow, newLowBar] = findLowestBetween(currentValidHighBar, bar_index)

        if not na(newLow) and not na(newLowBar)
            // NOTE: Zone creation moved to HTF BOS section only

            // Store previous low before updating
            previousValidLow := currentValidLow
            previousValidLowBar := currentValidLowBar

            currentValidLow := newLow
            currentValidLowBar := newLowBar
            lookingForHigh := true
            lookingForLow := false
            currentLowIsBroken := false

            addLow(newLow, newLowBar, "strong", lowColor)
            mostRecentLowIndex := array.size(lows) - 1

    if not bosBullish and not na(currentValidLow) and not na(currentValidHigh) and close < currentValidLow and lookingForHigh
        bosBearish := true
        currentLowIsBroken := true
        lastBosDirection := "bearish"
        ctfBearishBOS := ctfBearishBOS + 1

        // First, find the new high that led to this BOS
        [newHigh, newHighBar] = findHighestBetween(currentValidLowBar, bar_index)

        if not na(newHigh) and not na(newHighBar)
            // NOTE: Zone creation moved to HTF BOS section only

            // Store previous high before updating
            previousValidHigh := currentValidHigh
            previousValidHighBar := currentValidHighBar

            currentValidHigh := newHigh
            currentValidHighBar := newHighBar
            lookingForLow := true
            lookingForHigh := false
            currentHighIsBroken := false

            addHigh(newHigh, newHighBar, "strong", highColor)
            mostRecentHighIndex := array.size(highs) - 1

    // Look for new valid low via breakout
    if not bosBullish and not bosBearish and lookingForLow
        if isBullishBreakout()
            [newLow, newLowBar] = findLowestBetween(currentValidHighBar, bar_index)

            if not na(newLow) and not na(newLowBar)
                currentValidLow := newLow
                currentValidLowBar := newLowBar
                lookingForHigh := true
                lookingForLow := false
                currentLowIsBroken := false

                levelType = getLowLevelType(lastBosDirection)
                addLow(newLow, newLowBar, levelType, lowColor)
                mostRecentLowIndex := array.size(lows) - 1

    // Look for new valid high via breakdown
    if not bosBullish and not bosBearish and lookingForHigh
        if isBearishBreakdown()
            [newHigh, newHighBar] = findHighestBetween(currentValidLowBar, bar_index)

            if not na(newHigh) and not na(newHighBar)
                currentValidHigh := newHigh
                currentValidHighBar := newHighBar
                lookingForLow := true
                lookingForHigh := false
                currentHighIsBroken := false

                levelType = getHighLevelType(lastBosDirection)
                addHigh(newHigh, newHighBar, levelType, highColor)
                mostRecentHighIndex := array.size(highs) - 1

    // Track LTF BOS for alert conditions
    if bosBullish
        ltfBosBullishSinceLastHTF := true
        ltfBosFlag := true

        // Check if bullish BOS is below 50% of HTF range
        if not na(pullback50Level) and close < pullback50Level
            ltfBosAtExtremeFlag := true

    if bosBearish
        ltfBosBearishSinceLastHTF := true
        ltfBosFlag := true

        // Check if bearish BOS is above 50% of HTF range
        if not na(pullback50Level) and close > pullback50Level
            ltfBosAtExtremeFlag := true

// ============================================================================
// HTF DATA AND LOGIC
// ============================================================================

[htfHigh, htfLow, htfOpen, htfClose] = request.security(syminfo.tickerid, htfTimeframe, [high, low, open, close], lookahead=barmerge.lookahead_off)
htfTime = request.security(syminfo.tickerid, htfTimeframe, time, lookahead=barmerge.lookahead_off)
bool htfNewCandle = ta.change(htfTime) != 0

// HTF helper functions (defined here because they need HTF data)
htfIsBearishBreakdown() =>
    htfClose < htfOpen and htfClose < htfLow[1]

htfIsBullishBreakout() =>
    htfClose > htfOpen and htfClose > htfHigh[1]

// HTF Initialization
// IMPORTANT: We need to set BOTH htfCurrentValidHigh AND htfCurrentValidLow
// Otherwise BOS detection fails because it requires both to be non-NA
if htfEnabled and not htfInitialized and bar_index > 0 and htfNewCandle
    if htfIsBearishBreakdown()
        // Find the highest high in the lookback period for initial valid high
        float initHigh = high
        int initHighBar = bar_index
        for i = 1 to math.min(bar_index, 200)
            if high[i] > initHigh
                initHigh := high[i]
                initHighBar := bar_index - i

        htfCurrentValidHigh := initHigh
        htfCurrentValidHighBar := initHighBar

        // Also set an initial valid low to current bar
        // This allows BOS detection to work immediately
        htfCurrentValidLow := low
        htfCurrentValidLowBar := bar_index

        htfInitialized := true
        htfLookingForLow := true

        // Initialize swing tracking for the NEW HTF candle - start with current bar
        htfSwingLow := low
        htfSwingLowBar := bar_index

        addHighHTF(initHigh, initHighBar, "strong", htfHighColor)
        htfMostRecentHighIndex := array.size(htfHighs) - 1

        // Also add the initial low level
        addLowHTF(low, bar_index, "strong", htfLowColor)
        htfMostRecentLowIndex := array.size(htfLows) - 1

// HTF main logic (only on new HTF candles)
// IMPORTANT: This must run BEFORE swing tracking updates, so we use the
// swing values from the PREVIOUS HTF candle, not contaminated by current bar
if htfEnabled and htfInitialized and htfNewCandle
    // Reset HTF BOS flags
    htfBosBullish := false
    htfBosBearish := false

    // Check HTF BOS - zones are now created in checkBrokenLevelsHTF
    // This section just updates state tracking for the market structure
    // Use findLowestBetween/findHighestBetween for accurate swing detection
    if not na(htfCurrentValidHigh) and not na(htfCurrentValidLow) and htfClose > htfCurrentValidHigh and htfLookingForLow
        htfBosBullish := true
        htfCurrentHighIsBroken := true
        htfLastBosDirection := "bullish"
        htfBullishBOS := htfBullishBOS + 1

        // Find the actual lowest low between the last valid high and now
        [foundLow, foundLowBar] = findLowestBetween(htfCurrentValidHighBar, bar_index)
        if not na(foundLow) and not na(foundLowBar)
            // Store previous low
            htfPreviousValidLow := htfCurrentValidLow
            htfPreviousValidLowBar := htfCurrentValidLowBar

            htfCurrentValidLow := foundLow
            htfCurrentValidLowBar := foundLowBar

            addLowHTF(foundLow, foundLowBar, "strong", htfLowColor)
            htfMostRecentLowIndex := array.size(htfLows) - 1

        // CRITICAL: Always update direction flags after BOS
        htfLookingForHigh := true
        htfLookingForLow := false
        htfCurrentLowIsBroken := false
        // Reset swing tracking for the NEW HTF candle - start with current bar
        htfSwingHigh := high
        htfSwingHighBar := bar_index

    if not htfBosBullish and not na(htfCurrentValidLow) and not na(htfCurrentValidHigh) and htfClose < htfCurrentValidLow and htfLookingForHigh
        htfBosBearish := true
        htfCurrentLowIsBroken := true
        htfLastBosDirection := "bearish"
        htfBearishBOS := htfBearishBOS + 1

        // Find the actual highest high between the last valid low and now
        [foundHigh, foundHighBar] = findHighestBetween(htfCurrentValidLowBar, bar_index)
        if not na(foundHigh) and not na(foundHighBar)
            // Store previous high
            htfPreviousValidHigh := htfCurrentValidHigh
            htfPreviousValidHighBar := htfCurrentValidHighBar

            htfCurrentValidHigh := foundHigh
            htfCurrentValidHighBar := foundHighBar

            addHighHTF(foundHigh, foundHighBar, "strong", htfHighColor)
            htfMostRecentHighIndex := array.size(htfHighs) - 1

        // CRITICAL: Always update direction flags after BOS
        htfLookingForLow := true
        htfLookingForHigh := false
        htfCurrentHighIsBroken := false
        // Reset swing tracking for the NEW HTF candle - start with current bar
        htfSwingLow := low
        htfSwingLowBar := bar_index

    // HTF breakout/breakdown
    // Use findLowestBetween/findHighestBetween like CTF does for accuracy
    if not htfBosBullish and not htfBosBearish and htfLookingForLow
        if htfIsBullishBreakout()
            // Find the actual lowest low between the last valid high and now
            [foundLow, foundLowBar] = findLowestBetween(htfCurrentValidHighBar, bar_index)
            if not na(foundLow) and not na(foundLowBar)
                htfCurrentValidLow := foundLow
                htfCurrentValidLowBar := foundLowBar
                htfLookingForHigh := true
                htfLookingForLow := false
                htfCurrentLowIsBroken := false

                levelType = getLowLevelType(htfLastBosDirection)
                addLowHTF(foundLow, foundLowBar, levelType, htfLowColor)
                htfMostRecentLowIndex := array.size(htfLows) - 1

                // Reset swing tracking for the NEW HTF candle - start with current bar
                htfSwingHigh := high
                htfSwingHighBar := bar_index

    if not htfBosBullish and not htfBosBearish and htfLookingForHigh
        if htfIsBearishBreakdown()
            // Find the actual highest high between the last valid low and now
            [foundHigh, foundHighBar] = findHighestBetween(htfCurrentValidLowBar, bar_index)
            if not na(foundHigh) and not na(foundHighBar)
                htfCurrentValidHigh := foundHigh
                htfCurrentValidHighBar := foundHighBar
                htfLookingForLow := true
                htfLookingForHigh := false
                htfCurrentHighIsBroken := false

                levelType = getHighLevelType(htfLastBosDirection)
                addHighHTF(foundHigh, foundHighBar, levelType, htfHighColor)
                htfMostRecentHighIndex := array.size(htfHighs) - 1

                // Reset swing tracking for the NEW HTF candle - start with current bar
                htfSwingLow := low
                htfSwingLowBar := bar_index

// Check HTF broken/swept levels - ONLY on new HTF candles
// This now also creates zones for every broken level
if htfEnabled and htfInitialized and htfNewCandle
    [bullLabels, bearLabels, demandFromLabels, supplyFromLabels] = checkBrokenLevelsHTF(htfHigh, htfLow, htfClose)
    htfBullishLabels := htfBullishLabels + bullLabels
    htfBearishLabels := htfBearishLabels + bearLabels
    demandZonesCreated := demandZonesCreated + demandFromLabels
    supplyZonesCreated := supplyZonesCreated + supplyFromLabels

// HTF swing tracking - track actual LTF bars where HTF extremes occur
// IMPORTANT: This runs AFTER the htfNewCandle logic so the swing values
// from the previous HTF candle are used before being updated
if htfEnabled and htfInitialized
    if htfLookingForLow
        if na(htfSwingLow) or low < htfSwingLow
            htfSwingLow := low
            htfSwingLowBar := bar_index

    if htfLookingForHigh
        if na(htfSwingHigh) or high > htfSwingHigh
            htfSwingHigh := high
            htfSwingHighBar := bar_index

// ============================================================================
// ALERT CONDITION CHECKING
// ============================================================================

// Detect LTF level sweeps
if initialized
    bool ltfHighJustSwept = false
    bool ltfLowJustSwept = false

    if mostRecentHighIndex >= 0
        highLevel = array.get(highs, mostRecentHighIndex)
        if highLevel.levelType == "swept" and ltfMostRecentHighPrevType != "swept"
            ltfHighJustSwept := true
            ltfSweptFlag := true
        ltfMostRecentHighPrevType := highLevel.levelType

    if mostRecentLowIndex >= 0
        lowLevel = array.get(lows, mostRecentLowIndex)
        if lowLevel.levelType == "swept" and ltfMostRecentLowPrevType != "swept"
            ltfLowJustSwept := true
            ltfSweptFlag := true
        ltfMostRecentLowPrevType := lowLevel.levelType

// HTF alert conditions (set at HTF candle close)
if htfEnabled and htfInitialized
    // Detect if HTF levels just became swept this bar
    bool htfHighJustSwept = false
    bool htfLowJustSwept = false

    if htfMostRecentHighIndex >= 0
        highLevel = array.get(htfHighs, htfMostRecentHighIndex)
        if highLevel.levelType == "swept" and htfMostRecentHighPrevType != "swept"
            htfHighJustSwept := true
        htfMostRecentHighPrevType := highLevel.levelType

    if htfMostRecentLowIndex >= 0
        lowLevel = array.get(htfLows, htfMostRecentLowIndex)
        if lowLevel.levelType == "swept" and htfMostRecentLowPrevType != "swept"
            htfLowJustSwept := true
        htfMostRecentLowPrevType := lowLevel.levelType

    // Always update 50% and 25% levels based on current HTF range
    if not na(htfCurrentValidHigh) and not na(htfCurrentValidLow)
        pullback50Level := (htfCurrentValidHigh + htfCurrentValidLow) / 2
        pullback25Level := htfCurrentValidLow + (htfCurrentValidHigh - htfCurrentValidLow) * 0.25

    // Check HTF alert conditions at HTF candle close
    if htfNewCandle
        // Store whether HTF BOS occurred
        bool htfBosOccurred = htfBosBullish or htfBosBearish

        // HTF Condition 1: HTF BOS
        if htfBosOccurred
            htfBosFlag := true

            // HTF Condition 2: HTF BOS + LTF BOS same direction
            if (htfBosBullish and ltfBosBullishSinceLastHTF) or (htfBosBearish and ltfBosBearishSinceLastHTF)
                htfBosLtfBosFlag := true

        // HTF Condition 3: HTF Swept
        if htfHighJustSwept or htfLowJustSwept
            htfSweptFlag := true

            // HTF Condition 4: HTF Swept + LTF BOS in reversal direction
            if (htfHighJustSwept and ltfBosBearishSinceLastHTF) or (htfLowJustSwept and ltfBosBullishSinceLastHTF)
                htfSweptLtfBosFlag := true

        // Reset LTF BOS tracking flags for next HTF candle
        ltfBosBullishSinceLastHTF := false
        ltfBosBearishSinceLastHTF := false

// Check for 50% pullback
if not na(pullback50Level)
    float tolerance = pullback50Level * 0.001
    if (high >= pullback50Level and low <= pullback50Level) or
       (close >= pullback50Level - tolerance and close <= pullback50Level + tolerance)
        pullback50Flag := true

// Check for 25% pullback
if not na(pullback25Level)
    float tolerance = pullback25Level * 0.001
    if (high >= pullback25Level and low <= pullback25Level) or
       (close >= pullback25Level - tolerance and close <= pullback25Level + tolerance)
        pullback25Flag := true

// ============================================================================
// UPDATE LEVEL STATES (Ensure consistency on every bar)
// ============================================================================

// Update current timeframe level states
if initialized
    // Find most recent BOS in highs array
    int brokenHighIdx = -1
    if array.size(highs) > 0
        for i = array.size(highs) - 1 to 0
            highLevel = array.get(highs, i)
            if highLevel.levelType == "broken"
                brokenHighIdx := i
                break

    // Find most recent BOS in lows array
    int brokenLowIdx = -1
    if array.size(lows) > 0
        for i = array.size(lows) - 1 to 0
            lowLevel = array.get(lows, i)
            if lowLevel.levelType == "broken"
                brokenLowIdx := i
                break

    // Determine which BOS is most recent and update states accordingly
    if brokenHighIdx >= 0 or brokenLowIdx >= 0
        if brokenHighIdx >= 0 and (brokenLowIdx < 0 or brokenHighIdx > brokenLowIdx)
            lastBosDirection := "bullish"

            if mostRecentHighIndex >= 0
                currentHigh = array.get(highs, mostRecentHighIndex)
                if currentHigh.levelType != "broken" and currentHigh.levelType != "swept"
                    currentHigh.levelType := "weak"

            if mostRecentLowIndex >= 0
                currentLow = array.get(lows, mostRecentLowIndex)
                if currentLow.levelType != "broken" and currentLow.levelType != "swept"
                    currentLow.levelType := "strong"

        else if brokenLowIdx >= 0
            lastBosDirection := "bearish"

            if mostRecentLowIndex >= 0
                currentLow = array.get(lows, mostRecentLowIndex)
                if currentLow.levelType != "broken" and currentLow.levelType != "swept"
                    currentLow.levelType := "weak"

            if mostRecentHighIndex >= 0
                currentHigh = array.get(highs, mostRecentHighIndex)
                if currentHigh.levelType != "broken" and currentHigh.levelType != "swept"
                    currentHigh.levelType := "strong"

// Update HTF level states
if htfEnabled and htfInitialized
    int htfBrokenHighIdx = -1
    if array.size(htfHighs) > 0
        for i = array.size(htfHighs) - 1 to 0
            highLevel = array.get(htfHighs, i)
            if highLevel.levelType == "broken"
                htfBrokenHighIdx := i
                break

    int htfBrokenLowIdx = -1
    if array.size(htfLows) > 0
        for i = array.size(htfLows) - 1 to 0
            lowLevel = array.get(htfLows, i)
            if lowLevel.levelType == "broken"
                htfBrokenLowIdx := i
                break

    if htfBrokenHighIdx >= 0 or htfBrokenLowIdx >= 0
        if htfBrokenHighIdx >= 0 and (htfBrokenLowIdx < 0 or htfBrokenHighIdx > htfBrokenLowIdx)
            htfLastBosDirection := "bullish"

            if htfMostRecentHighIndex >= 0
                currentHigh = array.get(htfHighs, htfMostRecentHighIndex)
                if currentHigh.levelType != "broken" and currentHigh.levelType != "swept"
                    currentHigh.levelType := "weak"

            if htfMostRecentLowIndex >= 0
                currentLow = array.get(htfLows, htfMostRecentLowIndex)
                if currentLow.levelType != "broken" and currentLow.levelType != "swept"
                    currentLow.levelType := "strong"

        else if htfBrokenLowIdx >= 0
            htfLastBosDirection := "bearish"

            if htfMostRecentLowIndex >= 0
                currentLow = array.get(htfLows, htfMostRecentLowIndex)
                if currentLow.levelType != "broken" and currentLow.levelType != "swept"
                    currentLow.levelType := "weak"

            if htfMostRecentHighIndex >= 0
                currentHigh = array.get(htfHighs, htfMostRecentHighIndex)
                if currentHigh.levelType != "broken" and currentHigh.levelType != "swept"
                    currentHigh.levelType := "strong"

// ============================================================================
// ARRAY TRUNCATION (Performance)
// ============================================================================

if array.size(highs) > 30
    oldHigh = array.get(highs, 0)
    line.delete(oldHigh.levelLine)
    array.shift(highs)
    if mostRecentHighIndex >= 0
        mostRecentHighIndex := mostRecentHighIndex - 1

if array.size(lows) > 30
    oldLow = array.get(lows, 0)
    line.delete(oldLow.levelLine)
    array.shift(lows)
    if mostRecentLowIndex >= 0
        mostRecentLowIndex := mostRecentLowIndex - 1

if array.size(htfHighs) > 30
    oldHigh = array.get(htfHighs, 0)
    line.delete(oldHigh.levelLine)
    array.shift(htfHighs)
    if htfMostRecentHighIndex >= 0
        htfMostRecentHighIndex := htfMostRecentHighIndex - 1

if array.size(htfLows) > 30
    oldLow = array.get(htfLows, 0)
    line.delete(oldLow.levelLine)
    array.shift(htfLows)
    if htfMostRecentLowIndex >= 0
        htfMostRecentLowIndex := htfMostRecentLowIndex - 1

// Remove old broken zones to keep arrays clean
// NOTE: Disabled automatic removal - let size limit handle cleanup
// if array.size(demandZones) > 0
//     for i = array.size(demandZones) - 1 to 0
//         zone = array.get(demandZones, i)
//         if zone.broken and (time - zone.rightTime) > (100 * (time - time[1]))
//             array.remove(demandZones, i)

// if array.size(supplyZones) > 0
//     for i = array.size(supplyZones) - 1 to 0
//         zone = array.get(supplyZones, i)
//         if zone.broken and (time - zone.rightTime) > (100 * (time - time[1]))
//             array.remove(supplyZones, i)

// if array.size(htfDemandZones) > 0
//     for i = array.size(htfDemandZones) - 1 to 0
//         zone = array.get(htfDemandZones, i)
//         if zone.broken and (time - zone.rightTime) > (100 * (time - time[1]))
//             array.remove(htfDemandZones, i)

// if array.size(htfSupplyZones) > 0
//     for i = array.size(htfSupplyZones) - 1 to 0
//         zone = array.get(htfSupplyZones, i)
//         if zone.broken and (time - zone.rightTime) > (100 * (time - time[1]))
//             array.remove(htfSupplyZones, i)

// Zone array size limiting is now handled at insertion time in addDemandZone/addSupplyZone

// ============================================================================
// PLOTS AND LABELS
// ============================================================================

plot(currentValidHigh, "Current Valid High", color=color.new(highColor, 80), linewidth=1, style=plot.style_stepline)
plot(currentValidLow, "Current Valid Low", color=color.new(lowColor, 80), linewidth=1, style=plot.style_stepline)
plot(htfEnabled ? htfCurrentValidHigh : na, "HTF Valid High", color=color.new(htfHighColor, 80), linewidth=1, style=plot.style_stepline)
plot(htfEnabled ? htfCurrentValidLow : na, "HTF Valid Low", color=color.new(htfLowColor, 80), linewidth=1, style=plot.style_stepline)

// Update labels for current levels
if initialized and not na(currentValidHigh) and mostRecentHighIndex >= 0
    if not na(currentHighLabel)
        label.delete(currentHighLabel)

    highLevel = array.get(highs, mostRecentHighIndex)
    string labelText = na
    color labelColor = highColor

    if highLevel.levelType == "broken"
        labelText := timeframe.period + " Broken High"
        labelColor := color.new(color.red, 0)
    else if highLevel.levelType == "weak"
        labelText := timeframe.period + " Weak High"
    else if highLevel.levelType == "swept"
        labelText := timeframe.period + " Swept High"
    else
        labelText := timeframe.period + " Strong High"

    currentHighLabel := label.new(bar_index + 5, currentValidHigh,
                                   text=labelText,
                                   style=label.style_label_left,
                                   color=labelColor,
                                   textcolor=color.white,
                                   size=size.small)

if initialized and not na(currentValidLow) and mostRecentLowIndex >= 0
    if not na(currentLowLabel)
        label.delete(currentLowLabel)

    lowLevel = array.get(lows, mostRecentLowIndex)
    string labelText = na
    color labelColor = lowColor

    if lowLevel.levelType == "broken"
        labelText := timeframe.period + " Broken Low"
        labelColor := color.new(color.green, 0)
    else if lowLevel.levelType == "weak"
        labelText := timeframe.period + " Weak Low"
    else if lowLevel.levelType == "swept"
        labelText := timeframe.period + " Swept Low"
    else
        labelText := timeframe.period + " Strong Low"

    currentLowLabel := label.new(bar_index + 5, currentValidLow,
                                  text=labelText,
                                  style=label.style_label_left,
                                  color=labelColor,
                                  textcolor=color.white,
                                  size=size.small)

// HTF labels
if htfEnabled and htfInitialized and not na(htfCurrentValidHigh) and htfMostRecentHighIndex >= 0
    if not na(htfCurrentHighLabel)
        label.delete(htfCurrentHighLabel)

    highLevel = array.get(htfHighs, htfMostRecentHighIndex)
    string labelText = na
    color labelColor = htfHighColor

    if highLevel.levelType == "broken"
        labelText := htfTimeframe + " Broken High"
        labelColor := color.new(color.orange, 0)
    else if highLevel.levelType == "weak"
        labelText := htfTimeframe + " Weak High"
    else if highLevel.levelType == "swept"
        labelText := htfTimeframe + " Swept High"
    else
        labelText := htfTimeframe + " Strong High"

    htfCurrentHighLabel := label.new(bar_index + 20, htfCurrentValidHigh,
                                      text=labelText,
                                      style=label.style_label_left,
                                      color=labelColor,
                                      textcolor=color.white,
                                      size=size.small)

if htfEnabled and htfInitialized and not na(htfCurrentValidLow) and htfMostRecentLowIndex >= 0
    if not na(htfCurrentLowLabel)
        label.delete(htfCurrentLowLabel)

    lowLevel = array.get(htfLows, htfMostRecentLowIndex)
    string labelText = na
    color labelColor = htfLowColor

    if lowLevel.levelType == "broken"
        labelText := htfTimeframe + " Broken Low"
        labelColor := color.new(color.blue, 0)
    else if lowLevel.levelType == "weak"
        labelText := htfTimeframe + " Weak Low"
    else if lowLevel.levelType == "swept"
        labelText := htfTimeframe + " Swept Low"
    else
        labelText := htfTimeframe + " Strong Low"

    htfCurrentLowLabel := label.new(bar_index + 20, htfCurrentValidLow,
                                     text=labelText,
                                     style=label.style_label_left,
                                     color=labelColor,
                                     textcolor=color.white,
                                     size=size.small)

// Swept level labels (most recent only)
if array.size(sweptHighLabels) > 0
    for i = 0 to array.size(sweptHighLabels) - 1
        label.delete(array.get(sweptHighLabels, i))
    array.clear(sweptHighLabels)

if array.size(sweptLowLabels) > 0
    for i = 0 to array.size(sweptLowLabels) - 1
        label.delete(array.get(sweptLowLabels, i))
    array.clear(sweptLowLabels)

if array.size(htfSweptHighLabels) > 0
    for i = 0 to array.size(htfSweptHighLabels) - 1
        label.delete(array.get(htfSweptHighLabels, i))
    array.clear(htfSweptHighLabels)

if array.size(htfSweptLowLabels) > 0
    for i = 0 to array.size(htfSweptLowLabels) - 1
        label.delete(array.get(htfSweptLowLabels, i))
    array.clear(htfSweptLowLabels)

// Find and display most recent swept levels
if array.size(highs) > 1
    for i = array.size(highs) - 2 to 0
        highLevel = array.get(highs, i)
        if highLevel.levelType == "swept"
            sweptLabel = label.new(bar_index + 5, highLevel.price,
                                   text=timeframe.period + " Swept High",
                                   style=label.style_label_left,
                                   color=color.new(highColor, 50),
                                   textcolor=color.white,
                                   size=size.small)
            array.push(sweptHighLabels, sweptLabel)
            break

if array.size(lows) > 1
    for i = array.size(lows) - 2 to 0
        lowLevel = array.get(lows, i)
        if lowLevel.levelType == "swept"
            sweptLabel = label.new(bar_index + 5, lowLevel.price,
                                   text=timeframe.period + " Swept Low",
                                   style=label.style_label_left,
                                   color=color.new(lowColor, 50),
                                   textcolor=color.white,
                                   size=size.small)
            array.push(sweptLowLabels, sweptLabel)
            break

if htfEnabled and array.size(htfHighs) > 1
    for i = array.size(htfHighs) - 2 to 0
        highLevel = array.get(htfHighs, i)
        if highLevel.levelType == "swept"
            sweptLabel = label.new(bar_index + 20, highLevel.price,
                                   text=htfTimeframe + " Swept High",
                                   style=label.style_label_left,
                                   color=color.new(htfHighColor, 50),
                                   textcolor=color.white,
                                   size=size.small)
            array.push(htfSweptHighLabels, sweptLabel)
            break

if htfEnabled and array.size(htfLows) > 1
    for i = array.size(htfLows) - 2 to 0
        lowLevel = array.get(htfLows, i)
        if lowLevel.levelType == "swept"
            sweptLabel = label.new(bar_index + 20, lowLevel.price,
                                   text=htfTimeframe + " Swept Low",
                                   style=label.style_label_left,
                                   color=color.new(htfLowColor, 50),
                                   textcolor=color.white,
                                   size=size.small)
            array.push(htfSweptLowLabels, sweptLabel)
            break

// ============================================================================
// ALERT CONDITIONS
// ============================================================================

// HTF Alert Conditions
alertcondition(htfBosFlag, title="HTF BOS", message="HTF Break of Structure occurred on {{ticker}}")
alertcondition(htfBosLtfBosFlag, title="HTF BOS + LTF BOS Same Direction", message="HTF and LTF both broke structure in same direction on {{ticker}}")
alertcondition(htfSweptFlag, title="HTF Swept", message="HTF level swept on {{ticker}}")
alertcondition(htfSweptLtfBosFlag, title="HTF Swept + LTF BOS Reversal", message="HTF level swept followed by LTF reversal BOS on {{ticker}}")

// Pullback Alert Conditions
alertcondition(pullback50Flag, title="50% Pullback", message="Price touched 50% level on {{ticker}}")
alertcondition(pullback25Flag, title="25% Pullback (Low 50% Mark)", message="Price touched 25% level (low 50% mark) on {{ticker}}")

// LTF Alert Conditions
alertcondition(ltfBosFlag, title="LTF BOS", message="LTF Break of Structure occurred on {{ticker}}")
alertcondition(ltfSweptFlag, title="LTF Swept", message="LTF level swept on {{ticker}}")
alertcondition(ltfBosAtExtremeFlag, title="LTF BOS at HTF Extreme", message="LTF BOS occurred at HTF extreme (bullish below 50% or bearish above 50%) on {{ticker}}")

// Reset all alert flags at end of bar
htfBosFlag := false
htfBosLtfBosFlag := false
htfSweptFlag := false
htfSweptLtfBosFlag := false
pullback50Flag := false
pullback25Flag := false
ltfBosFlag := false
ltfSweptFlag := false
ltfBosAtExtremeFlag := false

// ============================================================================
// ZONE RENDERING - Only on last bar for performance
// ============================================================================

// Render zones only on the last bar
var int demandZonesRendered = 0
var int supplyZonesRendered = 0
var int htfDemandZonesRendered = 0
var int htfSupplyZonesRendered = 0
var int demandSkipped = 0
var int supplySkipped = 0
var array<int> demandZoneTimes = array.new<int>()
var array<int> supplyZoneTimes = array.new<int>()

// Use user-configured max zones per side

if barstate.islast
    // Delete all existing boxes
    for bx in box.all
        bx.delete()

if barstate.islast and showCtfZones
    demandZonesRendered := 0
    supplyZonesRendered := 0
    demandSkipped := 0
    supplySkipped := 0
    array.clear(demandZoneTimes)
    array.clear(supplyZoneTimes)

    // Render demand zones (newest first, up to limit)
    if array.size(demandZones) > 0
        for i = array.size(demandZones) - 1 to 0
            if demandZonesRendered >= maxZonesPerSide
                break
            zone = array.get(demandZones, i)
            // Skip broken zones unless showBrokenZones is enabled
            if zone.broken and not showBrokenZones
                continue
            if not na(zone.leftTime) and not na(zone.top) and not na(zone.bottom)
                zoneEndTime = zone.broken ? zone.rightTime : time
                box.new(zone.leftTime, zone.top, zoneEndTime, zone.bottom,
                       bgcolor=demandZoneColor,
                       border_color=demandZoneBorderColorInput,
                       border_width=1,
                       xloc=xloc.bar_time)
                array.push(demandZoneTimes, zone.leftTime)
                demandZonesRendered := demandZonesRendered + 1
            else
                demandSkipped := demandSkipped + 1

    // Render supply zones (newest first, up to limit)
    if array.size(supplyZones) > 0
        for i = array.size(supplyZones) - 1 to 0
            if supplyZonesRendered >= maxZonesPerSide
                break
            zone = array.get(supplyZones, i)
            // Skip broken zones unless showBrokenZones is enabled
            if zone.broken and not showBrokenZones
                continue
            if not na(zone.leftTime) and not na(zone.top) and not na(zone.bottom)
                zoneEndTime = zone.broken ? zone.rightTime : time
                box.new(zone.leftTime, zone.top, zoneEndTime, zone.bottom,
                       bgcolor=supplyZoneColor,
                       border_color=supplyZoneBorderColorInput,
                       border_width=1,
                       xloc=xloc.bar_time)
                array.push(supplyZoneTimes, zone.leftTime)
                supplyZonesRendered := supplyZonesRendered + 1
            else
                supplySkipped := supplySkipped + 1

// NOTE: HTF zones are now stored in the main demandZones/supplyZones arrays
// No separate HTF rendering needed

// Debug labels showing zone counts and BOS events
if barstate.islast and showDebugLabel
    var label debugLabel = na
    label.delete(debugLabel)

    // Count broken zones
    int brokenDemand = 0
    int brokenSupply = 0
    if array.size(demandZones) > 0
        for i = 0 to array.size(demandZones) - 1
            if array.get(demandZones, i).broken
                brokenDemand := brokenDemand + 1
    if array.size(supplyZones) > 0
        for i = 0 to array.size(supplyZones) - 1
            if array.get(supplyZones, i).broken
                brokenSupply := brokenSupply + 1

    // Calculate time spans of rendered zones
    int demandOldest = array.size(demandZoneTimes) > 0 ? array.get(demandZoneTimes, array.size(demandZoneTimes) - 1) : na
    int demandNewest = array.size(demandZoneTimes) > 0 ? array.get(demandZoneTimes, 0) : na
    int supplyOldest = array.size(supplyZoneTimes) > 0 ? array.get(supplyZoneTimes, array.size(supplyZoneTimes) - 1) : na
    int supplyNewest = array.size(supplyZoneTimes) > 0 ? array.get(supplyZoneTimes, 0) : na

    // Calculate bars ago
    int demandOldestBarsAgo = not na(demandOldest) ? math.round((time - demandOldest) / (time - time[1])) : na
    int demandNewestBarsAgo = not na(demandNewest) ? math.round((time - demandNewest) / (time - time[1])) : na
    int supplyOldestBarsAgo = not na(supplyOldest) ? math.round((time - supplyOldest) / (time - time[1])) : na
    int supplyNewestBarsAgo = not na(supplyNewest) ? math.round((time - supplyNewest) / (time - time[1])) : na

    string debugText = "ZONE DEBUG v4:\n"
    debugText := debugText + "HTF Labels: " + str.tostring(htfBullishLabels) + " bull / " + str.tostring(htfBearishLabels) + " bear\n"
    debugText := debugText + "Zones created: " + str.tostring(demandZonesCreated) + " D / " + str.tostring(supplyZonesCreated) + " S\n"
    debugText := debugText + "In array: " + str.tostring(array.size(demandZones)) + " D / " + str.tostring(array.size(supplyZones)) + " S\n"
    debugText := debugText + "Rendered: " + str.tostring(demandZonesRendered) + " D / " + str.tostring(supplyZonesRendered) + " S\n"
    debugText := debugText + "Total boxes: " + str.tostring(array.size(box.all))

    debugLabel := label.new(bar_index, high, debugText,
                           style=label.style_label_down,
                           color=color.yellow,
                           textcolor=color.black,
                           size=size.small)
