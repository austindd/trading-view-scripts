// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© scientificbest

//@version=5
indicator("Supply & Demand Zones V8 (Multi-Timeframe) [SB]", "S&D Zones V8 [SB]", overlay = true
  , max_bars_back = 5000
  , max_lines_count  = 500
  , max_labels_count = 500
  , max_boxes_count  = 500)

////////////////////////////////////////////////////////////////////////////////
//// Inputs
////////////////////////////////////////////////////////////////////////////////
grp1 = 'Zone Detection Parameters'
grp2 = 'Current Timeframe Display'
grp3 = 'Higher Timeframe Settings'
grp4 = 'Current Timeframe Colors'
grp5 = 'Higher Timeframe Colors'

// Zone Detection
src 								= input.source(close, title='Source', group=grp1)
src_vol 							= input.string('No', title='Use volume as the source?', group=grp1, options=['No', 'Volume', 'VolumeDiff'], tooltip='If enabled, will use volume as the source, so the Source parameter above will be ignored.')
period 								= input.int(80, title='Lookback Period', minval=1, maxval=500, group=grp1, tooltip='This is the number of bars that will be sampled to detect outliers in the "Source" data.') + 1
limit_second 						= input.float(13, title='Significance threshold', minval=0, step=0.05, group=grp1, tooltip='This value is used as a threshold for detecting outliers in the "Source" data, which should identify significant "strong moves" in the price action. Generally speaking, the higher the value, the fewer zones will be detected. However, those zone tend to be higher quality. You probably want a value between 0.5 and 2.5')
minMoveToZoneRatioInput				= input.float(1.1, title='Minimum move to zone ratio', minval=0, step=0.05, group=grp1, tooltip='This is the minimum ratio of the intial "strong move" to the zone size. If the move is smaller than this ratio, the zone will not be plotted. This roughly translates into the minimum risk reward ratio for the trade, but it also correlates with zone strength. Since this only refers to the "explosive" part of the move, you probably want a value between 0.25 and 1.5.')
maxNumberOfZonesInput				= input.int(120, title='Max number of zones', minval=1, group=grp1, tooltip='This is the maximum number of zones that will be plotted on the chart. If the number of zones exceeds this value, the oldest zones will be removed from the chart. Keep in mind the maximum number of boxes that can be plotted by a single indicator is 500, so if the total number of zones AND strong moves plotted exceeds 500, some of the boxes will fail to render.')

// Current Timeframe Display
showCtfZonesInput					= input.bool(true, title="Show CTF Zones", group=grp2, tooltip='If enabled, will display the current timeframe zones on the chart.')
showCtfStrongMovesInput				= input.bool(false, title="Show CTF Strong Moves", group=grp2, tooltip='If enabled, will display the current timeframe strong moves on the chart.')
changeColorOnTouchedInput			= input.bool(true, title="Change Color On Touched", group=grp2, tooltip='If enabled, will change the color of the zone when it is touched.')
brokenWhenTouchedInput				= input.bool(false, title="Zones Are Broken When Touched", group=grp2, tooltip='If enabled, the zone will be considered broken when it is touched. If disabled, the zone will only be considered broken when it is crossed.')

// Higher Timeframe Settings
htfEnabled							= input.bool(true, title="Enable HTF Zones", group=grp3, tooltip='If enabled, will detect and display zones from the higher timeframe.')
htfTimeframe						= input.timeframe("60", title="HTF Timeframe", group=grp3, tooltip='The higher timeframe to use for zone detection.')
showHtfZonesInput					= input.bool(true, title="Show HTF Zones", group=grp3, tooltip='If enabled, will display the higher timeframe zones on the chart.')
showHtfStrongMovesInput				= input.bool(false, title="Show HTF Strong Moves", group=grp3, tooltip='If enabled, will display the higher timeframe strong moves on the chart.')
htfMaxNumberOfZonesInput			= input.int(60, title='HTF Max number of zones', minval=1, group=grp3, tooltip='Maximum number of HTF zones to display.')
showHtfDebugInput					= input.bool(false, title="Show HTF Debug Labels", group=grp3, tooltip='If enabled, will show debug labels for HTF zone detection.')

// Current Timeframe Colors
ctfSupplyZoneColorInput 			= input.color(color.new(color.red, 70), title="Supply Zone Color", group=grp4)
ctfSupplyZoneBorderColorInput 		= input.color(color.new(color.red, 50), title="Supply Zone Border Color", group=grp4)
ctfSupplyStrongMoveColorInput 		= input.color(color.new(color.orange, 80), title="Supply Strong Move Color", group=grp4)
ctfSupplyStrongMoveBorderColorInput	= input.color(color.new(color.orange, 50), title="Supply Strong Move Border Color", group=grp4)
ctfDemandZoneColorInput 			= input.color(color.new(color.green, 70), title="Demand Zone Color", group=grp4)
ctfDemandZoneBorderColorInput 		= input.color(color.new(color.green, 50), title="Demand Zone Border Color", group=grp4)
ctfDemandStrongMoveColorInput 		= input.color(color.new(color.blue, 80), title="Demand Strong Move Color", group=grp4)
ctfDemandStrongMoveBorderColorInput	= input.color(color.new(color.blue, 50), title="Demand Strong Move Border Color", group=grp4)
ctfZoneTouchedColorInput 			= input.color(color.new(color.gray, 80), title="Zone Touched Color", group=grp4)

// Higher Timeframe Colors
htfSupplyZoneColorInput 			= input.color(color.new(color.maroon, 60), title="HTF Supply Zone Color", group=grp5)
htfSupplyZoneBorderColorInput 		= input.color(color.new(color.maroon, 30), title="HTF Supply Zone Border Color", group=grp5)
htfSupplyStrongMoveColorInput 		= input.color(color.new(color.maroon, 80), title="HTF Supply Strong Move Color", group=grp5)
htfSupplyStrongMoveBorderColorInput	= input.color(color.new(color.maroon, 50), title="HTF Supply Strong Move Border Color", group=grp5)
htfDemandZoneColorInput 			= input.color(color.new(color.teal, 60), title="HTF Demand Zone Color", group=grp5)
htfDemandZoneBorderColorInput 		= input.color(color.new(color.teal, 30), title="HTF Demand Zone Border Color", group=grp5)
htfDemandStrongMoveColorInput 		= input.color(color.new(color.teal, 80), title="HTF Demand Strong Move Color", group=grp5)
htfDemandStrongMoveBorderColorInput	= input.color(color.new(color.teal, 50), title="HTF Demand Strong Move Border Color", group=grp5)
htfZoneTouchedColorInput 			= input.color(color.new(color.gray, 70), title="HTF Zone Touched Color", group=grp5)

////////////////////////////////////////////////////////////////////////////////
//// Type Definitions
////////////////////////////////////////////////////////////////////////////////

type ZoneScore
	float strengthOfMove = na
	float timeAtZone = na
	float freshness = na
	float riskReward = na
	float originality = na
	float htfOverlappingZone = na

method total(ZoneScore score) =>
	score.strengthOfMove + score.timeAtZone + score.freshness + score.riskReward + score.originality + score.htfOverlappingZone

type StrongMove
	int dir = na
	int startLoc = na
	int endLoc = na
	float startPrice = na
	float endPrice = na
	float totalChange = na
	float highPrice = na
	float lowPrice = na
	int numberOfBars = na

type Zone
	int dir = na
	float top = na
	float btm = na
	int startLoc = na
	int endLoc = na
	StrongMove strongMove = na
	ZoneScore score = na
	bool crossed = false
	int crossedLoc = na
	bool touched = false
	int touchedLoc = na
	bool breaker = false
	bool brokeOpposingZone = false
	bool isHtf = false  // Flag to identify HTF zones

////////////////////////////////////////////////////////////////////////////////
//// Current Timeframe Data
////////////////////////////////////////////////////////////////////////////////

// DATA LOADING
float source = switch src_vol
	"No" => src
	'Volume' => math.sign(ta.change(close)) * volume
	'VolumeDiff' => volume

// CALCULATIONS
diff = src_vol == 'Volume' ? source : source[0] - math.avg(source[1], source[1], source[2])

// Use ta.sma and ta.stdev instead of array-based calculation
// This ensures the calculation works correctly with request.security for HTF
sampleAvg = ta.sma(diff, period)
sampleStdDev = ta.stdev(diff, period)

// Z-score
z = (diff - sampleAvg) / (sampleStdDev / math.sqrt(period))

// Get absolute value
z_abs = math.abs(z)

limit_first = ta.highest(z_abs, period) / 2

// Candle calculations
ma2 = ta.sma(close, 3)
maChange = ma2 - ma2[1]
candleBodyChange = close - open
candleBodyRange = math.abs(open - close)
candleRange = high - low
candleBodyUp = close > open
candleBodyDown = close < open
candleBodyHigh = close > open ? close : open
candleBodyLow = close > open ? open : close
topWickMidpoint = math.avg(high, candleBodyHigh)
btmWickMidpoint = math.avg(low, candleBodyLow)

////////////////////////////////////////////////////////////////////////////////
//// Higher Timeframe Data
////////////////////////////////////////////////////////////////////////////////

// For HTF, calculate z-score using close directly (not the input source)
// This ensures correct behavior with request.security
htfDiffForCalc = close - math.avg(close[1], close[1], close[2])
htfSampleAvgForCalc = ta.sma(htfDiffForCalc, period)
htfSampleStdDevForCalc = ta.stdev(htfDiffForCalc, period)
htfZForCalc = (htfDiffForCalc - htfSampleAvgForCalc) / (htfSampleStdDevForCalc / math.sqrt(period))
htfZAbsForCalc = math.abs(htfZForCalc)
htfLimitFirstForCalc = ta.highest(htfZAbsForCalc, period) / 2

// HTF OHLC and z-score data - request.security will evaluate these on HTF bars
[htfOpen, htfHigh, htfLow, htfClose, htfTime, htfZ_abs, htfLimitFirst] = request.security(syminfo.tickerid, htfTimeframe, [open, high, low, close, time, htfZAbsForCalc, htfLimitFirstForCalc], lookahead=barmerge.lookahead_off)

bool htfNewCandle = ta.change(htfTime) != 0

// HTF candle calculations
htfCandleBodyRange = math.abs(htfOpen - htfClose)
htfCandleRange = htfHigh - htfLow
htfCandleBodyUp = htfClose > htfOpen
htfCandleBodyDown = htfClose < htfOpen

// Debug labels for HTF detection
if showHtfDebugInput and htfNewCandle and htfEnabled
	htfCandleBodyDownPrev = htfClose[1] < htfOpen[1]
	htfCandleBodyUpPrev = htfClose[1] > htfOpen[1]
	passesSupplyCondition = htfZ_abs[1] > htfLimitFirst[1] and htfCandleBodyDownPrev
	passesDemandCondition = htfZ_abs[1] > htfLimitFirst[1] and htfCandleBodyUpPrev
	debugText = "HTF New Candle\nZ:" + str.tostring(htfZ_abs[1], "#.##") + " L:" + str.tostring(htfLimitFirst[1], "#.##") + "\nDown:" + str.tostring(htfCandleBodyDownPrev) + " Up:" + str.tostring(htfCandleBodyUpPrev) + "\nSupply:" + str.tostring(passesSupplyCondition) + " Demand:" + str.tostring(passesDemandCondition)
	label.new(bar_index, high, debugText, style=label.style_label_down, color=color.new(color.blue, 70), textcolor=color.white, size=size.tiny)

////////////////////////////////////////////////////////////////////////////////
//// Zone Arrays
////////////////////////////////////////////////////////////////////////////////

// Current Timeframe Zones
var ctfSupplyZones = array.new<Zone>(0)
var ctfDemandZones = array.new<Zone>(0)
var ctfUnbrokenSupplyZones = array.new<Zone>(0)
var ctfUnbrokenDemandZones = array.new<Zone>(0)

// Higher Timeframe Zones
var htfSupplyZones = array.new<Zone>(0)
var htfDemandZones = array.new<Zone>(0)
var htfUnbrokenSupplyZones = array.new<Zone>(0)
var htfUnbrokenDemandZones = array.new<Zone>(0)

// Tracking lists
var recentZoneCreationList = array.new<int>(0)
var recentZoneCrossedList = array.new<int>(0)
var Zone mostRecentSupplyZone = na
var Zone mostRecentDemandZone = na

// Alert variables - CTF
var bool ctfSupplyZoneCreated = false
var bool ctfDemandZoneCreated = false
var float ctfSupplyZoneCreatedTop = na
var float ctfSupplyZoneCreatedBtm = na
var float ctfDemandZoneCreatedTop = na
var float ctfDemandZoneCreatedBtm = na

var bool ctfSupplyZoneCrossed = false
var bool ctfDemandZoneCrossed = false
var float ctfSupplyZoneCrossedTop = na
var float ctfSupplyZoneCrossedBtm = na
var float ctfDemandZoneCrossedTop = na
var float ctfDemandZoneCrossedBtm = na

var bool ctfSupplyZoneTouched = false
var bool ctfDemandZoneTouched = false
var float ctfSupplyZoneTouchedTop = na
var float ctfSupplyZoneTouchedBtm = na
var float ctfDemandZoneTouchedTop = na
var float ctfDemandZoneTouchedBtm = na

// Alert variables - HTF
var bool htfSupplyZoneCreated = false
var bool htfDemandZoneCreated = false
var float htfSupplyZoneCreatedTop = na
var float htfSupplyZoneCreatedBtm = na
var float htfDemandZoneCreatedTop = na
var float htfDemandZoneCreatedBtm = na

var bool htfSupplyZoneCrossed = false
var bool htfDemandZoneCrossed = false
var float htfSupplyZoneCrossedTop = na
var float htfSupplyZoneCrossedBtm = na
var float htfDemandZoneCrossedTop = na
var float htfDemandZoneCrossedBtm = na

var bool htfSupplyZoneTouched = false
var bool htfDemandZoneTouched = false
var float htfSupplyZoneTouchedTop = na
var float htfSupplyZoneTouchedBtm = na
var float htfDemandZoneTouchedTop = na
var float htfDemandZoneTouchedBtm = na

////////////////////////////////////////////////////////////////////////////////
//// Helper Methods
////////////////////////////////////////////////////////////////////////////////

method getStrengthOfMove(Zone zone, int swingLength) =>
	zone.top - zone.btm

method getTimeAtZone(Zone zone, int minBars, int maxBars) =>
	minMaxDiff = maxBars - minBars
	bucketSize = minMaxDiff / 3
	b1 = math.floor(minBars + bucketSize)
	b2 = math.floor(minBars + (bucketSize * 2))
	b3 = maxBars
	bars = zone.endLoc - zone.startLoc
	score = bars > minBars and bars < b1 ? 3 : bars > b1 and bars < b2 ? 2 : bars > b2 and bars < b3 ? 1 : 0
	zone.score.timeAtZone := score
	zone

getLeadingDownCandles(startOffset) =>
	var leadingCandles = 0
	for i = startOffset to startOffset + 10
		if close[i] > open[i]
			leadingCandles := leadingCandles + 1
		else
			break
	leadingCandles

////////////////////////////////////////////////////////////////////////////////
//// CTF Zone Detection Functions
////////////////////////////////////////////////////////////////////////////////

identifyCtfSupplyZone() =>
	var StrongMove move = na
	var Zone zone = na
	var bool hasExplosiveCandle = false
	var float maxDeviation = 0
	prevZone = array.size(ctfSupplyZones) > 0 ? array.get(ctfSupplyZones, 0) : na
	prevMove = not na(prevZone) ? prevZone.strongMove : na
	prevMoveInProgress = not na(prevMove) ? prevMove.endLoc >= bar_index - 1 : false
	prevClose = close[1]

	// Get StrongMove
	if z_abs > limit_first and candleBodyDown
		maxDeviation := math.max(z_abs, maxDeviation)
		move := StrongMove.new(dir=-1, startLoc=bar_index, endLoc=bar_index, startPrice=math.max(close[1], open), endPrice=close, totalChange=0, highPrice=math.max(close[1], high), lowPrice=low, numberOfBars=0)
		for i = 0 to 40
			explosiveCandle = z_abs[i] > limit_second and candleBodyDown[i] and candleBodyRange[i] / candleRange[i] > 0.4
			strongCandle = z_abs[i] > limit_first and z_abs[i] < limit_second and candleBodyDown[i]
			if explosiveCandle
				maxDeviation := math.max(z_abs[i], maxDeviation)
				move.startLoc := move.startLoc - 1
				move.startPrice := math.max(close[i + 1], open[i])
				move.highPrice := math.max(move.highPrice, close[i + 1], high[i])
				move.lowPrice := math.min(move.lowPrice, low[i])
				move.totalChange := move.endPrice - move.startPrice
				move.numberOfBars := move.numberOfBars + 1
				hasExplosiveCandle := true
			else
				break
		if not hasExplosiveCandle
			move := na
		else if prevMoveInProgress
			array.shift(ctfSupplyZones)
		halfMaxDeviation = maxDeviation / 2
		// Get Zone
		if not na(move)
			prevZone := array.size(ctfSupplyZones) > 0 ? array.get(ctfSupplyZones, 0) : na
			if na(zone)
				zone := Zone.new(dir=-1, top=math.max(move.highPrice, high[move.numberOfBars]), btm=math.min(move.startPrice, low[move.numberOfBars]), startLoc=move.startLoc - 1, endLoc=move.endLoc, strongMove=move, score=ZoneScore.new(strengthOfMove=0, timeAtZone=0, freshness=0, riskReward=0, originality=0, htfOverlappingZone=0), crossed=false, crossedLoc=na, touched=false, touchedLoc=na, isHtf=false)

	if not na(move) and not na(zone)
		if zone.endLoc - zone.startLoc > 0 and (zone.btm - move.endPrice) / (zone.top - zone.btm) > minMoveToZoneRatioInput
			array.unshift(ctfSupplyZones, zone)
		else
			zone := na
			move := na

	if not na(zone)
		array.unshift(ctfUnbrokenSupplyZones, zone)

	if array.size(ctfSupplyZones) > maxNumberOfZonesInput
		array.pop(ctfSupplyZones)
	if array.size(ctfUnbrokenSupplyZones) > maxNumberOfZonesInput
		array.pop(ctfUnbrokenSupplyZones)

	result = zone
	zone := na
	move := na
	hasExplosiveCandle := false
	maxDeviation := 0
	result


identifyCtfDemandZone() =>
	var StrongMove move = na
	var Zone zone = na
	var bool hasExplosiveCandle = false
	var float maxDeviation = 0
	prevZone = array.size(ctfDemandZones) > 0 ? array.get(ctfDemandZones, 0) : na
	prevMove = not na(prevZone) ? prevZone.strongMove : na
	prevMoveInProgress = not na(prevMove) ? prevMove.endLoc >= bar_index - 1 : false

	// Get StrongMove
	if z_abs > limit_first and candleBodyUp
		maxDeviation := math.max(z_abs, maxDeviation)
		move := StrongMove.new(dir=1, startLoc=bar_index, endLoc=bar_index, startPrice=math.min(close[1], open), endPrice=close, totalChange=0, highPrice=high, lowPrice=math.min(close[1], low), numberOfBars=0)
		for i = 0 to 40
			explosiveCandle = z_abs[i] > limit_second and candleBodyUp[i] and candleBodyRange[i] / candleRange[i] > 0.4
			strongCandle = z_abs[i] > limit_first and z_abs[i] < limit_second and candleBodyUp[i]
			if explosiveCandle
				maxDeviation := math.max(z_abs[i], maxDeviation)
				move.startLoc := move.startLoc - 1
				move.startPrice := math.min(close[i + 1], open[i])
				move.highPrice := math.max(move.highPrice, high[i])
				move.lowPrice := math.min(move.lowPrice, close[i + 1], low[i])
				move.totalChange := move.endPrice - move.startPrice
				move.numberOfBars := move.numberOfBars + 1
				hasExplosiveCandle := true
			else
				break
		if not hasExplosiveCandle
			move := na
		else if prevMoveInProgress
			array.shift(ctfDemandZones)
		halfMaxDeviation = maxDeviation / 2
		// Get Zone
		if not na(move)
			prevZone := array.size(ctfDemandZones) > 0 ? array.get(ctfDemandZones, 0) : na
			if na(zone)
				zone := Zone.new(dir=1, top=math.max(move.startPrice, high[move.numberOfBars]), btm=math.min(move.lowPrice, low[move.numberOfBars]), startLoc=move.startLoc - 1, endLoc=move.endLoc, strongMove=move, score=ZoneScore.new(strengthOfMove=0, timeAtZone=0, freshness=0, riskReward=0, originality=0, htfOverlappingZone=0), crossed=false, crossedLoc=na, touched=false, touchedLoc=na, isHtf=false)

	if not na(move) and not na(zone)
		if zone.endLoc - zone.startLoc > 0 and (move.endPrice - zone.top) / (zone.top - zone.btm) > minMoveToZoneRatioInput
			array.unshift(ctfDemandZones, zone)
		else
			zone := na
			move := na

	if not na(zone)
		array.unshift(ctfUnbrokenDemandZones, zone)

	if array.size(ctfDemandZones) > maxNumberOfZonesInput
		array.pop(ctfDemandZones)
	if array.size(ctfUnbrokenDemandZones) > maxNumberOfZonesInput
		array.pop(ctfUnbrokenDemandZones)

	result = zone
	zone := na
	move := na
	hasExplosiveCandle := false
	maxDeviation := 0
	result

////////////////////////////////////////////////////////////////////////////////
//// HTF Zone Detection Functions
////////////////////////////////////////////////////////////////////////////////

// Track HTF candle history for zone detection
var float[] htfHighHist = array.new<float>(50, na)
var float[] htfLowHist = array.new<float>(50, na)
var float[] htfOpenHist = array.new<float>(50, na)
var float[] htfCloseHist = array.new<float>(50, na)
var float[] htfZAbsHist = array.new<float>(50, na)
var int[] htfBarIndexHist = array.new<int>(50, na)

// Update HTF history on new HTF candle
if htfNewCandle and htfEnabled
	array.unshift(htfHighHist, htfHigh[1])
	array.unshift(htfLowHist, htfLow[1])
	array.unshift(htfOpenHist, htfOpen[1])
	array.unshift(htfCloseHist, htfClose[1])
	array.unshift(htfZAbsHist, htfZ_abs[1])
	array.unshift(htfBarIndexHist, bar_index)
	if array.size(htfHighHist) > 50
		array.pop(htfHighHist)
		array.pop(htfLowHist)
		array.pop(htfOpenHist)
		array.pop(htfCloseHist)
		array.pop(htfZAbsHist)
		array.pop(htfBarIndexHist)

identifyHtfSupplyZone() =>
	var StrongMove move = na
	var Zone zone = na
	var bool hasExplosiveCandle = false
	var float maxDeviation = 0

	if htfEnabled and htfNewCandle
		prevZone = array.size(htfSupplyZones) > 0 ? array.get(htfSupplyZones, 0) : na
		prevMove = not na(prevZone) ? prevZone.strongMove : na
		prevMoveInProgress = not na(prevMove) ? prevMove.endLoc >= bar_index - 5 : false

		// Use completed HTF candle data
		htfCandleBodyDownCurrent = htfClose[1] < htfOpen[1]
		htfCandleBodyRangeCurrent = math.abs(htfOpen[1] - htfClose[1])
		htfCandleRangeCurrent = htfHigh[1] - htfLow[1]

		// Get StrongMove - use [1] for both to compare the completed HTF candle
		if htfZ_abs[1] > htfLimitFirst[1] and htfCandleBodyDownCurrent
			maxDeviation := math.max(htfZ_abs[1], maxDeviation)
			move := StrongMove.new(dir=-1, startLoc=bar_index, endLoc=bar_index, startPrice=math.max(htfClose[2], htfOpen[1]), endPrice=htfClose[1], totalChange=0, highPrice=math.max(htfClose[2], htfHigh[1]), lowPrice=htfLow[1], numberOfBars=0)

			for i = 0 to math.min(40, array.size(htfZAbsHist) - 1)
				histZAbs = array.get(htfZAbsHist, i)
				histOpen = array.get(htfOpenHist, i)
				histClose = array.get(htfCloseHist, i)
				histHigh = array.get(htfHighHist, i)
				histLow = array.get(htfLowHist, i)
				histBarIndex = array.get(htfBarIndexHist, i)

				if na(histZAbs) or na(histOpen) or na(histClose)
					break

				histBodyDown = histClose < histOpen
				histBodyRange = math.abs(histOpen - histClose)
				histRange = histHigh - histLow

				explosiveCandle = histZAbs > limit_second and histBodyDown and histRange > 0 and histBodyRange / histRange > 0.4

				if explosiveCandle
					maxDeviation := math.max(histZAbs, maxDeviation)
					move.startLoc := histBarIndex
					prevClose = i + 1 < array.size(htfCloseHist) ? array.get(htfCloseHist, i + 1) : histOpen
					move.startPrice := math.max(nz(prevClose, histOpen), histOpen)
					move.highPrice := math.max(move.highPrice, nz(prevClose, histHigh), histHigh)
					move.lowPrice := math.min(move.lowPrice, histLow)
					move.totalChange := move.endPrice - move.startPrice
					move.numberOfBars := move.numberOfBars + 1
					hasExplosiveCandle := true
				else
					break

			if not hasExplosiveCandle
				move := na
			else if prevMoveInProgress
				if array.size(htfSupplyZones) > 0
					array.shift(htfSupplyZones)

			// Get Zone - extend to include the base candle (like CTF does)
			if not na(move)
				prevZone := array.size(htfSupplyZones) > 0 ? array.get(htfSupplyZones, 0) : na
				if na(zone)
					// Get base candle high/low from history to extend the zone
					baseIndex = move.numberOfBars
					baseHigh = baseIndex < array.size(htfHighHist) ? nz(array.get(htfHighHist, baseIndex), move.highPrice) : move.highPrice
					baseLow = baseIndex < array.size(htfLowHist) ? nz(array.get(htfLowHist, baseIndex), move.startPrice) : move.startPrice
					zoneTop = math.max(move.highPrice, baseHigh)
					zoneBtm = math.min(move.startPrice, baseLow)
					zone := Zone.new(dir=-1, top=zoneTop, btm=zoneBtm, startLoc=move.startLoc, endLoc=move.endLoc, strongMove=move, score=ZoneScore.new(strengthOfMove=0, timeAtZone=0, freshness=0, riskReward=0, originality=0, htfOverlappingZone=0), crossed=false, crossedLoc=na, touched=false, touchedLoc=na, isHtf=true)

		if not na(move) and not na(zone)
			zoneHeight = zone.top - zone.btm
			moveDistance = zone.btm - move.endPrice
			if zoneHeight > 0 and moveDistance / zoneHeight > minMoveToZoneRatioInput
				array.unshift(htfSupplyZones, zone)
			else
				zone := na
				move := na

		if not na(zone)
			array.unshift(htfUnbrokenSupplyZones, zone)

		if array.size(htfSupplyZones) > htfMaxNumberOfZonesInput
			array.pop(htfSupplyZones)
		if array.size(htfUnbrokenSupplyZones) > htfMaxNumberOfZonesInput
			array.pop(htfUnbrokenSupplyZones)

	result = zone
	zone := na
	move := na
	hasExplosiveCandle := false
	maxDeviation := 0
	result


identifyHtfDemandZone() =>
	var StrongMove move = na
	var Zone zone = na
	var bool hasExplosiveCandle = false
	var float maxDeviation = 0

	if htfEnabled and htfNewCandle
		prevZone = array.size(htfDemandZones) > 0 ? array.get(htfDemandZones, 0) : na
		prevMove = not na(prevZone) ? prevZone.strongMove : na
		prevMoveInProgress = not na(prevMove) ? prevMove.endLoc >= bar_index - 5 : false

		// Use completed HTF candle data
		htfCandleBodyUpCurrent = htfClose[1] > htfOpen[1]
		htfCandleBodyRangeCurrent = math.abs(htfOpen[1] - htfClose[1])
		htfCandleRangeCurrent = htfHigh[1] - htfLow[1]

		// Get StrongMove
		// Get StrongMove - use [1] for both to compare the completed HTF candle
		if htfZ_abs[1] > htfLimitFirst[1] and htfCandleBodyUpCurrent
			maxDeviation := math.max(htfZ_abs[1], maxDeviation)
			move := StrongMove.new(dir=1, startLoc=bar_index, endLoc=bar_index, startPrice=math.min(htfClose[2], htfOpen[1]), endPrice=htfClose[1], totalChange=0, highPrice=htfHigh[1], lowPrice=math.min(htfClose[2], htfLow[1]), numberOfBars=0)

			for i = 0 to math.min(40, array.size(htfZAbsHist) - 1)
				histZAbs = array.get(htfZAbsHist, i)
				histOpen = array.get(htfOpenHist, i)
				histClose = array.get(htfCloseHist, i)
				histHigh = array.get(htfHighHist, i)
				histLow = array.get(htfLowHist, i)
				histBarIndex = array.get(htfBarIndexHist, i)

				if na(histZAbs) or na(histOpen) or na(histClose)
					break

				histBodyUp = histClose > histOpen
				histBodyRange = math.abs(histOpen - histClose)
				histRange = histHigh - histLow

				explosiveCandle = histZAbs > limit_second and histBodyUp and histRange > 0 and histBodyRange / histRange > 0.4

				if explosiveCandle
					maxDeviation := math.max(histZAbs, maxDeviation)
					move.startLoc := histBarIndex
					prevClose = i + 1 < array.size(htfCloseHist) ? array.get(htfCloseHist, i + 1) : histOpen
					move.startPrice := math.min(nz(prevClose, histOpen), histOpen)
					move.highPrice := math.max(move.highPrice, histHigh)
					move.lowPrice := math.min(move.lowPrice, nz(prevClose, histLow), histLow)
					move.totalChange := move.endPrice - move.startPrice
					move.numberOfBars := move.numberOfBars + 1
					hasExplosiveCandle := true
				else
					break

			if not hasExplosiveCandle
				move := na
			else if prevMoveInProgress
				if array.size(htfDemandZones) > 0
					array.shift(htfDemandZones)

			// Get Zone - extend to include the base candle (like CTF does)
			if not na(move)
				prevZone := array.size(htfDemandZones) > 0 ? array.get(htfDemandZones, 0) : na
				if na(zone)
					// Get base candle high/low from history to extend the zone
					baseIndex = move.numberOfBars
					baseHigh = baseIndex < array.size(htfHighHist) ? nz(array.get(htfHighHist, baseIndex), move.startPrice) : move.startPrice
					baseLow = baseIndex < array.size(htfLowHist) ? nz(array.get(htfLowHist, baseIndex), move.lowPrice) : move.lowPrice
					zoneTop = math.max(move.startPrice, baseHigh)
					zoneBtm = math.min(move.lowPrice, baseLow)
					zone := Zone.new(dir=1, top=zoneTop, btm=zoneBtm, startLoc=move.startLoc, endLoc=move.endLoc, strongMove=move, score=ZoneScore.new(strengthOfMove=0, timeAtZone=0, freshness=0, riskReward=0, originality=0, htfOverlappingZone=0), crossed=false, crossedLoc=na, touched=false, touchedLoc=na, isHtf=true)

		if not na(move) and not na(zone)
			zoneHeight = zone.top - zone.btm
			moveDistance = move.endPrice - zone.top
			if zoneHeight > 0 and moveDistance / zoneHeight > minMoveToZoneRatioInput
				array.unshift(htfDemandZones, zone)
			else
				zone := na
				move := na

		if not na(zone)
			array.unshift(htfUnbrokenDemandZones, zone)

		if array.size(htfDemandZones) > htfMaxNumberOfZonesInput
			array.pop(htfDemandZones)
		if array.size(htfUnbrokenDemandZones) > htfMaxNumberOfZonesInput
			array.pop(htfUnbrokenDemandZones)

	result = zone
	zone := na
	move := na
	hasExplosiveCandle := false
	maxDeviation := 0
	result

////////////////////////////////////////////////////////////////////////////////
//// Display Functions
////////////////////////////////////////////////////////////////////////////////

displayStrongMove(StrongMove move, color strongMoveCss, color strongMoveBorderCss) =>
	if bar_index - move.startLoc < 4000
		box.new(move.startLoc, move.highPrice, move.endLoc + 1, move.lowPrice, bgcolor = strongMoveCss, border_color = strongMoveBorderCss)

displayZone(Zone zn, color zoneCss, color zoneBorderCss, color strongMoveCss, color strongMoveBorderCss, color zoneTouchedCss, bool showStrongMoves) =>
	if bar_index - zn.startLoc < 4000
		zoneEnd = brokenWhenTouchedInput ? (zn.touched ? zn.touchedLoc : last_bar_index) : (zn.crossed ? zn.crossedLoc : last_bar_index)
		box.new(zn.startLoc, zn.top, zoneEnd + 1, zn.btm, bgcolor = changeColorOnTouchedInput and zn.touched ? zoneTouchedCss : zoneCss, border_color = zoneBorderCss)
		if showStrongMoves
			displayStrongMove(zn.strongMove, strongMoveCss, strongMoveBorderCss)

displayZoneList(array<Zone> zoneList, color zoneCss, color zoneBorderCss, color strongMoveCss, color strongMoveBorderCss, color zoneTouchedCss, bool showZones, bool showStrongMoves) =>
	if barstate.islast and showZones
		if zoneList.size() > 0
			for i = 0 to zoneList.size() - 1
				zn = zoneList.get(i)
				displayZone(zn, zoneCss, zoneBorderCss, strongMoveCss, strongMoveBorderCss, zoneTouchedCss, showStrongMoves)

////////////////////////////////////////////////////////////////////////////////
//// Zone Status Update Functions
////////////////////////////////////////////////////////////////////////////////

updateZoneStatus(array<Zone> zones, bool isSupplyZone) =>
	if array.size(zones) > 0
		for i = 0 to array.size(zones) - 1
			zn = array.get(zones, i)
			if zn.endLoc < bar_index
				if isSupplyZone  // Supply zone (dir == -1)
					if not zn.crossed and high > zn.top
						zn.crossed := true
						zn.crossedLoc := bar_index
					if not zn.touched and high > zn.btm
						zn.touched := true
						zn.touchedLoc := bar_index
				else  // Demand zone (dir == 1)
					if not zn.crossed and low < zn.btm
						zn.crossed := true
						zn.crossedLoc := bar_index
					if not zn.touched and low < zn.top
						zn.touched := true
						zn.touchedLoc := bar_index

////////////////////////////////////////////////////////////////////////////////
//// Main Logic
////////////////////////////////////////////////////////////////////////////////

// Detect CTF Zones
ctfSZone = identifyCtfSupplyZone()
ctfDZone = identifyCtfDemandZone()

if not na(ctfSZone)
	ctfSupplyZoneCreated := true
	ctfSupplyZoneCreatedTop := ctfSZone.top
	ctfSupplyZoneCreatedBtm := ctfSZone.btm

if not na(ctfDZone)
	ctfDemandZoneCreated := true
	ctfDemandZoneCreatedTop := ctfDZone.top
	ctfDemandZoneCreatedBtm := ctfDZone.btm

// Detect HTF Zones
htfSZone = identifyHtfSupplyZone()
htfDZone = identifyHtfDemandZone()

if not na(htfSZone)
	htfSupplyZoneCreated := true
	htfSupplyZoneCreatedTop := htfSZone.top
	htfSupplyZoneCreatedBtm := htfSZone.btm

if not na(htfDZone)
	htfDemandZoneCreated := true
	htfDemandZoneCreatedTop := htfDZone.top
	htfDemandZoneCreatedBtm := htfDZone.btm

// Update zone status (touched/crossed)
updateZoneStatus(ctfSupplyZones, true)
updateZoneStatus(ctfDemandZones, false)
updateZoneStatus(htfSupplyZones, true)
updateZoneStatus(htfDemandZones, false)

////////////////////////////////////////////////////////////////////////////////
//// Plotting
////////////////////////////////////////////////////////////////////////////////

// Clear all boxes each bar (will be redrawn)
for bx in box.all
	bx.delete()

for l in line.all
	l.delete()

// Display CTF Zones
displayZoneList(ctfSupplyZones, ctfSupplyZoneColorInput, ctfSupplyZoneBorderColorInput, ctfSupplyStrongMoveColorInput, ctfSupplyStrongMoveBorderColorInput, ctfZoneTouchedColorInput, showCtfZonesInput, showCtfStrongMovesInput)
displayZoneList(ctfDemandZones, ctfDemandZoneColorInput, ctfDemandZoneBorderColorInput, ctfDemandStrongMoveColorInput, ctfDemandStrongMoveBorderColorInput, ctfZoneTouchedColorInput, showCtfZonesInput, showCtfStrongMovesInput)

// Display HTF Zones
if htfEnabled
	displayZoneList(htfSupplyZones, htfSupplyZoneColorInput, htfSupplyZoneBorderColorInput, htfSupplyStrongMoveColorInput, htfSupplyStrongMoveBorderColorInput, htfZoneTouchedColorInput, showHtfZonesInput, showHtfStrongMovesInput)
	displayZoneList(htfDemandZones, htfDemandZoneColorInput, htfDemandZoneBorderColorInput, htfDemandStrongMoveColorInput, htfDemandStrongMoveBorderColorInput, htfZoneTouchedColorInput, showHtfZonesInput, showHtfStrongMovesInput)

////////////////////////////////////////////////////////////////////////////////
//// Alerts
////////////////////////////////////////////////////////////////////////////////

// CTF Alert Plots
plot(ctfSupplyZoneCreatedTop, title = "CTF Supply Zone Created Top", display=display.none)
plot(ctfSupplyZoneCreatedBtm, title = "CTF Supply Zone Created Bottom", display=display.none)
plot(ctfDemandZoneCreatedTop, title = "CTF Demand Zone Created Top", display=display.none)
plot(ctfDemandZoneCreatedBtm, title = "CTF Demand Zone Created Bottom", display=display.none)

// HTF Alert Plots
plot(htfSupplyZoneCreatedTop, title = "HTF Supply Zone Created Top", display=display.none)
plot(htfSupplyZoneCreatedBtm, title = "HTF Supply Zone Created Bottom", display=display.none)
plot(htfDemandZoneCreatedTop, title = "HTF Demand Zone Created Top", display=display.none)
plot(htfDemandZoneCreatedBtm, title = "HTF Demand Zone Created Bottom", display=display.none)

// CTF Alerts
alertcondition(ctfSupplyZoneCreated, title = "CTF Supply Zone Created", message = 'CTF Supply Zone Created, Top: {{plot("CTF Supply Zone Created Top")}}, Bottom: {{plot("CTF Supply Zone Created Bottom")}}')
alertcondition(ctfDemandZoneCreated, title = "CTF Demand Zone Created", message = 'CTF Demand Zone Created, Top: {{plot("CTF Demand Zone Created Top")}}, Bottom: {{plot("CTF Demand Zone Created Bottom")}}')

// HTF Alerts
alertcondition(htfSupplyZoneCreated, title = "HTF Supply Zone Created", message = 'HTF Supply Zone Created, Top: {{plot("HTF Supply Zone Created Top")}}, Bottom: {{plot("HTF Supply Zone Created Bottom")}}')
alertcondition(htfDemandZoneCreated, title = "HTF Demand Zone Created", message = 'HTF Demand Zone Created, Top: {{plot("HTF Demand Zone Created Top")}}, Bottom: {{plot("HTF Demand Zone Created Bottom")}}')

// Reset alert flags
ctfSupplyZoneCreated := false
ctfSupplyZoneCreatedTop := na
ctfSupplyZoneCreatedBtm := na

ctfDemandZoneCreated := false
ctfDemandZoneCreatedTop := na
ctfDemandZoneCreatedBtm := na

htfSupplyZoneCreated := false
htfSupplyZoneCreatedTop := na
htfSupplyZoneCreatedBtm := na

htfDemandZoneCreated := false
htfDemandZoneCreatedTop := na
htfDemandZoneCreatedBtm := na
