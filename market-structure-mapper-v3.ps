// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © scientificbest

//@version=5
indicator("Market Structure Mapper V3 (Multi-Timeframe)", "MSM V3 [SB]", overlay=true, max_lines_count=250, max_labels_count=250)

// Input settings
showHighLowLabels = input.bool(true, "Show High/Low Labels", group="Display")
showBosLabels = input.bool(false, "Show BOS Labels", group="Display")
lineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="Display")

// Higher Timeframe Settings
htfEnabled = input.bool(true, "Show HTF Structure", group="Higher Timeframe")
htfTimeframe = input.timeframe("60", "HTF Timeframe", group="Higher Timeframe")

// Current Timeframe Colors
highColor = input.color(color.new(color.orange, 0), "Valid High Color", group="Current TF Colors")
lowColor = input.color(color.new(color.blue, 0), "Valid Low Color", group="Current TF Colors")
bosColor = input.color(color.new(color.black, 0), "BOS Color", group="Current TF Colors")

// Higher Timeframe Colors
htfHighColor = input.color(color.new(color.red, 0), "HTF Valid High Color", group="HTF Colors")
htfLowColor = input.color(color.new(color.green, 0), "HTF Valid Low Color", group="HTF Colors")
htfBosColor = input.color(color.new(color.black, 0), "HTF BOS Color", group="HTF Colors")

// Arrays to store all historical highs and lows
var array<float> highLevels = array.new<float>()
var array<int> highBars = array.new<int>()
var array<line> highLines = array.new<line>()
var array<bool> highBroken = array.new<bool>()
var array<bool> highSweeped = array.new<bool>()

var array<float> lowLevels = array.new<float>()
var array<int> lowBars = array.new<int>()
var array<line> lowLines = array.new<line>()
var array<bool> lowBroken = array.new<bool>()
var array<bool> lowSweeped = array.new<bool>()

// Variables to track current market structure
var float currentValidHigh = na
var float currentValidLow = na
var int currentValidHighBar = na
var int currentValidLowBar = na
var bool initialized = false
var bool lookingForLow = false
var bool lookingForHigh = false
var bool currentHighIsWeak = false  // True if formed via BOS, false if formed via breakdown
var bool currentLowIsWeak = false   // True if formed via BOS, false if formed via breakout
var bool currentHighIsBroken = false  // True if high was broken and not yet replaced
var bool currentLowIsBroken = false   // True if low was broken and not yet replaced

// Track indices of most recent high/low for solid line display and BOS detection
var int mostRecentHighIndex = -1
var int mostRecentLowIndex = -1

// HTF Arrays to store all historical highs and lows
var array<float> htfHighLevels = array.new<float>()
var array<int> htfHighBars = array.new<int>()
var array<line> htfHighLines = array.new<line>()
var array<bool> htfHighBroken = array.new<bool>()
var array<bool> htfHighSweeped = array.new<bool>()

var array<float> htfLowLevels = array.new<float>()
var array<int> htfLowBars = array.new<int>()
var array<line> htfLowLines = array.new<line>()
var array<bool> htfLowBroken = array.new<bool>()
var array<bool> htfLowSweeped = array.new<bool>()

// HTF Variables to track current market structure
var float htfCurrentValidHigh = na
var float htfCurrentValidLow = na
var int htfCurrentValidHighBar = na
var int htfCurrentValidLowBar = na
var bool htfInitialized = false
var bool htfLookingForLow = false
var bool htfLookingForHigh = false
var bool htfCurrentHighIsWeak = false  // True if formed via BOS, false if formed via breakdown
var bool htfCurrentLowIsWeak = false   // True if formed via BOS, false if formed via breakout
var bool htfCurrentHighIsBroken = false  // True if high was broken and not yet replaced
var bool htfCurrentLowIsBroken = false   // True if low was broken and not yet replaced

// Track the range extremes as HTF structure develops (instead of searching backwards)
var float htfSwingLow = na       // Tracks lowest low since last valid high
var int htfSwingLowBar = na
var float htfSwingHigh = na      // Tracks highest high since last valid low
var int htfSwingHighBar = na

// HTF Track indices of most recent high/low
var int htfMostRecentHighIndex = -1
var int htfMostRecentLowIndex = -1

// Labels for current levels (positioned to the right of chart)
var label currentHighLabel = na
var label currentLowLabel = na
var label htfCurrentHighLabel = na
var label htfCurrentLowLabel = na

// Arrays to store swept level labels
var array<label> sweptHighLabels = array.new<label>()
var array<label> sweptLowLabels = array.new<label>()
var array<label> htfSweptHighLabels = array.new<label>()
var array<label> htfSweptLowLabels = array.new<label>()

// Labels for "looking for" states (when a level was broken and we're seeking replacement)
var label htfLookingForHighLabel = na
var label htfLookingForLowLabel = na

// Helper function: Check if current candle is bearish and closes below previous candle's low
isBearishBreakdown() =>
    close < open and close < low[1]

// Helper function: Check if current candle is bullish and closes above previous candle's high
isBullishBreakout() =>
    close > open and close > high[1]

// Helper function: Find lowest low between two bar indices
findLowestBetween(startBar, endBar) =>
    float lowestPrice = na
    int lowestBarIndex = na
    
    int start = startBar
    int end = endBar
    
    if start > end
        int temp = start
        start := end
        end := temp
    
    int currentBar = bar_index
    int lookbackStart = currentBar - end
    int lookbackEnd = currentBar - start - 1
    
    lookbackStart := math.max(lookbackStart, 0)
    lookbackEnd := math.min(lookbackEnd, 5000)
    
    if lookbackStart <= lookbackEnd
        for i = lookbackStart to lookbackEnd
            if not na(low[i])
                if na(lowestPrice) or low[i] < lowestPrice
                    lowestPrice := low[i]
                    lowestBarIndex := currentBar - i
    
    [lowestPrice, lowestBarIndex]

// Helper function: Find highest high between two bar indices
findHighestBetween(startBar, endBar) =>
    float highestPrice = na
    int highestBarIndex = na
    
    int start = startBar
    int end = endBar
    
    if start > end
        int temp = start
        start := end
        end := temp
    
    int currentBar = bar_index
    int lookbackStart = currentBar - end
    int lookbackEnd = currentBar - start - 1
    
    lookbackStart := math.max(lookbackStart, 0)
    lookbackEnd := math.min(lookbackEnd, 5000)
    
    if lookbackStart <= lookbackEnd
        for i = lookbackStart to lookbackEnd
            if not na(high[i])
                if na(highestPrice) or high[i] > highestPrice
                    highestPrice := high[i]
                    highestBarIndex := currentBar - i
    
    [highestPrice, highestBarIndex]

// HTF Helper function: Find lowest low between two bar indices using HTF data
findLowestBetweenHTF(startBar, endBar, htfLowData) =>
    float lowestPrice = na
    int lowestBarIndex = na

    int start = startBar
    int end = endBar

    if start > end
        int temp = start
        start := end
        end := temp

    int currentBar = bar_index
    int lookbackStart = currentBar - end
    int lookbackEnd = currentBar - start - 1

    lookbackStart := math.max(lookbackStart, 0)
    // Limit lookback to 50 bars max for HTF data to avoid buffer overflow
    // HTF data from request.security has limited historical buffer
    lookbackEnd := math.min(lookbackEnd, 100)
    lookbackStart := math.min(lookbackStart, 100)

    if lookbackStart <= lookbackEnd
        for i = lookbackStart to lookbackEnd
            if not na(htfLowData[i])
                if na(lowestPrice) or htfLowData[i] < lowestPrice
                    lowestPrice := htfLowData[i]
                    lowestBarIndex := currentBar - i

    [lowestPrice, lowestBarIndex]

// HTF Helper function: Find highest high between two bar indices using HTF data
findHighestBetweenHTF(startBar, endBar, htfHighData) =>
    float highestPrice = na
    int highestBarIndex = na

    int start = startBar
    int end = endBar

    if start > end
        int temp = start
        start := end
        end := temp

    int currentBar = bar_index
    int lookbackStart = currentBar - end
    int lookbackEnd = currentBar - start - 1

    lookbackStart := math.max(lookbackStart, 0)
    // Limit lookback to 50 bars max for HTF data to avoid buffer overflow
    // HTF data from request.security has limited historical buffer
    lookbackEnd := math.min(lookbackEnd, 100)
    lookbackStart := math.min(lookbackStart, 100)

    if lookbackStart <= lookbackEnd
        for i = lookbackStart to lookbackEnd
            if not na(htfHighData[i])
                if na(highestPrice) or htfHighData[i] > highestPrice
                    highestPrice := htfHighData[i]
                    highestBarIndex := currentBar - i

    [highestPrice, highestBarIndex]

// Function to add a new valid high
addValidHigh(float price, int barIdx) =>
    // Delete the previous most recent high line (if it exists and isn't already broken/sweeped)
    if mostRecentHighIndex >= 0
        prevHighBroken = array.get(highBroken, mostRecentHighIndex)
        prevHighSweeped = array.get(highSweeped, mostRecentHighIndex)
        // Only delete if it's still solid (not broken or sweeped yet)
        if not prevHighBroken and not prevHighSweeped
            prevLine = array.get(highLines, mostRecentHighIndex)
            line.delete(prevLine)
    
    array.push(highLevels, price)
    array.push(highBars, barIdx)
    array.push(highBroken, false)
    array.push(highSweeped, false)
    
    // Create horizontal line extending to the right (solid for most recent)
    newLine = line.new(barIdx, price, barIdx + 1, price, 
                       color=highColor, 
                       width=lineWidth, 
                       extend=extend.right,
                       style=line.style_solid)
    array.push(highLines, newLine)
    
    if showHighLowLabels
        newLabel = label.new(barIdx, price, "VH", 
                 style=label.style_label_down, 
                 color=highColor, 
                 textcolor=color.white, 
                 size=size.small)
    true

// Function to add a new valid low
addValidLow(float price, int barIdx) =>
    // Delete the previous most recent low line (if it exists and isn't already broken/sweeped)
    if mostRecentLowIndex >= 0
        prevLowBroken = array.get(lowBroken, mostRecentLowIndex)
        prevLowSweeped = array.get(lowSweeped, mostRecentLowIndex)
        // Only delete if it's still solid (not broken or sweeped yet)
        if not prevLowBroken and not prevLowSweeped
            prevLine = array.get(lowLines, mostRecentLowIndex)
            line.delete(prevLine)
    
    array.push(lowLevels, price)
    array.push(lowBars, barIdx)
    array.push(lowBroken, false)
    array.push(lowSweeped, false)
    
    // Create horizontal line extending to the right (solid for most recent)
    newLine = line.new(barIdx, price, barIdx + 1, price, 
                       color=lowColor, 
                       width=lineWidth, 
                       extend=extend.right,
                       style=line.style_solid)
    array.push(lowLines, newLine)
    
    if showHighLowLabels
        newLabel = label.new(barIdx, price, "VL", 
                 style=label.style_label_up, 
                 color=lowColor, 
                 textcolor=color.white, 
                 size=size.small)
    true

// Function to check and mark sweeped and broken levels
checkBrokenLevels() =>
    // Check highs for sweeps and breaks
    if array.size(highLevels) > 0
        for i = 0 to array.size(highLevels) - 1
            levelPrice = array.get(highLevels, i)
            isSweeped = array.get(highSweeped, i)
            isBroken = array.get(highBroken, i)
            
            // Check for sweep first (wick crosses but close doesn't)
            if not isSweeped and not isBroken and high > levelPrice and close <= levelPrice
                // Mark as sweeped
                array.set(highSweeped, i, true)
                
                // Update line: make dotted but keep extending right
                sweepedLine = array.get(highLines, i)
                line.set_style(sweepedLine, line.style_dotted)
                // Keep extend.right - line continues indefinitely
                true
            
            // Check for break (close crosses above)
            else if not isBroken and close > levelPrice
                // Mark as broken
                array.set(highBroken, i, true)
                
                brokenLine = array.get(highLines, i)
                
                // Only keep the line visible if this is a valid BOS (most recent high)
                if i == mostRecentHighIndex
                    // Get the bar where this level was created
                    levelBar = array.get(highBars, i)
                    
                    // Update line: stop extending, make dotted, cut off at break point, change to gray
                    line.set_x2(brokenLine, bar_index)
                    line.set_extend(brokenLine, extend.none)
                    line.set_style(brokenLine, line.style_dotted)
                    line.set_color(brokenLine, bosColor)  // Changed to gray
                    line.set_width(brokenLine, lineWidth)
                    
                    // Show BOS label if enabled
                    if showBosLabels
                        // Calculate center position: midpoint between level bar and break bar
                        centerBar = math.round((levelBar + bar_index) / 2)
                        // Place label at the level price (Y-axis centered on line)
                        bosLabel = label.new(centerBar, levelPrice, "BOS↑", 
                                 style=label.style_label_center, 
                                 color=color.white,
                                 textcolor=bosColor, 
                                 size=size.tiny)
                else
                    // Not a valid BOS, just delete the line
                    line.delete(brokenLine)
                
                true
    
    // Check lows for sweeps and breaks
    if array.size(lowLevels) > 0
        for i = 0 to array.size(lowLevels) - 1
            levelPrice = array.get(lowLevels, i)
            isSweeped = array.get(lowSweeped, i)
            isBroken = array.get(lowBroken, i)
            
            // Check for sweep first (wick crosses but close doesn't)
            if not isSweeped and not isBroken and low < levelPrice and close >= levelPrice
                // Mark as sweeped
                array.set(lowSweeped, i, true)
                
                // Update line: make dotted but keep extending right
                sweepedLine = array.get(lowLines, i)
                line.set_style(sweepedLine, line.style_dotted)
                // Keep extend.right - line continues indefinitely
                true
            
            // Check for break (close crosses below)
            else if not isBroken and close < levelPrice
                // Mark as broken
                array.set(lowBroken, i, true)
                
                brokenLine = array.get(lowLines, i)
                
                // Only keep the line visible if this is a valid BOS (most recent low)
                if i == mostRecentLowIndex
                    // Get the bar where this level was created
                    levelBar = array.get(lowBars, i)
                    
                    // Update line: stop extending, make dotted, cut off at break point, change to gray
                    line.set_x2(brokenLine, bar_index)
                    line.set_extend(brokenLine, extend.none)
                    line.set_style(brokenLine, line.style_dotted)
                    line.set_color(brokenLine, bosColor)  // Changed to gray
                    line.set_width(brokenLine, lineWidth)
                    
                    // Show BOS label if enabled
                    if showBosLabels
                        // Calculate center position: midpoint between level bar and break bar
                        centerBar = math.round((levelBar + bar_index) / 2)
                        // Place label at the level price (Y-axis centered on line)
                        bosLabel = label.new(centerBar, levelPrice, "BOS↓", 
                                 style=label.style_label_center,
                                 color=color.white,
                                 textcolor=bosColor, 
                                 size=size.tiny)
                else
                    // Not a valid BOS, just delete the line
                    line.delete(brokenLine)
                
                true
    true

// HTF Function to add a new valid high
addValidHighHTF(float price, int barIdx) =>
    // Delete the previous most recent high line (if it exists and isn't already broken/sweeped)
    if htfMostRecentHighIndex >= 0
        prevHighBroken = array.get(htfHighBroken, htfMostRecentHighIndex)
        prevHighSweeped = array.get(htfHighSweeped, htfMostRecentHighIndex)
        // Only delete if it's still solid (not broken or sweeped yet)
        if not prevHighBroken and not prevHighSweeped
            prevLine = array.get(htfHighLines, htfMostRecentHighIndex)
            line.delete(prevLine)

    array.push(htfHighLevels, price)
    array.push(htfHighBars, barIdx)
    array.push(htfHighBroken, false)
    array.push(htfHighSweeped, false)

    // Create horizontal line extending to the right (solid for most recent)
    // HTF lines are thicker (lineWidth + 1) for better visibility
    newLine = line.new(barIdx, price, barIdx + 1, price,
                       color=htfHighColor,
                       width=math.min(lineWidth + 1, 5),
                       extend=extend.right,
                       style=line.style_solid)
    array.push(htfHighLines, newLine)

    if showHighLowLabels
        newLabel = label.new(barIdx, price, "HTF VH",
                 style=label.style_label_down,
                 color=htfHighColor,
                 textcolor=color.white,
                 size=size.small)
    true

// HTF Function to add a new valid low
addValidLowHTF(float price, int barIdx) =>
    // Delete the previous most recent low line (if it exists and isn't already broken/sweeped)
    if htfMostRecentLowIndex >= 0
        prevLowBroken = array.get(htfLowBroken, htfMostRecentLowIndex)
        prevLowSweeped = array.get(htfLowSweeped, htfMostRecentLowIndex)
        // Only delete if it's still solid (not broken or sweeped yet)
        if not prevLowBroken and not prevLowSweeped
            prevLine = array.get(htfLowLines, htfMostRecentLowIndex)
            line.delete(prevLine)

    array.push(htfLowLevels, price)
    array.push(htfLowBars, barIdx)
    array.push(htfLowBroken, false)
    array.push(htfLowSweeped, false)

    // Create horizontal line extending to the right (solid for most recent)
    // HTF lines are thicker (lineWidth + 1) for better visibility
    newLine = line.new(barIdx, price, barIdx + 1, price,
                       color=htfLowColor,
                       width=math.min(lineWidth + 1, 5),
                       extend=extend.right,
                       style=line.style_solid)
    array.push(htfLowLines, newLine)

    if showHighLowLabels
        newLabel = label.new(barIdx, price, "HTF VL",
                 style=label.style_label_up,
                 color=htfLowColor,
                 textcolor=color.white,
                 size=size.small)
    true

// HTF Function to check and mark sweeped and broken levels
checkBrokenLevelsHTF(float htfHigh, float htfLow, float htfClose) =>
    // Check highs for sweeps and breaks
    if array.size(htfHighLevels) > 0
        for i = 0 to array.size(htfHighLevels) - 1
            levelPrice = array.get(htfHighLevels, i)
            isSweeped = array.get(htfHighSweeped, i)
            isBroken = array.get(htfHighBroken, i)

            // Check for sweep first (wick crosses but close doesn't)
            if not isSweeped and not isBroken and htfHigh > levelPrice and htfClose <= levelPrice
                // Mark as sweeped
                array.set(htfHighSweeped, i, true)

                // Update line: make dotted but keep extending right
                sweepedLine = array.get(htfHighLines, i)
                line.set_style(sweepedLine, line.style_dotted)
                true

            // Check for break (close crosses above)
            else if not isBroken and htfClose > levelPrice
                // Mark as broken
                array.set(htfHighBroken, i, true)

                brokenLine = array.get(htfHighLines, i)

                // Only keep the line visible if this is a valid BOS (most recent high)
                if i == htfMostRecentHighIndex
                    // Get the bar where this level was created
                    levelBar = array.get(htfHighBars, i)

                    // Update line: stop extending, make dotted, cut off at break point, change to gray
                    line.set_x2(brokenLine, bar_index)
                    line.set_extend(brokenLine, extend.none)
                    line.set_style(brokenLine, line.style_dotted)
                    line.set_color(brokenLine, htfBosColor)
                    line.set_width(brokenLine, math.min(lineWidth + 1, 5))

                    // Show BOS label if enabled
                    if showBosLabels
                        // Calculate center position: midpoint between level bar and break bar
                        centerBar = math.round((levelBar + bar_index) / 2)
                        // Place label at the level price (Y-axis centered on line)
                        bosLabel = label.new(centerBar, levelPrice, "HTF BOS↑",
                                 style=label.style_label_center,
                                 color=color.white,
                                 textcolor=htfBosColor,
                                 size=size.tiny)
                else
                    // Not a valid BOS, just delete the line
                    line.delete(brokenLine)

                true

    // Check lows for sweeps and breaks
    if array.size(htfLowLevels) > 0
        for i = 0 to array.size(htfLowLevels) - 1
            levelPrice = array.get(htfLowLevels, i)
            isSweeped = array.get(htfLowSweeped, i)
            isBroken = array.get(htfLowBroken, i)

            // Check for sweep first (wick crosses but close doesn't)
            if not isSweeped and not isBroken and htfLow < levelPrice and htfClose >= levelPrice
                // Mark as sweeped
                array.set(htfLowSweeped, i, true)

                // Update line: make dotted but keep extending right
                sweepedLine = array.get(htfLowLines, i)
                line.set_style(sweepedLine, line.style_dotted)
                true

            // Check for break (close crosses below)
            else if not isBroken and htfClose < levelPrice
                // Mark as broken
                array.set(htfLowBroken, i, true)

                brokenLine = array.get(htfLowLines, i)

                // Only keep the line visible if this is a valid BOS (most recent low)
                if i == htfMostRecentLowIndex
                    // Get the bar where this level was created
                    levelBar = array.get(htfLowBars, i)

                    // Update line: stop extending, make dotted, cut off at break point, change to gray
                    line.set_x2(brokenLine, bar_index)
                    line.set_extend(brokenLine, extend.none)
                    line.set_style(brokenLine, line.style_dotted)
                    line.set_color(brokenLine, htfBosColor)
                    line.set_width(brokenLine, math.min(lineWidth + 1, 5))

                    // Show BOS label if enabled
                    if showBosLabels
                        // Calculate center position: midpoint between level bar and break bar
                        centerBar = math.round((levelBar + bar_index) / 2)
                        // Place label at the level price (Y-axis centered on line)
                        bosLabel = label.new(centerBar, levelPrice, "HTF BOS↓",
                                 style=label.style_label_center,
                                 color=color.white,
                                 textcolor=htfBosColor,
                                 size=size.tiny)
                else
                    // Not a valid BOS, just delete the line
                    line.delete(brokenLine)

                true
    true

// Get HTF data using request.security
[htfHigh, htfLow, htfOpen, htfClose] = request.security(syminfo.tickerid, htfTimeframe, [high, low, open, close], lookahead=barmerge.lookahead_off)

// Detect when we're on a new HTF candle (HTF time has changed)
htfTime = request.security(syminfo.tickerid, htfTimeframe, time, lookahead=barmerge.lookahead_off)
bool htfNewCandle = ta.change(htfTime) != 0

// Helper functions for HTF
htfIsBearishBreakdown() =>
    htfClose < htfOpen and htfClose < htfLow[1]

htfIsBullishBreakout() =>
    htfClose > htfOpen and htfClose > htfHigh[1]

// INITIALIZATION PHASE
if not initialized and bar_index > 0
    if isBearishBreakdown()
        float localHigh = high
        int localHighBar = bar_index
        
        for i = 1 to math.min(bar_index, 200)
            if high[i] > localHigh
                localHigh := high[i]
                localHighBar := bar_index - i
        
        currentValidHigh := localHigh
        currentValidHighBar := localHighBar
        initialized := true
        lookingForLow := true
        
        // Add to array
        addValidHigh(localHigh, localHighBar)
        mostRecentHighIndex := array.size(highLevels) - 1

// MAIN LOGIC (after initialization)
if initialized
    // First check if any historical levels are broken or sweeped
    checkBrokenLevels()

    // Clean up old swept lines - only keep the most recent swept high and low
    if array.size(highLevels) > 0
        int mostRecentSweptHighIndex = -1
        // Find most recent swept high (iterate backwards)
        for i = array.size(highLevels) - 1 to 0
            if array.get(highSweeped, i) and not array.get(highBroken, i)
                mostRecentSweptHighIndex := i
                break

        // Delete lines for all swept highs except the most recent
        for i = 0 to array.size(highLevels) - 1
            if array.get(highSweeped, i) and not array.get(highBroken, i) and i != mostRecentSweptHighIndex
                sweepLine = array.get(highLines, i)
                line.delete(sweepLine)

    if array.size(lowLevels) > 0
        int mostRecentSweptLowIndex = -1
        // Find most recent swept low (iterate backwards)
        for i = array.size(lowLevels) - 1 to 0
            if array.get(lowSweeped, i) and not array.get(lowBroken, i)
                mostRecentSweptLowIndex := i
                break

        // Delete lines for all swept lows except the most recent
        for i = 0 to array.size(lowLevels) - 1
            if array.get(lowSweeped, i) and not array.get(lowBroken, i) and i != mostRecentSweptLowIndex
                sweepLine = array.get(lowLines, i)
                line.delete(sweepLine)
    
    bool bosBullish = false
    bool bosBearish = false
    
    // Check for Break of Structure on current valid levels
    if not na(currentValidHigh) and not na(currentValidLow) and close > currentValidHigh and lookingForLow
        bosBullish := true
        currentHighIsBroken := true  // Mark the high as broken

        // Make the broken high line dotted
        if mostRecentHighIndex >= 0
            brokenLine = array.get(highLines, mostRecentHighIndex)
            line.set_style(brokenLine, line.style_dotted)

        [newLow, newLowBar] = findLowestBetween(currentValidHighBar, bar_index)

        if not na(newLow) and not na(newLowBar)
            currentValidLow := newLow
            currentValidLowBar := newLowBar
            lookingForHigh := true
            lookingForLow := false
            currentLowIsWeak := true  // Low formed via BOS is weak
            currentLowIsBroken := false  // New low is not broken

            addValidLow(newLow, newLowBar)
            mostRecentLowIndex := array.size(lowLevels) - 1

    if not bosBullish and not na(currentValidLow) and not na(currentValidHigh) and close < currentValidLow and lookingForHigh
        bosBearish := true
        currentLowIsBroken := true  // Mark the low as broken

        // Make the broken low line dotted
        if mostRecentLowIndex >= 0
            brokenLine = array.get(lowLines, mostRecentLowIndex)
            line.set_style(brokenLine, line.style_dotted)

        [newHigh, newHighBar] = findHighestBetween(currentValidLowBar, bar_index)

        if not na(newHigh) and not na(newHighBar)
            currentValidHigh := newHigh
            currentValidHighBar := newHighBar
            lookingForLow := true
            lookingForHigh := false
            currentHighIsWeak := true  // High formed via BOS is weak
            currentHighIsBroken := false  // New high is not broken

            addValidHigh(newHigh, newHighBar)
            mostRecentHighIndex := array.size(highLevels) - 1

    // Look for new valid low
    if not bosBullish and not bosBearish and lookingForLow
        if isBullishBreakout()
            [newLow, newLowBar] = findLowestBetween(currentValidHighBar, bar_index)

            if not na(newLow) and not na(newLowBar)
                currentValidLow := newLow
                currentValidLowBar := newLowBar
                lookingForHigh := true
                lookingForLow := false
                currentLowIsWeak := false  // Low formed via breakout is strong
                currentLowIsBroken := false  // New low is not broken

                addValidLow(newLow, newLowBar)
                mostRecentLowIndex := array.size(lowLevels) - 1

    // Look for new valid high
    if not bosBullish and not bosBearish and lookingForHigh
        if isBearishBreakdown()
            [newHigh, newHighBar] = findHighestBetween(currentValidLowBar, bar_index)

            if not na(newHigh) and not na(newHighBar)
                currentValidHigh := newHigh
                currentValidHighBar := newHighBar
                lookingForLow := true
                lookingForHigh := false
                currentHighIsWeak := false  // High formed via breakdown is strong
                currentHighIsBroken := false  // New high is not broken

                addValidHigh(newHigh, newHighBar)
                mostRecentHighIndex := array.size(highLevels) - 1

// HTF INITIALIZATION PHASE (only on new HTF candles)
if htfEnabled and not htfInitialized and bar_index > 0 and htfNewCandle
    if htfIsBearishBreakdown()
        // Initialize with current HTF high
        htfCurrentValidHigh := htfHigh
        htfCurrentValidHighBar := bar_index
        htfInitialized := true
        htfLookingForLow := true

        // Start tracking swing low from here
        htfSwingLow := htfLow
        htfSwingLowBar := bar_index

        // Add to array
        addValidHighHTF(htfHigh, bar_index)
        htfMostRecentHighIndex := array.size(htfHighLevels) - 1

// HTF SWING TRACKING (update on every bar to track extremes)
if htfEnabled and htfInitialized
    // If looking for low, track the lowest low
    if htfLookingForLow
        if na(htfSwingLow) or htfLow < htfSwingLow
            htfSwingLow := htfLow
            htfSwingLowBar := bar_index

    // If looking for high, track the highest high
    if htfLookingForHigh
        if na(htfSwingHigh) or htfHigh > htfSwingHigh
            htfSwingHigh := htfHigh
            htfSwingHighBar := bar_index

// HTF MAIN LOGIC (after initialization, only on new HTF candles)
if htfEnabled and htfInitialized and htfNewCandle
    bool htfBosBullish = false
    bool htfBosBearish = false

    // Check for Break of Structure on current valid levels
    if not na(htfCurrentValidHigh) and not na(htfCurrentValidLow) and htfClose > htfCurrentValidHigh and htfLookingForLow
        htfBosBullish := true
        htfCurrentHighIsBroken := true  // Mark the HTF high as broken

        // Make the broken HTF high line dotted
        if htfMostRecentHighIndex >= 0
            brokenLine = array.get(htfHighLines, htfMostRecentHighIndex)
            line.set_style(brokenLine, line.style_dotted)

        // Use the tracked swing low instead of searching
        if not na(htfSwingLow) and not na(htfSwingLowBar)
            htfCurrentValidLow := htfSwingLow
            htfCurrentValidLowBar := htfSwingLowBar
            htfLookingForHigh := true
            htfLookingForLow := false
            htfCurrentLowIsWeak := true  // HTF Low formed via BOS is weak
            htfCurrentLowIsBroken := false  // New low is not broken

            addValidLowHTF(htfSwingLow, htfSwingLowBar)
            htfMostRecentLowIndex := array.size(htfLowLevels) - 1

            // Reset swing tracking for high
            htfSwingHigh := htfHigh
            htfSwingHighBar := bar_index

    if not htfBosBullish and not na(htfCurrentValidLow) and not na(htfCurrentValidHigh) and htfClose < htfCurrentValidLow and htfLookingForHigh
        htfBosBearish := true
        htfCurrentLowIsBroken := true  // Mark the HTF low as broken

        // Make the broken HTF low line dotted
        if htfMostRecentLowIndex >= 0
            brokenLine = array.get(htfLowLines, htfMostRecentLowIndex)
            line.set_style(brokenLine, line.style_dotted)

        // Use the tracked swing high instead of searching
        if not na(htfSwingHigh) and not na(htfSwingHighBar)
            htfCurrentValidHigh := htfSwingHigh
            htfCurrentValidHighBar := htfSwingHighBar
            htfLookingForLow := true
            htfLookingForHigh := false
            htfCurrentHighIsWeak := true  // HTF High formed via BOS is weak
            htfCurrentHighIsBroken := false  // New high is not broken

            addValidHighHTF(htfSwingHigh, htfSwingHighBar)
            htfMostRecentHighIndex := array.size(htfHighLevels) - 1

            // Reset swing tracking for low
            htfSwingLow := htfLow
            htfSwingLowBar := bar_index

    // Look for new valid low
    if not htfBosBullish and not htfBosBearish and htfLookingForLow
        if htfIsBullishBreakout()
            // Use the tracked swing low instead of searching
            if not na(htfSwingLow) and not na(htfSwingLowBar)
                htfCurrentValidLow := htfSwingLow
                htfCurrentValidLowBar := htfSwingLowBar
                htfLookingForHigh := true
                htfLookingForLow := false
                htfCurrentLowIsWeak := false  // HTF Low formed via breakout is strong
                htfCurrentLowIsBroken := false  // New low is not broken

                addValidLowHTF(htfSwingLow, htfSwingLowBar)
                htfMostRecentLowIndex := array.size(htfLowLevels) - 1

                // Reset swing tracking for high
                htfSwingHigh := htfHigh
                htfSwingHighBar := bar_index

    // Look for new valid high
    if not htfBosBullish and not htfBosBearish and htfLookingForHigh
        if htfIsBearishBreakdown()
            // Use the tracked swing high instead of searching
            if not na(htfSwingHigh) and not na(htfSwingHighBar)
                htfCurrentValidHigh := htfSwingHigh
                htfCurrentValidHighBar := htfSwingHighBar
                htfLookingForLow := true
                htfLookingForHigh := false
                htfCurrentHighIsWeak := false  // HTF High formed via breakdown is strong
                htfCurrentHighIsBroken := false  // New high is not broken

                addValidHighHTF(htfSwingHigh, htfSwingHighBar)
                htfMostRecentHighIndex := array.size(htfHighLevels) - 1

                // Reset swing tracking for low
                htfSwingLow := htfLow
                htfSwingLowBar := bar_index

// Check HTF broken/swept levels on every bar (not just new HTF candles)
if htfEnabled and htfInitialized
    checkBrokenLevelsHTF(htfHigh, htfLow, htfClose)

    // Clean up old swept lines - only keep the most recent swept high and low
    if array.size(htfHighLevels) > 0
        int mostRecentSweptHighIndex = -1
        // Find most recent swept high (iterate backwards)
        for i = array.size(htfHighLevels) - 1 to 0
            if array.get(htfHighSweeped, i) and not array.get(htfHighBroken, i)
                mostRecentSweptHighIndex := i
                break

        // Delete lines for all swept highs except the most recent
        for i = 0 to array.size(htfHighLevels) - 1
            if array.get(htfHighSweeped, i) and not array.get(htfHighBroken, i) and i != mostRecentSweptHighIndex
                htfLine = array.get(htfHighLines, i)
                line.delete(htfLine)

    if array.size(htfLowLevels) > 0
        int mostRecentSweptLowIndex = -1
        // Find most recent swept low (iterate backwards)
        for i = array.size(htfLowLevels) - 1 to 0
            if array.get(htfLowSweeped, i) and not array.get(htfLowBroken, i)
                mostRecentSweptLowIndex := i
                break

        // Delete lines for all swept lows except the most recent
        for i = 0 to array.size(htfLowLevels) - 1
            if array.get(htfLowSweeped, i) and not array.get(htfLowBroken, i) and i != mostRecentSweptLowIndex
                htfLine = array.get(htfLowLines, i)
                line.delete(htfLine)

// Plot current valid levels for reference (optional - you can comment these out)
plot(currentValidHigh, "Current Valid High", color=color.new(highColor, 80), linewidth=1, style=plot.style_stepline)
plot(currentValidLow, "Current Valid Low", color=color.new(lowColor, 80), linewidth=1, style=plot.style_stepline)

// Plot HTF valid levels for reference (optional - you can comment these out)
plot(htfEnabled ? htfCurrentValidHigh : na, "HTF Valid High", color=color.new(htfHighColor, 80), linewidth=1, style=plot.style_stepline)
plot(htfEnabled ? htfCurrentValidLow : na, "HTF Valid Low", color=color.new(htfLowColor, 80), linewidth=1, style=plot.style_stepline)

// Update labels for current levels (positioned to the right of chart)
if initialized and not na(currentValidHigh)
    // Delete old label
    if not na(currentHighLabel)
        label.delete(currentHighLabel)
    // Determine label text based on state
    string labelText = na
    color labelColor = highColor
    if currentHighIsBroken
        labelText := timeframe.period + " Broken High"
        labelColor := color.new(color.red, 0)  // Red for broken
    else
        labelText := currentHighIsWeak ? timeframe.period + " Weak High" : timeframe.period + " High"

    currentHighLabel := label.new(bar_index + 10, currentValidHigh,
                                   text=labelText,
                                   style=label.style_label_left,
                                   color=labelColor,
                                   textcolor=color.white,
                                   size=size.small)

if initialized and not na(currentValidLow)
    // Delete old label
    if not na(currentLowLabel)
        label.delete(currentLowLabel)
    // Determine label text based on state
    string labelText = na
    color labelColor = lowColor
    if currentLowIsBroken
        labelText := timeframe.period + " Broken Low"
        labelColor := color.new(color.red, 0)  // Red for broken
    else
        labelText := currentLowIsWeak ? timeframe.period + " Weak Low" : timeframe.period + " Low"

    currentLowLabel := label.new(bar_index + 10, currentValidLow,
                                  text=labelText,
                                  style=label.style_label_left,
                                  color=labelColor,
                                  textcolor=color.white,
                                  size=size.small)

// Update HTF labels (with more spacing to avoid overlap)
if htfEnabled and htfInitialized and not na(htfCurrentValidHigh)
    // Delete old label
    if not na(htfCurrentHighLabel)
        label.delete(htfCurrentHighLabel)
    // Determine label text based on state
    string labelText = na
    color labelColor = htfHighColor
    if htfCurrentHighIsBroken
        labelText := htfTimeframe + " Broken High"
        labelColor := color.new(color.red, 0)  // Red for broken
    else
        labelText := htfCurrentHighIsWeak ? htfTimeframe + " Weak High" : htfTimeframe + " High"

    htfCurrentHighLabel := label.new(bar_index + 20, htfCurrentValidHigh,
                                      text=labelText,
                                      style=label.style_label_left,
                                      color=labelColor,
                                      textcolor=color.white,
                                      size=size.small)

if htfEnabled and htfInitialized and not na(htfCurrentValidLow)
    // Delete old label
    if not na(htfCurrentLowLabel)
        label.delete(htfCurrentLowLabel)
    // Determine label text based on state
    string labelText = na
    color labelColor = htfLowColor
    if htfCurrentLowIsBroken
        labelText := htfTimeframe + " Broken Low"
        labelColor := color.new(color.red, 0)  // Red for broken
    else
        labelText := htfCurrentLowIsWeak ? htfTimeframe + " Weak Low" : htfTimeframe + " Low"

    htfCurrentLowLabel := label.new(bar_index + 20, htfCurrentValidLow,
                                     text=labelText,
                                     style=label.style_label_left,
                                     color=labelColor,
                                     textcolor=color.white,
                                     size=size.small)

// Update swept level labels (delete old ones and create new ones)
// Clear old swept labels
if array.size(sweptHighLabels) > 0
    for i = 0 to array.size(sweptHighLabels) - 1
        label.delete(array.get(sweptHighLabels, i))
    array.clear(sweptHighLabels)

if array.size(sweptLowLabels) > 0
    for i = 0 to array.size(sweptLowLabels) - 1
        label.delete(array.get(sweptLowLabels, i))
    array.clear(sweptLowLabels)

if array.size(htfSweptHighLabels) > 0
    for i = 0 to array.size(htfSweptHighLabels) - 1
        label.delete(array.get(htfSweptHighLabels, i))
    array.clear(htfSweptHighLabels)

if array.size(htfSweptLowLabels) > 0
    for i = 0 to array.size(htfSweptLowLabels) - 1
        label.delete(array.get(htfSweptLowLabels, i))
    array.clear(htfSweptLowLabels)

// Create new swept labels for current TF (only most recent)
if array.size(highLevels) > 0
    // Find most recent swept high (iterate backwards)
    for i = array.size(highLevels) - 1 to 0
        if array.get(highSweeped, i) and not array.get(highBroken, i)
            sweptLabel = label.new(bar_index + 10, array.get(highLevels, i), text="Swept", style=label.style_label_left, color=color.new(highColor, 50), textcolor=color.white, size=size.tiny)
            array.push(sweptHighLabels, sweptLabel)
            break  // Only show most recent

if array.size(lowLevels) > 0
    // Find most recent swept low (iterate backwards)
    for i = array.size(lowLevels) - 1 to 0
        if array.get(lowSweeped, i) and not array.get(lowBroken, i)
            sweptLabel = label.new(bar_index + 10, array.get(lowLevels, i), text="Swept", style=label.style_label_left, color=color.new(lowColor, 50), textcolor=color.white, size=size.tiny)
            array.push(sweptLowLabels, sweptLabel)
            break  // Only show most recent

// Create new swept labels for HTF (only most recent)
if htfEnabled and array.size(htfHighLevels) > 0
    // Find most recent swept HTF high (iterate backwards)
    for i = array.size(htfHighLevels) - 1 to 0
        if array.get(htfHighSweeped, i) and not array.get(htfHighBroken, i)
            sweptLabel = label.new(bar_index + 20, array.get(htfHighLevels, i), text="HTF Swept", style=label.style_label_left, color=color.new(htfHighColor, 50), textcolor=color.white, size=size.tiny)
            array.push(htfSweptHighLabels, sweptLabel)
            break  // Only show most recent

if htfEnabled and array.size(htfLowLevels) > 0
    // Find most recent swept HTF low (iterate backwards)
    for i = array.size(htfLowLevels) - 1 to 0
        if array.get(htfLowSweeped, i) and not array.get(htfLowBroken, i)
            sweptLabel = label.new(bar_index + 20, array.get(htfLowLevels, i), text="HTF Swept", style=label.style_label_left, color=color.new(htfLowColor, 50), textcolor=color.white, size=size.tiny)
            array.push(htfSweptLowLabels, sweptLabel)
            break  // Only show most recent

// Show "looking for" labels when HTF levels have been broken and we're seeking replacements
// When looking for high, it means the previous high was broken and we're waiting for a new one
if htfEnabled and htfInitialized and htfLookingForHigh and not na(htfCurrentValidLow)
    // Delete old label
    if not na(htfLookingForHighLabel)
        label.delete(htfLookingForHighLabel)
    // Place label above the current low, showing we're looking for a high
    // htfLookingForHighLabel := label.new(bar_index + 25, htfCurrentValidLow * 1.001, text="Looking for " + htfTimeframe + " High", style=label.style_label_left, color=color.new(htfHighColor, 70), textcolor=color.white, size=size.tiny)

// When looking for low, it means the previous low was broken and we're waiting for a new one
if htfEnabled and htfInitialized and htfLookingForLow and not na(htfCurrentValidHigh)
    // Delete old label
    if not na(htfLookingForLowLabel)
        label.delete(htfLookingForLowLabel)
    // Place label below the current high, showing we're looking for a low
    // htfLookingForLowLabel := label.new(bar_index + 25, htfCurrentValidHigh * 0.999, text="Looking for " + htfTimeframe + " Low", style=label.style_label_left, color=color.new(htfLowColor, 70), textcolor=color.white, size=size.tiny)
