// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© scientificbest

//@version=5
indicator("Candlestick Swing Points [SB]", "CSP [SB]", overlay=true, max_lines_count=500)

////////////////////////////////////////////////////////////////////////////////
//// Inputs
////////////////////////////////////////////////////////////////////////////////

grp1 = "Display Settings"
grp2 = "Colors"

showSwingHighs          = input.bool(true, title="Show Swing Highs", group=grp1)
showSwingLows           = input.bool(true, title="Show Swing Lows", group=grp1)
allowEqualSwings        = input.bool(true, title="Allow Equal Highs/Lows", group=grp1, tooltip="Count consecutive equal highs as a valid swing high when surrounded by lower highs (and vice versa for lows)")
extendLines             = input.bool(true, title="Extend Lines Until Crossed", group=grp1, tooltip="If enabled, lines extend until price crosses them. If disabled, lines extend to the end of the chart.")
lineWidth               = input.int(1, title="Line Width", minval=1, maxval=5, group=grp1)
maxLines                = input.int(50, title="Max Lines Per Side", minval=1, maxval=250, group=grp1)

swingHighColor          = input.color(color.new(color.red, 30), title="Swing High Color", group=grp2)
swingLowColor           = input.color(color.new(color.green, 30), title="Swing Low Color", group=grp2)

////////////////////////////////////////////////////////////////////////////////
//// Types
////////////////////////////////////////////////////////////////////////////////

type SwingPoint
    float price
    int barIdx
    line levelLine
    bool wicked      // Wicked through but not closed through
    bool crossed     // Closed through

////////////////////////////////////////////////////////////////////////////////
//// Variables
////////////////////////////////////////////////////////////////////////////////

var array<SwingPoint> swingHighs = array.new<SwingPoint>()
var array<SwingPoint> swingLows = array.new<SwingPoint>()

////////////////////////////////////////////////////////////////////////////////
//// Swing Point Detection
////////////////////////////////////////////////////////////////////////////////

// Count consecutive equal highs going back from offset, returns count and first bar offset
countEqualHighs(int startOff) =>
    count = 1
    price = high[startOff]
    i = startOff + 1
    while i < 200 and high[i] == price
        count += 1
        i += 1
    [count, i - 1]  // Returns count and offset of last equal high

// Count consecutive equal lows going back from offset
countEqualLows(int startOff) =>
    count = 1
    price = low[startOff]
    i = startOff + 1
    while i < 200 and low[i] == price
        count += 1
        i += 1
    [count, i - 1]  // Returns count and offset of last equal low

// Standard swing high: middle candle's high > both neighbors' highs
// Pattern: [2] [1] [0] where [1] is the swing point
isStandardSwingHigh = high[1] > high[2] and high[1] > high[0]

// Standard swing low: middle candle's low < both neighbors' lows
isStandardSwingLow = low[1] < low[2] and low[1] < low[0]

// Equal highs swing: consecutive equal highs surrounded by lower highs
// Detected when current bar breaks below the plateau
var int equalHighStartBar = na
var float equalHighPrice = na
isEqualSwingHigh = false

if allowEqualSwings and high[0] < high[1]
    [eqCount, lastEqOff] = countEqualHighs(1)
    // Check if we have 2+ equal highs and the bar before them is lower
    if eqCount >= 2 and high[lastEqOff + 1] < high[lastEqOff]
        isEqualSwingHigh := true
        equalHighStartBar := bar_index - lastEqOff
        equalHighPrice := high[1]

// Equal lows swing: consecutive equal lows surrounded by higher lows
var int equalLowStartBar = na
var float equalLowPrice = na
isEqualSwingLow = false

if allowEqualSwings and low[0] > low[1]
    [eqCount, lastEqOff] = countEqualLows(1)
    // Check if we have 2+ equal lows and the bar before them is higher
    if eqCount >= 2 and low[lastEqOff + 1] > low[lastEqOff]
        isEqualSwingLow := true
        equalLowStartBar := bar_index - lastEqOff
        equalLowPrice := low[1]

// Combined detection
isSwingHigh = isStandardSwingHigh or isEqualSwingHigh
isSwingLow = isStandardSwingLow or isEqualSwingLow

////////////////////////////////////////////////////////////////////////////////
//// Create New Swing Points
////////////////////////////////////////////////////////////////////////////////

if isSwingHigh and showSwingHighs
    // Determine start bar and price based on swing type
    startBar = isEqualSwingHigh ? equalHighStartBar : bar_index - 1
    swingPrice = isEqualSwingHigh ? equalHighPrice : high[1]

    // Create line from the swing high
    newLine = line.new(startBar, swingPrice, bar_index, swingPrice, color=swingHighColor, width=lineWidth, extend=extend.right, style=line.style_solid)
    newSwing = SwingPoint.new(price=swingPrice, barIdx=startBar, levelLine=newLine, wicked=false, crossed=false)
    array.unshift(swingHighs, newSwing)

    // Limit array size
    if array.size(swingHighs) > maxLines
        oldSwing = array.pop(swingHighs)
        line.delete(oldSwing.levelLine)

if isSwingLow and showSwingLows
    // Determine start bar and price based on swing type
    startBar = isEqualSwingLow ? equalLowStartBar : bar_index - 1
    swingPrice = isEqualSwingLow ? equalLowPrice : low[1]

    // Create line from the swing low
    newLine = line.new(startBar, swingPrice, bar_index, swingPrice, color=swingLowColor, width=lineWidth, extend=extend.right, style=line.style_solid)
    newSwing = SwingPoint.new(price=swingPrice, barIdx=startBar, levelLine=newLine, wicked=false, crossed=false)
    array.unshift(swingLows, newSwing)

    // Limit array size
    if array.size(swingLows) > maxLines
        oldSwing = array.pop(swingLows)
        line.delete(oldSwing.levelLine)

////////////////////////////////////////////////////////////////////////////////
//// Check for Wicked and Crossed Levels
////////////////////////////////////////////////////////////////////////////////

// Check swing highs
if array.size(swingHighs) > 0
    for i = array.size(swingHighs) - 1 to 0
        swing = array.get(swingHighs, i)
        if not swing.crossed and swing.barIdx < bar_index
            // Check for close through (crossed)
            if close > swing.price
                swing.crossed := true
                if extendLines
                    line.set_extend(swing.levelLine, extend.none)
                    line.set_x2(swing.levelLine, bar_index)
            // Check for wick through (wicked but not closed)
            else if not swing.wicked and high > swing.price
                swing.wicked := true
                line.set_style(swing.levelLine, line.style_dotted)

// Check swing lows
if array.size(swingLows) > 0
    for i = array.size(swingLows) - 1 to 0
        swing = array.get(swingLows, i)
        if not swing.crossed and swing.barIdx < bar_index
            // Check for close through (crossed)
            if close < swing.price
                swing.crossed := true
                if extendLines
                    line.set_extend(swing.levelLine, extend.none)
                    line.set_x2(swing.levelLine, bar_index)
            // Check for wick through (wicked but not closed)
            else if not swing.wicked and low < swing.price
                swing.wicked := true
                line.set_style(swing.levelLine, line.style_dotted)

////////////////////////////////////////////////////////////////////////////////
//// Alerts
////////////////////////////////////////////////////////////////////////////////

alertcondition(isSwingHigh, title="Swing High Formed", message="Candlestick Swing High formed at {{high}}")
alertcondition(isSwingLow, title="Swing Low Formed", message="Candlestick Swing Low formed at {{low}}")
