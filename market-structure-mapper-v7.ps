// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © scientificbest

//@version=5
indicator("Market Structure Mapper V7 [SB]", "MSM V7 [SB]", overlay=true, max_lines_count=250, max_labels_count=250, max_boxes_count=500)

// ============================================================================
// CURRENT TIMEFRAME (CTF) SETTINGS
// ============================================================================
ctfEnabled = input.bool(true, "Enable CTF Structure", group="Current Timeframe")
showCtfPeaksValleys = input.bool(true, "Show CTF Peaks/Valleys (Lines)", group="Current Timeframe")
showCtfLabels = input.bool(false, "Show CTF Labels", group="Current Timeframe")
showCtfBosLabels = input.bool(true, "Show CTF BOS Labels", group="Current Timeframe")
showCtfZones = input.bool(true, "Show CTF Zones", group="Current Timeframe")
ctfZonesUseFullSwings = input.bool(false, "CTF Zones: Use Full Swings", group="Current Timeframe")

// CTF Colors
highColor = input.color(color.new(color.red, 0), "CTF High Color", group="Current Timeframe")
lowColor = input.color(color.new(color.green, 0), "CTF Low Color", group="Current Timeframe")
bosColor = input.color(color.new(color.black, 0), "CTF BOS Color", group="Current Timeframe")
ctfDemandZoneColor = input.color(color.new(color.green, 85), "CTF Demand Zone Color", group="Current Timeframe")
ctfDemandZoneBorderColor = input.color(color.new(color.green, 50), "CTF Demand Zone Border", group="Current Timeframe")
ctfSupplyZoneColor = input.color(color.new(color.red, 85), "CTF Supply Zone Color", group="Current Timeframe")
ctfSupplyZoneBorderColor = input.color(color.new(color.red, 50), "CTF Supply Zone Border", group="Current Timeframe")

// ============================================================================
// HIGHER TIMEFRAME (HTF) SETTINGS
// ============================================================================
htfEnabled = input.bool(true, "Enable HTF Structure", group="Higher Timeframe")
htfTimeframe = input.timeframe("60", "HTF Timeframe", group="Higher Timeframe")
showHtfPeaksValleys = input.bool(true, "Show HTF Peaks/Valleys (Lines)", group="Higher Timeframe")
showHtfLabels = input.bool(true, "Show HTF Labels", group="Higher Timeframe")
showHtfBosLabels = input.bool(true, "Show HTF BOS Labels", group="Higher Timeframe")
showHtfZones = input.bool(true, "Show HTF Zones", group="Higher Timeframe")

// HTF Colors
htfHighColor = input.color(color.new(color.orange, 0), "HTF High Color", group="Higher Timeframe")
htfLowColor = input.color(color.new(color.blue, 0), "HTF Low Color", group="Higher Timeframe")
htfBosColor = input.color(color.new(color.black, 0), "HTF BOS Color", group="Higher Timeframe")
demandZoneColor = input.color(color.new(color.blue, 85), "HTF Demand Zone Color", group="Higher Timeframe")
demandZoneBorderColorInput = input.color(color.new(color.blue, 50), "HTF Demand Zone Border", group="Higher Timeframe")
supplyZoneColor = input.color(color.new(color.orange, 85), "HTF Supply Zone Color", group="Higher Timeframe")
supplyZoneBorderColorInput = input.color(color.new(color.orange, 50), "HTF Supply Zone Border", group="Higher Timeframe")

// ============================================================================
// TRADING RANGE TIMEFRAME (HTF2) SETTINGS
// ============================================================================
htf2Enabled = input.bool(true, "Enable HTF2 Structure", group="Trading Range TF")
htf2Timeframe = input.timeframe("D", "HTF2 Timeframe", group="Trading Range TF")
showHtf2PeaksValleys = input.bool(true, "Show HTF2 Peaks/Valleys (Lines)", group="Trading Range TF")
showHtf2Labels = input.bool(true, "Show HTF2 Labels", group="Trading Range TF")
showHtf2BosLabels = input.bool(true, "Show HTF2 BOS Labels", group="Trading Range TF")
showHtf2Zones = input.bool(true, "Show HTF2 Zones", group="Trading Range TF")

// HTF2 Colors
htf2HighColor = input.color(color.new(color.purple, 0), "HTF2 High Color", group="Trading Range TF")
htf2LowColor = input.color(color.new(color.teal, 0), "HTF2 Low Color", group="Trading Range TF")
htf2DemandZoneColor = input.color(color.new(color.teal, 85), "HTF2 Demand Zone Color", group="Trading Range TF")
htf2DemandZoneBorderColor = input.color(color.new(color.teal, 50), "HTF2 Demand Zone Border", group="Trading Range TF")
htf2SupplyZoneColor = input.color(color.new(color.purple, 85), "HTF2 Supply Zone Color", group="Trading Range TF")
htf2SupplyZoneBorderColor = input.color(color.new(color.purple, 50), "HTF2 Supply Zone Border", group="Trading Range TF")

// ============================================================================
// ZONE SETTINGS
// ============================================================================
showBrokenCtfZones = input.bool(false, "Show Broken CTF Zones", group="Zone Settings")
showBrokenHtfZones = input.bool(false, "Show Broken HTF Zones", group="Zone Settings")
showBrokenHtf2Zones = input.bool(false, "Show Broken HTF2 Zones", group="Zone Settings")
extendBrokenZones = input.bool(false, "Extend Broken Zones to Current Bar", group="Zone Settings")
minZoneHeightAtr = input.float(0.5, "Min Zone Height (ATR multiplier)", minval=0.1, maxval=5.0, step=0.1, group="Zone Settings")
maxZonesPerSide = input.int(20, "Max Zones Per Side", minval=10, maxval=250, group="Zone Settings")
zoneBreakOnWick = input.bool(false, "Break Zones on Wick (not just close)", group="Zone Settings")
zoneBreakOnFirstTouch = input.bool(false, "Break Zones on First Touch", group="Zone Settings")
zoneBreakOnTouchAfterCreation = input.bool(false, "Break Zones on Touch After Creation", group="Zone Settings")

// ============================================================================
// DISPLAY SETTINGS
// ============================================================================
lineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="Display")
showDebugLabel = input.bool(false, "Show Debug Info", group="Display")

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

// Type for tracking high levels
type HighLevel
    float price
    int barIndex
    line levelLine
    string levelType  // "strong", "weak", "broken", "swept"
    bool zoneCreated  // Has a zone been created for this level?

// Type for tracking low levels
type LowLevel
    float price
    int barIndex
    line levelLine
    string levelType  // "strong", "weak", "broken", "swept"
    bool zoneCreated  // Has a zone been created for this level?

// Type for tracking supply/demand zones
type Zone
    float top
    float bottom
    int leftTime
    int rightTime
    bool broken
    bool touched        // Has the zone been touched since creation?
    int creationBar     // Bar index when zone was created (for "after creation" logic)

// ============================================================================
// ARRAYS TO STORE LEVELS AND ZONES
// ============================================================================

// Current Timeframe - All highs in one array, all lows in another
var array<HighLevel> highs = array.new<HighLevel>()
var array<LowLevel> lows = array.new<LowLevel>()

// Higher Timeframe (Middle TF)
var array<HighLevel> htfHighs = array.new<HighLevel>()
var array<LowLevel> htfLows = array.new<LowLevel>()

// Trading Range Timeframe (HTF2 - highest TF)
var array<HighLevel> htf2Highs = array.new<HighLevel>()
var array<LowLevel> htf2Lows = array.new<LowLevel>()

// CTF Zones
var array<Zone> ctfDemandZones = array.new<Zone>()
var array<Zone> ctfSupplyZones = array.new<Zone>()

// HTF Zones
var array<Zone> demandZones = array.new<Zone>()
var array<Zone> supplyZones = array.new<Zone>()

// HTF2 Zones
var array<Zone> htf2DemandZones = array.new<Zone>()
var array<Zone> htf2SupplyZones = array.new<Zone>()

// ============================================================================
// MARKET STRUCTURE STATE VARIABLES
// ============================================================================

// Current Timeframe
var float currentValidHigh = na
var float currentValidLow = na
var int currentValidHighBar = na
var int currentValidLowBar = na
var bool initialized = false
var bool lookingForLow = false
var bool lookingForHigh = false
var bool currentHighIsBroken = false
var bool currentLowIsBroken = false
var string lastBosDirection = "none"  // "bullish", "bearish", or "none"

// Track indices of most recent high/low
var int mostRecentHighIndex = -1
var int mostRecentLowIndex = -1

// Track previous valid levels to detect "clean" BOS (no intermediate levels)
var float previousValidHigh = na
var float previousValidLow = na
var int previousValidHighBar = na
var int previousValidLowBar = na

// Track nearest unbroken high/low (structure boundaries)
var int nearestUnbrokenHighIndex = -1
var int nearestUnbrokenLowIndex = -1
var line nearestUnbrokenHighLine = na
var line nearestUnbrokenLowLine = na

// Higher Timeframe
var float htfCurrentValidHigh = na
var float htfCurrentValidLow = na
var int htfCurrentValidHighBar = na
var int htfCurrentValidLowBar = na
var bool htfInitialized = false
var bool htfLookingForLow = false
var bool htfLookingForHigh = false
var bool htfCurrentHighIsBroken = false
var bool htfCurrentLowIsBroken = false
var string htfLastBosDirection = "none"

// HTF swing tracking
var float htfSwingLow = na
var int htfSwingLowBar = na
var float htfSwingHigh = na
var int htfSwingHighBar = na

// HTF Track indices
var int htfMostRecentHighIndex = -1
var int htfMostRecentLowIndex = -1

// HTF previous valid levels
var float htfPreviousValidHigh = na
var float htfPreviousValidLow = na
var int htfPreviousValidHighBar = na
var int htfPreviousValidLowBar = na

// HTF Track nearest unbroken high/low (structure boundaries)
var int htfNearestUnbrokenHighIndex = -1
var int htfNearestUnbrokenLowIndex = -1
var line htfNearestUnbrokenHighLine = na
var line htfNearestUnbrokenLowLine = na

// Trading Range Timeframe (HTF2) State Variables
var float htf2CurrentValidHigh = na
var float htf2CurrentValidLow = na
var int htf2CurrentValidHighBar = na
var int htf2CurrentValidLowBar = na
var bool htf2Initialized = false
var bool htf2LookingForLow = false
var bool htf2LookingForHigh = false
var bool htf2CurrentHighIsBroken = false
var bool htf2CurrentLowIsBroken = false
var string htf2LastBosDirection = "none"

// HTF2 swing tracking
var float htf2SwingLow = na
var int htf2SwingLowBar = na
var float htf2SwingHigh = na
var int htf2SwingHighBar = na

// HTF2 Track indices
var int htf2MostRecentHighIndex = -1
var int htf2MostRecentLowIndex = -1

// HTF2 previous valid levels
var float htf2PreviousValidHigh = na
var float htf2PreviousValidLow = na
var int htf2PreviousValidHighBar = na
var int htf2PreviousValidLowBar = na

// HTF2 Track nearest unbroken high/low (structure boundaries)
var int htf2NearestUnbrokenHighIndex = -1
var int htf2NearestUnbrokenLowIndex = -1
var line htf2NearestUnbrokenHighLine = na
var line htf2NearestUnbrokenLowLine = na

// Labels
var label currentHighLabel = na
var label currentLowLabel = na
var label htfCurrentHighLabel = na
var label htfCurrentLowLabel = na
var label htf2CurrentHighLabel = na
var label htf2CurrentLowLabel = na

// Labels for nearest unbroken levels (structure boundaries)
var label nearestUnbrokenHighLabel = na
var label nearestUnbrokenLowLabel = na
var label htfNearestUnbrokenHighLabel = na
var label htfNearestUnbrokenLowLabel = na
var label htf2NearestUnbrokenHighLabel = na
var label htf2NearestUnbrokenLowLabel = na

var array<label> sweptHighLabels = array.new<label>()
var array<label> sweptLowLabels = array.new<label>()
var array<label> htfSweptHighLabels = array.new<label>()
var array<label> htfSweptLowLabels = array.new<label>()

// Debug counters
var int ctfBullishBOS = 0
var int ctfBearishBOS = 0
var int htfBullishBOS = 0
var int htfBearishBOS = 0
var int htfBullishLabels = 0  // BOS labels created by checkBrokenLevelsHTF
var int htfBearishLabels = 0  // BOS labels created by checkBrokenLevelsHTF
var int demandZonesCreated = 0
var int supplyZonesCreated = 0
var int demandZonesBlocked = 0
var int supplyZonesBlocked = 0
var int ctfDemandZonesCreated = 0
var int ctfSupplyZonesCreated = 0
var int ctfDemandSkippedNa = 0
var int ctfDemandSkippedDupe = 0
var int lastDemandBarsWalked = 0
var float lastDemandHighFound = 0.0
var int swingNaCount = 0
var int calcNaCount = 0

// ============================================================================
// NOTIFICATION FLAGS (for alerts)
// ============================================================================

// HTF Alert condition flags (set at HTF candle close, reset on next LTF bar)
var bool htfBosFlag = false
var bool htfBosLtfBosFlag = false
var bool htfSweptFlag = false
var bool htfSweptLtfBosFlag = false
var bool pullback50Flag = false

// LTF Alert condition flags (set when LTF conditions occur)
var bool ltfBosFlag = false
var bool ltfSweptFlag = false
var bool ltfBosAtExtremeFlag = false
var bool pullback25Flag = false

// CTF BOS alert flags
var bool ctfBullishBosFlag = false
var bool ctfBearishBosFlag = false

// HTF BOS direction-specific flags
var bool htfBullishBosFlag = false
var bool htfBearishBosFlag = false

// HTF2 BOS alert flags
var bool htf2BullishBosFlag = false
var bool htf2BearishBosFlag = false

// Zone entry alert flags
var bool ctfDemandEntryFlag = false
var bool ctfSupplyEntryFlag = false
var bool htfDemandEntryFlag = false
var bool htfSupplyEntryFlag = false
var bool htf2DemandEntryFlag = false
var bool htf2SupplyEntryFlag = false

// State tracking for "BOS after entering zone" alerts
var bool inHtfDemandZone = false
var bool inHtfSupplyZone = false
var bool inHtf2DemandZone = false
var bool inHtf2SupplyZone = false
var int activeHtfDemandZoneIdx = -1   // Index of the HTF demand zone we entered
var int activeHtfSupplyZoneIdx = -1   // Index of the HTF supply zone we entered
var int activeHtf2DemandZoneIdx = -1  // Index of the HTF2 demand zone we entered
var int activeHtf2SupplyZoneIdx = -1  // Index of the HTF2 supply zone we entered
var int ctfBullishBosCountSinceHtfDemand = 0
var int ctfBearishBosCountSinceHtfSupply = 0
var int ctfBullishBosCountSinceHtf2Demand = 0
var int ctfBearishBosCountSinceHtf2Supply = 0
var int htfBullishBosCountSinceHtf2Demand = 0
var int htfBearishBosCountSinceHtf2Supply = 0

// Flags for "BOS after zone entry" alerts
// CTF BOS after HTF zone entry
var bool firstCtfBullishBosAfterHtfDemandFlag = false
var bool firstCtfBearishBosAfterHtfSupplyFlag = false
var bool secondCtfBullishBosAfterHtfDemandFlag = false
var bool secondCtfBearishBosAfterHtfSupplyFlag = false
// CTF BOS after HTF2 zone entry
var bool firstCtfBullishBosAfterHtf2DemandFlag = false
var bool firstCtfBearishBosAfterHtf2SupplyFlag = false
var bool secondCtfBullishBosAfterHtf2DemandFlag = false
var bool secondCtfBearishBosAfterHtf2SupplyFlag = false
// HTF BOS after HTF2 zone entry
var bool firstHtfBullishBosAfterHtf2DemandFlag = false
var bool firstHtfBearishBosAfterHtf2SupplyFlag = false

// State tracking for alert conditions
var bool ltfBosBullishSinceLastHTF = false
var bool ltfBosBearishSinceLastHTF = false
var float pullback50Level = na
var float pullback25Level = na

// Track HTF level state changes to detect when they become swept
var string htfMostRecentHighPrevType = "strong"
var string htfMostRecentLowPrevType = "strong"

// Track LTF level state changes to detect when they become swept
var string ltfMostRecentHighPrevType = "strong"
var string ltfMostRecentLowPrevType = "strong"

// Track HTF BOS for current bar (needed for alert logic)
var bool htfBosBullish = false
var bool htfBosBearish = false

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Check if current candle is bearish and closes below previous candle's low
isBearishBreakdown() =>
    close < open and close < low[1]

// Check if current candle is bullish and closes above previous candle's high
isBullishBreakout() =>
    close > open and close > high[1]

// Find lowest low between two bar indices
// Note: Pine Script has a limited historical buffer (typically ~200-500 bars depending on plan)
// We use a conservative limit of 200 to avoid runtime errors
findLowestBetween(startBar, endBar) =>
    float lowestPrice = na
    int lowestBarIndex = na

    int start = startBar
    int end = endBar

    if start > end
        int temp = start
        start := end
        end := temp

    int currentBar = bar_index
    int lookbackStart = currentBar - end
    int lookbackEnd = currentBar - start - 1

    // Use conservative limit of 200 bars to stay well within historical buffer
    int maxLookback = 200
    lookbackStart := math.max(lookbackStart, 0)
    lookbackEnd := math.min(lookbackEnd, maxLookback)

    if lookbackStart <= lookbackEnd and lookbackEnd >= 0 and lookbackStart <= maxLookback
        for i = lookbackStart to lookbackEnd
            if i >= 0 and not na(low[i])
                if na(lowestPrice) or low[i] < lowestPrice
                    lowestPrice := low[i]
                    lowestBarIndex := currentBar - i

    [lowestPrice, lowestBarIndex]

// Find highest high between two bar indices
// Note: Pine Script has a limited historical buffer (typically ~200-500 bars depending on plan)
// We use a conservative limit of 200 to avoid runtime errors
findHighestBetween(startBar, endBar) =>
    float highestPrice = na
    int highestBarIndex = na

    int start = startBar
    int end = endBar

    if start > end
        int temp = start
        start := end
        end := temp

    int currentBar = bar_index
    int lookbackStart = currentBar - end
    int lookbackEnd = currentBar - start - 1

    // Use conservative limit of 200 bars to stay well within historical buffer
    int maxLookback = 200
    lookbackStart := math.max(lookbackStart, 0)
    lookbackEnd := math.min(lookbackEnd, maxLookback)

    if lookbackStart <= lookbackEnd and lookbackEnd >= 0 and lookbackStart <= maxLookback
        for i = lookbackStart to lookbackEnd
            if i >= 0 and not na(high[i])
                if na(highestPrice) or high[i] > highestPrice
                    highestPrice := high[i]
                    highestBarIndex := currentBar - i

    [highestPrice, highestBarIndex]

// ============================================================================
// ZONE CALCULATION FUNCTIONS
// ============================================================================

// These functions find LTF swing structure around an HTF swing point.
// They first try to use CTF arrays, but fall back to scanning bar data directly.

// Helper: Find a swing high by scanning bar data (high with lower highs on both sides)
// Returns [price, barIndex] or [na, na] if not found
findSwingHighBefore(int startBarIndex, int maxBarsToScan) =>
    float swingPrice = na
    int swingBar = na
    int barsBack = bar_index - startBarIndex
    int maxLookback = 198  // Conservative limit to stay within historical buffer

    if barsBack >= 0 and barsBack < maxLookback
        // Scan backwards from startBarIndex to find a swing high
        for i = barsBack + 1 to math.min(barsBack + maxBarsToScan, maxLookback - 1)
            if i >= 1 and i < maxLookback and not na(high[i]) and not na(high[i-1]) and not na(high[i+1])
                // Check if this is a swing high (higher than neighbors)
                if high[i] > high[i-1] and high[i] > high[i+1]
                    swingPrice := high[i]
                    swingBar := bar_index - i
                    break

    [swingPrice, swingBar]

findSwingHighAfter(int startBarIndex, int maxBarsToScan) =>
    float swingPrice = na
    int swingBar = na
    int barsBack = bar_index - startBarIndex
    int maxLookback = 198  // Conservative limit to stay within historical buffer

    if barsBack > 1 and barsBack < maxLookback
        // Scan forwards from startBarIndex to find a swing high
        for i = barsBack - 1 to math.max(1, barsBack - maxBarsToScan)
            if i >= 1 and i < maxLookback and not na(high[i]) and not na(high[i-1]) and not na(high[i+1])
                // Check if this is a swing high (higher than neighbors)
                if high[i] > high[i-1] and high[i] > high[i+1]
                    swingPrice := high[i]
                    swingBar := bar_index - i
                    break

    [swingPrice, swingBar]

findSwingLowBefore(int startBarIndex, int maxBarsToScan) =>
    float swingPrice = na
    int swingBar = na
    int barsBack = bar_index - startBarIndex
    int maxLookback = 198  // Conservative limit to stay within historical buffer

    if barsBack >= 0 and barsBack < maxLookback
        // Scan backwards from startBarIndex to find a swing low
        for i = barsBack + 1 to math.min(barsBack + maxBarsToScan, maxLookback - 1)
            if i >= 1 and i < maxLookback and not na(low[i]) and not na(low[i-1]) and not na(low[i+1])
                // Check if this is a swing low (lower than neighbors)
                if low[i] < low[i-1] and low[i] < low[i+1]
                    swingPrice := low[i]
                    swingBar := bar_index - i
                    break

    [swingPrice, swingBar]

findSwingLowAfter(int startBarIndex, int maxBarsToScan) =>
    float swingPrice = na
    int swingBar = na
    int barsBack = bar_index - startBarIndex
    int maxLookback = 198  // Conservative limit to stay within historical buffer

    if barsBack > 1 and barsBack < maxLookback
        // Scan forwards from startBarIndex to find a swing low
        for i = barsBack - 1 to math.max(1, barsBack - maxBarsToScan)
            if i >= 1 and i < maxLookback and not na(low[i]) and not na(low[i-1]) and not na(low[i+1])
                // Check if this is a swing low (lower than neighbors)
                if low[i] < low[i-1] and low[i] < low[i+1]
                    swingPrice := low[i]
                    swingBar := bar_index - i
                    break

    [swingPrice, swingBar]

// Calculate demand zone from an HTF swing low
// Zone bottom = the low price at lowBarIndex
// Zone top = the LOWER of the two swing highs (before and after)
// Returns [zoneTop, zoneBottom, leftTime]
calculateZoneFromLow(int lowBarIndex) =>
    float zoneTop = na
    float zoneBottom = na
    int leftTime = na
    int maxLookback = 198  // Conservative limit to stay within historical buffer

    int barsBack = bar_index - lowBarIndex

    if barsBack >= 0 and barsBack < maxLookback
        // Zone bottom is the low at the given bar
        zoneBottom := low[barsBack]

        // First try CTF arrays
        float highBeforePrice = na
        int highBeforeBar = na
        float highAfterPrice = na
        int highAfterBar = na

        // Search CTF highs array for high before this low
        if array.size(highs) > 0
            for i = array.size(highs) - 1 to 0
                highLevel = array.get(highs, i)
                if highLevel.barIndex <= lowBarIndex
                    highBeforePrice := highLevel.price
                    highBeforeBar := highLevel.barIndex
                    break

        // Search CTF highs array for high after this low
        if array.size(highs) > 0
            for i = 0 to array.size(highs) - 1
                highLevel = array.get(highs, i)
                if highLevel.barIndex >= lowBarIndex
                    highAfterPrice := highLevel.price
                    highAfterBar := highLevel.barIndex
                    break

        // If CTF arrays didn't have results, scan bar data directly
        if na(highBeforePrice)
            [scanPrice, scanBar] = findSwingHighBefore(lowBarIndex, 50)
            highBeforePrice := scanPrice
            highBeforeBar := scanBar

        if na(highAfterPrice)
            [scanPrice, scanBar] = findSwingHighAfter(lowBarIndex, 50)
            highAfterPrice := scanPrice
            highAfterBar := scanBar

        // Use the LOWER of the two valid highs (creates smaller zone)
        // But always use the leftTime from the "before" high to ensure HTF pivot is included
        if not na(highBeforePrice) and not na(highAfterPrice)
            if highBeforePrice <= highAfterPrice
                zoneTop := highBeforePrice
            else
                zoneTop := highAfterPrice
            // Always start zone from the earlier (before) high
            if not na(highBeforeBar)
                int offset = bar_index - highBeforeBar
                if offset >= 0 and offset < maxLookback
                    leftTime := time[offset]
        else if not na(highBeforePrice)
            zoneTop := highBeforePrice
            if not na(highBeforeBar)
                int offset = bar_index - highBeforeBar
                if offset >= 0 and offset < maxLookback
                    leftTime := time[offset]
        else if not na(highAfterPrice)
            zoneTop := highAfterPrice
            if not na(highAfterBar)
                int offset = bar_index - highAfterBar
                if offset >= 0 and offset < maxLookback
                    leftTime := time[offset]
        else
            // Last fallback: just use the high at the low bar
            zoneTop := high[barsBack]
            leftTime := time[barsBack]

    [zoneTop, zoneBottom, leftTime]

// Calculate supply zone from an HTF swing high
// Zone top = the high price at highBarIndex
// Zone bottom = the HIGHER of the two swing lows (before and after)
// Returns [zoneTop, zoneBottom, leftTime]
calculateZoneFromHigh(int highBarIndex) =>
    float zoneTop = na
    float zoneBottom = na
    int leftTime = na
    int maxLookback = 198  // Conservative limit to stay within historical buffer

    int barsBack = bar_index - highBarIndex

    if barsBack >= 0 and barsBack < maxLookback
        // Zone top is the high at the given bar
        zoneTop := high[barsBack]

        // First try CTF arrays
        float lowBeforePrice = na
        int lowBeforeBar = na
        float lowAfterPrice = na
        int lowAfterBar = na

        // Search CTF lows array for low before this high
        if array.size(lows) > 0
            for i = array.size(lows) - 1 to 0
                lowLevel = array.get(lows, i)
                if lowLevel.barIndex <= highBarIndex
                    lowBeforePrice := lowLevel.price
                    lowBeforeBar := lowLevel.barIndex
                    break

        // Search CTF lows array for low after this high
        if array.size(lows) > 0
            for i = 0 to array.size(lows) - 1
                lowLevel = array.get(lows, i)
                if lowLevel.barIndex >= highBarIndex
                    lowAfterPrice := lowLevel.price
                    lowAfterBar := lowLevel.barIndex
                    break

        // If CTF arrays didn't have results, scan bar data directly
        if na(lowBeforePrice)
            [scanPrice, scanBar] = findSwingLowBefore(highBarIndex, 50)
            lowBeforePrice := scanPrice
            lowBeforeBar := scanBar

        if na(lowAfterPrice)
            [scanPrice, scanBar] = findSwingLowAfter(highBarIndex, 50)
            lowAfterPrice := scanPrice
            lowAfterBar := scanBar

        // Use the HIGHER of the two valid lows (creates smaller zone)
        // But always use the leftTime from the "before" low to ensure HTF pivot is included
        if not na(lowBeforePrice) and not na(lowAfterPrice)
            if lowBeforePrice >= lowAfterPrice
                zoneBottom := lowBeforePrice
            else
                zoneBottom := lowAfterPrice
            // Always start zone from the earlier (before) low
            if not na(lowBeforeBar)
                int offset = bar_index - lowBeforeBar
                if offset >= 0 and offset < maxLookback
                    leftTime := time[offset]
        else if not na(lowBeforePrice)
            zoneBottom := lowBeforePrice
            if not na(lowBeforeBar)
                int offset = bar_index - lowBeforeBar
                if offset >= 0 and offset < maxLookback
                    leftTime := time[offset]
        else if not na(lowAfterPrice)
            zoneBottom := lowAfterPrice
            if not na(lowAfterBar)
                int offset = bar_index - lowAfterBar
                if offset >= 0 and offset < maxLookback
                    leftTime := time[offset]
        else
            // Last fallback: just use the low at the high bar
            zoneBottom := low[barsBack]
            leftTime := time[barsBack]

    [zoneTop, zoneBottom, leftTime]

// ============================================================================
// CTF ZONE CALCULATION FUNCTIONS (Walk-back algorithm)
// ============================================================================

// Calculate CTF demand zone from a valid low
// SIMPLIFIED: Zone top = most recent valid high price, Zone bottom = valid low price
// Returns [zoneTop, zoneBottom, leftTime, barsWalked]
calculateCtfDemandZone(int lowBarIndex, float lowPrice) =>
    float zoneTop = na
    float zoneBottom = lowPrice
    int leftTime = na
    int barsWalked = 0

    int barsBack = bar_index - lowBarIndex

    // Use the current valid high as zone top (this is the high that just got broken)
    if not na(currentValidHigh)
        zoneTop := currentValidHigh
        leftTime := time[barsBack]
        barsWalked := 1

    [zoneTop, zoneBottom, leftTime, barsWalked]

// Calculate CTF supply zone from a valid high
// SIMPLIFIED: Zone top = valid high price, Zone bottom = most recent valid low price
// Returns [zoneTop, zoneBottom, leftTime]
calculateCtfSupplyZone(int highBarIndex, float highPrice) =>
    float zoneTop = highPrice
    float zoneBottom = na
    int leftTime = na

    int barsBack = bar_index - highBarIndex

    // Use the current valid low as zone bottom (this is the low that just got broken)
    if not na(currentValidLow)
        zoneBottom := currentValidLow
        leftTime := time[barsBack]

    [zoneTop, zoneBottom, leftTime]

// ============================================================================
// LEVEL MANAGEMENT FUNCTIONS
// ============================================================================

// Add a new high level
addHigh(float price, int barIdx, string levelType, color lineColor) =>
    // Delete previous most recent high line if it's not broken or swept
    if mostRecentHighIndex >= 0
        prevHigh = array.get(highs, mostRecentHighIndex)
        if prevHigh.levelType != "broken" and prevHigh.levelType != "swept" and not na(prevHigh.levelLine)
            line.delete(prevHigh.levelLine)

    // Create new line only if peaks/valleys are enabled
    line newLine = na
    if showCtfPeaksValleys
        newLine := line.new(barIdx, price, barIdx + 1, price,
                           color=lineColor,
                           width=lineWidth,
                           extend=extend.right,
                           style=line.style_solid)

    // Create new HighLevel object
    newHigh = HighLevel.new(price, barIdx, newLine, levelType, false)
    array.push(highs, newHigh)

    // Create label if enabled
    if showCtfLabels
        label.new(barIdx, price, "",
                 style=label.style_label_down,
                 color=lineColor,
                 textcolor=color.white,
                 size=size.tiny)

    true

// Add a new low level
addLow(float price, int barIdx, string levelType, color lineColor) =>
    // Delete previous most recent low line if it's not broken or swept
    if mostRecentLowIndex >= 0
        prevLow = array.get(lows, mostRecentLowIndex)
        if prevLow.levelType != "broken" and prevLow.levelType != "swept" and not na(prevLow.levelLine)
            line.delete(prevLow.levelLine)

    // Create new line only if peaks/valleys are enabled
    line newLine = na
    if showCtfPeaksValleys
        newLine := line.new(barIdx, price, barIdx + 1, price,
                           color=lineColor,
                           width=lineWidth,
                           extend=extend.right,
                           style=line.style_solid)

    // Create new LowLevel object
    newLow = LowLevel.new(price, barIdx, newLine, levelType, false)
    array.push(lows, newLow)

    // Create label if enabled
    if showCtfLabels
        label.new(barIdx, price, "",
                 style=label.style_label_up,
                 color=lineColor,
                 textcolor=color.white,
                 size=size.tiny)

    true

// HTF versions
addHighHTF(float price, int barIdx, string levelType, color lineColor) =>
    if htfMostRecentHighIndex >= 0
        prevHigh = array.get(htfHighs, htfMostRecentHighIndex)
        if prevHigh.levelType != "broken" and prevHigh.levelType != "swept" and not na(prevHigh.levelLine)
            line.delete(prevHigh.levelLine)

    // Create new line only if peaks/valleys are enabled
    line newLine = na
    if showHtfPeaksValleys
        newLine := line.new(barIdx, price, barIdx + 1, price,
                           color=lineColor,
                           width=lineWidth + 1,  // Thicker for HTF
                           extend=extend.right,
                           style=line.style_solid)

    newHigh = HighLevel.new(price, barIdx, newLine, levelType, false)
    array.push(htfHighs, newHigh)

    if showHtfLabels
        label.new(barIdx, price, "",
                 style=label.style_label_down,
                 color=lineColor,
                 textcolor=color.white,
                 size=size.small)

    true

addLowHTF(float price, int barIdx, string levelType, color lineColor) =>
    if htfMostRecentLowIndex >= 0
        prevLow = array.get(htfLows, htfMostRecentLowIndex)
        if prevLow.levelType != "broken" and prevLow.levelType != "swept" and not na(prevLow.levelLine)
            line.delete(prevLow.levelLine)

    // Create new line only if peaks/valleys are enabled
    line newLine = na
    if showHtfPeaksValleys
        newLine := line.new(barIdx, price, barIdx + 1, price,
                           color=lineColor,
                           width=lineWidth + 1,  // Thicker for HTF
                           extend=extend.right,
                           style=line.style_solid)

    newLow = LowLevel.new(price, barIdx, newLine, levelType, false)
    array.push(htfLows, newLow)

    if showHtfLabels
        label.new(barIdx, price, "",
                 style=label.style_label_up,
                 color=lineColor,
                 textcolor=color.white,
                 size=size.small)

    true

// HTF2 (Trading Range) versions - uses htf2HighColor/htf2LowColor with peak/valley labels
addHighHTF2(float price, int barIdx, string levelType) =>
    if htf2MostRecentHighIndex >= 0
        prevHigh = array.get(htf2Highs, htf2MostRecentHighIndex)
        if prevHigh.levelType != "broken" and prevHigh.levelType != "swept" and not na(prevHigh.levelLine)
            line.delete(prevHigh.levelLine)

    // Create new line only if peaks/valleys are enabled
    line newLine = na
    if showHtf2PeaksValleys
        newLine := line.new(barIdx, price, barIdx + 1, price,
                           color=htf2HighColor,
                           width=lineWidth + 2,  // Thickest for HTF2
                           extend=extend.right,
                           style=line.style_solid)

    // Create label at the peak (top label pointing down)
    if showHtf2Labels
        label.new(barIdx, price, levelType == "weak" ? "W" : "S",
                  style=label.style_label_down,
                  color=htf2HighColor,
                  textcolor=color.white,
                  size=size.small)

    newHigh = HighLevel.new(price, barIdx, newLine, levelType, false)
    array.push(htf2Highs, newHigh)

    true

addLowHTF2(float price, int barIdx, string levelType) =>
    if htf2MostRecentLowIndex >= 0
        prevLow = array.get(htf2Lows, htf2MostRecentLowIndex)
        if prevLow.levelType != "broken" and prevLow.levelType != "swept" and not na(prevLow.levelLine)
            line.delete(prevLow.levelLine)

    // Create new line only if peaks/valleys are enabled
    line newLine = na
    if showHtf2PeaksValleys
        newLine := line.new(barIdx, price, barIdx + 1, price,
                           color=htf2LowColor,
                           width=lineWidth + 2,  // Thickest for HTF2
                           extend=extend.right,
                           style=line.style_solid)

    // Create label at the valley (bottom label pointing up)
    if showHtf2Labels
        label.new(barIdx, price, levelType == "weak" ? "W" : "S",
                  style=label.style_label_up,
                  color=htf2LowColor,
                  textcolor=color.white,
                  size=size.small)

    newLow = LowLevel.new(price, barIdx, newLine, levelType, false)
    array.push(htf2Lows, newLow)

    true

// ============================================================================
// ZONE MANAGEMENT FUNCTIONS
// ============================================================================

// Helper to check if a demand zone should be broken
checkDemandZone(Zone zone) =>
    if not zone.broken
        bool isTouching = low <= zone.top and high >= zone.bottom
        if isTouching and not zone.touched
            zone.touched := true
        bool shouldBreak = close < zone.bottom or (zoneBreakOnWick and low < zone.bottom) or ((zoneBreakOnFirstTouch or zoneBreakOnTouchAfterCreation) and isTouching and bar_index > zone.creationBar)
        if shouldBreak
            zone.broken := true
            zone.rightTime := time
    true

// Helper to check if a supply zone should be broken
checkSupplyZone(Zone zone) =>
    if not zone.broken
        bool isTouching = low <= zone.top and high >= zone.bottom
        if isTouching and not zone.touched
            zone.touched := true
        bool shouldBreak = close > zone.top or (zoneBreakOnWick and high > zone.top) or ((zoneBreakOnFirstTouch or zoneBreakOnTouchAfterCreation) and isTouching and bar_index > zone.creationBar)
        if shouldBreak
            zone.broken := true
            zone.rightTime := time
    true

// Check and update all broken zones
checkAllBrokenZones() =>
    // CTF zones
    for i = 0 to math.max(0, array.size(ctfDemandZones) - 1)
        if i < array.size(ctfDemandZones)
            checkDemandZone(array.get(ctfDemandZones, i))
    for i = 0 to math.max(0, array.size(ctfSupplyZones) - 1)
        if i < array.size(ctfSupplyZones)
            checkSupplyZone(array.get(ctfSupplyZones, i))
    // HTF zones
    for i = 0 to math.max(0, array.size(demandZones) - 1)
        if i < array.size(demandZones)
            checkDemandZone(array.get(demandZones, i))
    for i = 0 to math.max(0, array.size(supplyZones) - 1)
        if i < array.size(supplyZones)
            checkSupplyZone(array.get(supplyZones, i))
    // HTF2 zones
    for i = 0 to math.max(0, array.size(htf2DemandZones) - 1)
        if i < array.size(htf2DemandZones)
            checkDemandZone(array.get(htf2DemandZones, i))
    for i = 0 to math.max(0, array.size(htf2SupplyZones) - 1)
        if i < array.size(htf2SupplyZones)
            checkSupplyZone(array.get(htf2SupplyZones, i))
    true

// ============================================================================
// CHECK FOR BROKEN AND SWEPT LEVELS
// ============================================================================

// Returns [bullishBos, bearishBos]
checkBrokenLevels() =>
    bool bullishBos = false
    bool bearishBos = false

    // Check highs for sweeps and breaks
    if array.size(highs) > 0
        // Iterate from most recent to oldest
        for i = array.size(highs) - 1 to 0
            highLevel = array.get(highs, i)

            // Check for sweep (wick crosses but close doesn't)
            if highLevel.levelType != "swept" and highLevel.levelType != "broken" and high > highLevel.price and close <= highLevel.price
                highLevel.levelType := "swept"
                if not na(highLevel.levelLine)
                    line.set_style(highLevel.levelLine, line.style_dashed)
                array.set(highs, i, highLevel)

            // Check for break (close crosses above)
            else if highLevel.levelType != "broken" and close > highLevel.price
                highLevel.levelType := "broken"

                // Only the most recent high breaking constitutes a valid BOS
                // Other highs breaking are just old levels being cleared, not structure breaks
                if i == mostRecentHighIndex
                    // Create demand zone for valid BOS
                    if showCtfZones
                        int barsBack = bar_index - highLevel.barIndex
                        if barsBack >= 0 and barsBack < 5000
                            // Find the low between this high and current bar (zone bottom)
                            float zoneBottom = low
                            int zoneBottomIdx = 0
                            for j = 0 to math.min(barsBack, 200)
                                if low[j] < zoneBottom
                                    zoneBottom := low[j]
                                    zoneBottomIdx := j

                            float zoneTop = na
                            int zoneLeftIdx = zoneBottomIdx

                            if ctfZonesUseFullSwings
                                // Use full swing: zone top = the broken high's price
                                zoneTop := highLevel.price
                                zoneLeftIdx := barsBack
                            else
                                // Walk-back algorithm: find bearish candles before the low
                                // Step 1: Walk back from low until we find at least one bearish candle
                                // Step 2: Continue walking back through bearish candles until we hit a bullish one
                                // Step 3: Zone top = highest high of those bearish candles
                                bool foundBearish = false
                                float highestBearishHigh = na
                                int maxWalk = math.min(zoneBottomIdx + 50, 200)  // Don't walk too far

                                for j = zoneBottomIdx to maxWalk
                                    bool isBearish = close[j] < open[j]
                                    bool isBullish = close[j] > open[j]

                                    if not foundBearish
                                        // Still looking for first bearish candle
                                        if isBearish
                                            foundBearish := true
                                            highestBearishHigh := high[j]
                                            zoneLeftIdx := j
                                    else
                                        // We've found bearish, keep going until bullish
                                        if isBullish
                                            break
                                        else if isBearish
                                            if high[j] > highestBearishHigh
                                                highestBearishHigh := high[j]
                                            zoneLeftIdx := j

                                zoneTop := foundBearish ? highestBearishHigh : highLevel.price

                            int zoneLeftTime = time[zoneLeftIdx]
                            if not na(zoneTop) and zoneTop > zoneBottom
                                newZone = Zone.new(zoneTop, zoneBottom, zoneLeftTime, time, false, false, bar_index)
                                array.push(ctfDemandZones, newZone)

                // Update the object back in the array
                array.set(highs, i, highLevel)

                // Only keep line visible if this is most recent high (valid BOS)
                if i == mostRecentHighIndex
                    if not na(highLevel.levelLine)
                        line.set_x2(highLevel.levelLine, bar_index)
                        line.set_extend(highLevel.levelLine, extend.none)
                        line.set_style(highLevel.levelLine, line.style_dotted)
                        line.set_color(highLevel.levelLine, color.new(bosColor, 30))

                    // Set alert flag for bullish CTF BOS
                    bullishBos := true

                    if showCtfBosLabels
                        centerBar = math.round((highLevel.barIndex + bar_index) / 2)
                        label.new(centerBar, highLevel.price, "BOS↑",
                                 style=label.style_label_center,
                                 color=color.white,
                                 textcolor=bosColor,
                                 size=size.tiny)
                else
                    if not na(highLevel.levelLine)
                        line.delete(highLevel.levelLine)

    // Check lows for sweeps and breaks
    if array.size(lows) > 0
        // Iterate from most recent to oldest
        for i = array.size(lows) - 1 to 0
            lowLevel = array.get(lows, i)

            // Check for sweep
            if lowLevel.levelType != "swept" and lowLevel.levelType != "broken" and low < lowLevel.price and close >= lowLevel.price
                lowLevel.levelType := "swept"
                if not na(lowLevel.levelLine)
                    line.set_style(lowLevel.levelLine, line.style_dashed)
                array.set(lows, i, lowLevel)

            // Check for break
            else if lowLevel.levelType != "broken" and close < lowLevel.price
                lowLevel.levelType := "broken"

                // Only the most recent low breaking constitutes a valid BOS
                // Other lows breaking are just old levels being cleared, not structure breaks
                if i == mostRecentLowIndex
                    // Create supply zone for valid BOS
                    if showCtfZones
                        int barsBack = bar_index - lowLevel.barIndex
                        if barsBack >= 0 and barsBack < 5000
                            // Find the high between this low and current bar (zone top)
                            float zoneTop = high
                            int zoneTopIdx = 0
                            for j = 0 to math.min(barsBack, 200)
                                if high[j] > zoneTop
                                    zoneTop := high[j]
                                    zoneTopIdx := j

                            float zoneBottom = na
                            int zoneLeftIdx = zoneTopIdx

                            if ctfZonesUseFullSwings
                                // Use full swing: zone bottom = the broken low's price
                                zoneBottom := lowLevel.price
                                zoneLeftIdx := barsBack
                            else
                                // Walk-back algorithm: find bullish candles before the high
                                // Step 1: Walk back from high until we find at least one bullish candle
                                // Step 2: Continue walking back through bullish candles until we hit a bearish one
                                // Step 3: Zone bottom = lowest low of those bullish candles
                                bool foundBullish = false
                                float lowestBullishLow = na
                                int maxWalk = math.min(zoneTopIdx + 50, 200)  // Don't walk too far

                                for j = zoneTopIdx to maxWalk
                                    bool isBearish = close[j] < open[j]
                                    bool isBullish = close[j] > open[j]

                                    if not foundBullish
                                        // Still looking for first bullish candle
                                        if isBullish
                                            foundBullish := true
                                            lowestBullishLow := low[j]
                                            zoneLeftIdx := j
                                    else
                                        // We've found bullish, keep going until bearish
                                        if isBearish
                                            break
                                        else if isBullish
                                            if low[j] < lowestBullishLow
                                                lowestBullishLow := low[j]
                                            zoneLeftIdx := j

                                zoneBottom := foundBullish ? lowestBullishLow : lowLevel.price

                            int zoneLeftTime = time[zoneLeftIdx]
                            if not na(zoneBottom) and zoneTop > zoneBottom
                                newZone = Zone.new(zoneTop, zoneBottom, zoneLeftTime, time, false, false, bar_index)
                                array.push(ctfSupplyZones, newZone)

                // Update the object back in the array
                array.set(lows, i, lowLevel)

                if i == mostRecentLowIndex
                    if not na(lowLevel.levelLine)
                        line.set_x2(lowLevel.levelLine, bar_index)
                        line.set_extend(lowLevel.levelLine, extend.none)
                        line.set_style(lowLevel.levelLine, line.style_dotted)
                        line.set_color(lowLevel.levelLine, color.new(bosColor, 30))

                    // Set alert flag for bearish CTF BOS
                    bearishBos := true

                    if showCtfBosLabels
                        centerBar = math.round((lowLevel.barIndex + bar_index) / 2)
                        label.new(centerBar, lowLevel.price, "BOS↓",
                                 style=label.style_label_center,
                                 color=color.white,
                                 textcolor=bosColor,
                                 size=size.tiny)
                else
                    if not na(lowLevel.levelLine)
                        line.delete(lowLevel.levelLine)

    [bullishBos, bearishBos]

// HTF version - checks for broken/swept levels
// Creates zones for immediate BOS (when most recent level is broken, including after sweep)
// Uses savedHighIdx/savedLowIdx which are captured BEFORE main BOS logic updates them
// Returns [bullishLabelsCreated, bearishLabelsCreated, demandZonesCreated, supplyZonesCreated, bullishBos, bearishBos]
checkBrokenLevelsHTF(htfHigh, htfLow, htfClose, int savedHighIdx, int savedLowIdx) =>
    int bullishLabels = 0
    int bearishLabels = 0
    int demandCreated = 0
    int supplyCreated = 0
    bool bullishBos = false
    bool bearishBos = false

    if array.size(htfHighs) > 0
        for i = 0 to array.size(htfHighs) - 1
            highLevel = array.get(htfHighs, i)

            if highLevel.levelType != "swept" and highLevel.levelType != "broken" and htfHigh > highLevel.price and htfClose <= highLevel.price
                highLevel.levelType := "swept"
                if not na(highLevel.levelLine)
                    line.set_style(highLevel.levelLine, line.style_dashed)

            else if highLevel.levelType != "broken" and htfClose > highLevel.price
                highLevel.levelType := "broken"

                // Style the broken line
                if not na(highLevel.levelLine)
                    line.set_x2(highLevel.levelLine, bar_index)
                    line.set_extend(highLevel.levelLine, extend.none)
                    line.set_style(highLevel.levelLine, line.style_dotted)
                    line.set_color(highLevel.levelLine, color.new(htfBosColor, 30))

                // Set BOS flag
                bullishBos := true

                // Create BOS label
                if showHtfBosLabels
                    centerBar = math.round((highLevel.barIndex + bar_index) / 2)
                    label.new(centerBar, highLevel.price, htfTimeframe + " BOS↑",
                             style=label.style_label_center,
                             color=color.white,
                             textcolor=htfBosColor,
                             size=size.tiny)
                    bullishLabels := bullishLabels + 1

                // Create zone if this is the most recent high (immediate BOS)
                // Use savedHighIdx which was captured BEFORE main logic updated it
                if i == savedHighIdx
                    // Bullish BOS (high broken) -> Create DEMAND zone
                    [lowPrice, lowBar] = findLowestBetween(highLevel.barIndex, bar_index)
                    if not na(lowBar)
                        [zoneTop, zoneBottom, zoneLeftTime] = calculateZoneFromLow(lowBar)
                        if not na(zoneTop) and not na(zoneBottom) and not na(zoneLeftTime)
                            bool isDuplicate = false
                            if array.size(demandZones) > 0
                                for j = array.size(demandZones) - 1 to math.max(0, array.size(demandZones) - 20)
                                    existingZone = array.get(demandZones, j)
                                    if existingZone.leftTime == zoneLeftTime and existingZone.top == zoneTop and existingZone.bottom == zoneBottom
                                        isDuplicate := true
                                        break
                            if not isDuplicate
                                newZone = Zone.new(zoneTop, zoneBottom, zoneLeftTime, time, false, false, bar_index)
                                array.push(demandZones, newZone)
                                demandCreated := demandCreated + 1

    if array.size(htfLows) > 0
        for i = 0 to array.size(htfLows) - 1
            lowLevel = array.get(htfLows, i)

            if lowLevel.levelType != "swept" and lowLevel.levelType != "broken" and htfLow < lowLevel.price and htfClose >= lowLevel.price
                lowLevel.levelType := "swept"
                if not na(lowLevel.levelLine)
                    line.set_style(lowLevel.levelLine, line.style_dashed)

            else if lowLevel.levelType != "broken" and htfClose < lowLevel.price
                lowLevel.levelType := "broken"

                // Style the broken line
                if not na(lowLevel.levelLine)
                    line.set_x2(lowLevel.levelLine, bar_index)
                    line.set_extend(lowLevel.levelLine, extend.none)
                    line.set_style(lowLevel.levelLine, line.style_dotted)
                    line.set_color(lowLevel.levelLine, color.new(htfBosColor, 30))

                // Set BOS flag
                bearishBos := true

                // Create BOS label
                if showHtfBosLabels
                    centerBar = math.round((lowLevel.barIndex + bar_index) / 2)
                    label.new(centerBar, lowLevel.price, htfTimeframe + " BOS↓",
                             style=label.style_label_center,
                             color=color.white,
                             textcolor=htfBosColor,
                             size=size.tiny)
                    bearishLabels := bearishLabels + 1

                // Create zone if this is the most recent low (immediate BOS)
                // Use savedLowIdx which was captured BEFORE main logic updated it
                if i == savedLowIdx
                    // Bearish BOS (low broken) -> Create SUPPLY zone
                    [highPrice, highBar] = findHighestBetween(lowLevel.barIndex, bar_index)
                    if not na(highBar)
                        [zoneTop, zoneBottom, zoneLeftTime] = calculateZoneFromHigh(highBar)
                        if not na(zoneTop) and not na(zoneBottom) and not na(zoneLeftTime)
                            bool isDuplicate = false
                            if array.size(supplyZones) > 0
                                for j = array.size(supplyZones) - 1 to math.max(0, array.size(supplyZones) - 20)
                                    existingZone = array.get(supplyZones, j)
                                    if existingZone.leftTime == zoneLeftTime and existingZone.top == zoneTop and existingZone.bottom == zoneBottom
                                        isDuplicate := true
                                        break
                            if not isDuplicate
                                newZone = Zone.new(zoneTop, zoneBottom, zoneLeftTime, time, false, false, bar_index)
                                array.push(supplyZones, newZone)
                                supplyCreated := supplyCreated + 1

    [bullishLabels, bearishLabels, demandCreated, supplyCreated, bullishBos, bearishBos]

// HTF2 (Trading Range) version - checks for broken/swept levels and creates zones
// Returns [demandCreated, supplyCreated, bullishBos, bearishBos]
checkBrokenLevelsHTF2(htf2High, htf2Low, htf2Close, int savedHighIdx, int savedLowIdx) =>
    int demandCreated = 0
    int supplyCreated = 0
    bool bullishBos = false
    bool bearishBos = false

    if array.size(htf2Highs) > 0
        for i = 0 to array.size(htf2Highs) - 1
            highLevel = array.get(htf2Highs, i)

            if highLevel.levelType != "swept" and highLevel.levelType != "broken" and htf2High > highLevel.price and htf2Close <= highLevel.price
                highLevel.levelType := "swept"
                if not na(highLevel.levelLine)
                    line.set_style(highLevel.levelLine, line.style_dashed)

            else if highLevel.levelType != "broken" and htf2Close > highLevel.price
                highLevel.levelType := "broken"

                // Style the broken line - keep it visible but dotted
                if not na(highLevel.levelLine)
                    line.set_x2(highLevel.levelLine, bar_index)
                    line.set_extend(highLevel.levelLine, extend.none)
                    line.set_style(highLevel.levelLine, line.style_dotted)
                    line.set_color(highLevel.levelLine, color.new(htf2HighColor, 50))

                // Set BOS flag
                bullishBos := true

                // Create BOS label
                if showHtf2BosLabels
                    centerBar = math.round((highLevel.barIndex + bar_index) / 2)
                    label.new(centerBar, highLevel.price, htf2Timeframe + " BOS↑",
                             style=label.style_label_center,
                             color=color.white,
                             textcolor=htf2LowColor,
                             size=size.tiny)

                // Create HTF2 demand zone if this is the most recent high
                if i == savedHighIdx
                    [lowPrice, lowBar] = findLowestBetween(highLevel.barIndex, bar_index)
                    if not na(lowBar)
                        [zoneTop, zoneBottom, zoneLeftTime] = calculateZoneFromLow(lowBar)
                        if not na(zoneTop) and not na(zoneBottom) and not na(zoneLeftTime)
                            bool isDuplicate = false
                            if array.size(htf2DemandZones) > 0
                                for j = array.size(htf2DemandZones) - 1 to math.max(0, array.size(htf2DemandZones) - 20)
                                    existingZone = array.get(htf2DemandZones, j)
                                    if existingZone.leftTime == zoneLeftTime and existingZone.top == zoneTop and existingZone.bottom == zoneBottom
                                        isDuplicate := true
                                        break
                            if not isDuplicate
                                newZone = Zone.new(zoneTop, zoneBottom, zoneLeftTime, time, false, false, bar_index)
                                array.push(htf2DemandZones, newZone)
                                demandCreated := demandCreated + 1

    if array.size(htf2Lows) > 0
        for i = 0 to array.size(htf2Lows) - 1
            lowLevel = array.get(htf2Lows, i)

            if lowLevel.levelType != "swept" and lowLevel.levelType != "broken" and htf2Low < lowLevel.price and htf2Close >= lowLevel.price
                lowLevel.levelType := "swept"
                if not na(lowLevel.levelLine)
                    line.set_style(lowLevel.levelLine, line.style_dashed)

            else if lowLevel.levelType != "broken" and htf2Close < lowLevel.price
                lowLevel.levelType := "broken"

                // Style the broken line - keep it visible but dotted
                if not na(lowLevel.levelLine)
                    line.set_x2(lowLevel.levelLine, bar_index)
                    line.set_extend(lowLevel.levelLine, extend.none)
                    line.set_style(lowLevel.levelLine, line.style_dotted)
                    line.set_color(lowLevel.levelLine, color.new(htf2LowColor, 50))

                // Set BOS flag
                bearishBos := true

                // Create BOS label
                if showHtf2BosLabels
                    centerBar = math.round((lowLevel.barIndex + bar_index) / 2)
                    label.new(centerBar, lowLevel.price, htf2Timeframe + " BOS↓",
                             style=label.style_label_center,
                             color=color.white,
                             textcolor=htf2HighColor,
                             size=size.tiny)

                // Create HTF2 supply zone if this is the most recent low
                if i == savedLowIdx
                    [highPrice, highBar] = findHighestBetween(lowLevel.barIndex, bar_index)
                    if not na(highBar)
                        [zoneTop, zoneBottom, zoneLeftTime] = calculateZoneFromHigh(highBar)
                        if not na(zoneTop) and not na(zoneBottom) and not na(zoneLeftTime)
                            bool isDuplicate = false
                            if array.size(htf2SupplyZones) > 0
                                for j = array.size(htf2SupplyZones) - 1 to math.max(0, array.size(htf2SupplyZones) - 20)
                                    existingZone = array.get(htf2SupplyZones, j)
                                    if existingZone.leftTime == zoneLeftTime and existingZone.top == zoneTop and existingZone.bottom == zoneBottom
                                        isDuplicate := true
                                        break
                            if not isDuplicate
                                newZone = Zone.new(zoneTop, zoneBottom, zoneLeftTime, time, false, false, bar_index)
                                array.push(htf2SupplyZones, newZone)
                                supplyCreated := supplyCreated + 1

    [demandCreated, supplyCreated, bullishBos, bearishBos]

// Determine level type based on BOS direction
getHighLevelType(string bosDirection) =>
    bosDirection == "bullish" ? "weak" : "strong"

getLowLevelType(string bosDirection) =>
    bosDirection == "bearish" ? "weak" : "strong"

// ============================================================================
// NEAREST UNBROKEN LEVEL FUNCTIONS
// ============================================================================

// Find the nearest unbroken high in an array (searching from most recent backwards)
// Returns the index of the nearest unbroken high, or -1 if none found
findNearestUnbrokenHigh(array<HighLevel> highsArray) =>
    int result = -1
    if array.size(highsArray) > 0
        for i = array.size(highsArray) - 1 to 0
            highLevel = array.get(highsArray, i)
            if highLevel.levelType != "broken"
                result := i
                break
    result

// Find the nearest unbroken low in an array (searching from most recent backwards)
// Returns the index of the nearest unbroken low, or -1 if none found
findNearestUnbrokenLow(array<LowLevel> lowsArray) =>
    int result = -1
    if array.size(lowsArray) > 0
        for i = array.size(lowsArray) - 1 to 0
            lowLevel = array.get(lowsArray, i)
            if lowLevel.levelType != "broken"
                result := i
                break
    result

// ============================================================================
// INITIALIZATION
// ============================================================================

if not initialized and bar_index > 0
    if isBearishBreakdown()
        float localHigh = high
        int localHighBar = bar_index

        for i = 1 to math.min(bar_index, 200)
            if high[i] > localHigh
                localHigh := high[i]
                localHighBar := bar_index - i

        currentValidHigh := localHigh
        currentValidHighBar := localHighBar
        initialized := true
        lookingForLow := true

        addHigh(localHigh, localHighBar, "strong", highColor)
        mostRecentHighIndex := array.size(highs) - 1

// ============================================================================
// MAIN LOGIC
// ============================================================================

if initialized
    // Check broken/swept levels and zones
    [ctfBullBos, ctfBearBos] = checkBrokenLevels()
    // Set CTF BOS alert flags
    if ctfBullBos
        ctfBullishBosFlag := true
    if ctfBearBos
        ctfBearishBosFlag := true
    checkAllBrokenZones()

    // Update nearest unbroken levels (structure boundaries) - CTF
    int ctfNewHighIdx = findNearestUnbrokenHigh(highs)
    if ctfNewHighIdx != nearestUnbrokenHighIndex or (ctfNewHighIdx >= 0 and na(nearestUnbrokenHighLine))
        if not na(nearestUnbrokenHighLine)
            line.delete(nearestUnbrokenHighLine)
            nearestUnbrokenHighLine := na
        nearestUnbrokenHighIndex := ctfNewHighIdx
        if ctfNewHighIdx >= 0 and ctfNewHighIdx != mostRecentHighIndex
            ctfHighLevel = array.get(highs, ctfNewHighIdx)
            // Use bar_index instead of stored barIndex to avoid "too far" error
            nearestUnbrokenHighLine := line.new(bar_index, ctfHighLevel.price, bar_index + 1, ctfHighLevel.price, color=color.new(highColor, 50), width=lineWidth, extend=extend.right, style=line.style_dashed)
    if not na(nearestUnbrokenHighLine)
        line.set_x2(nearestUnbrokenHighLine, bar_index + 1)

    int ctfNewLowIdx = findNearestUnbrokenLow(lows)
    if ctfNewLowIdx != nearestUnbrokenLowIndex or (ctfNewLowIdx >= 0 and na(nearestUnbrokenLowLine))
        if not na(nearestUnbrokenLowLine)
            line.delete(nearestUnbrokenLowLine)
            nearestUnbrokenLowLine := na
        nearestUnbrokenLowIndex := ctfNewLowIdx
        if ctfNewLowIdx >= 0 and ctfNewLowIdx != mostRecentLowIndex
            ctfLowLevel = array.get(lows, ctfNewLowIdx)
            // Use bar_index instead of stored barIndex to avoid "too far" error
            nearestUnbrokenLowLine := line.new(bar_index, ctfLowLevel.price, bar_index + 1, ctfLowLevel.price, color=color.new(lowColor, 50), width=lineWidth, extend=extend.right, style=line.style_dashed)
    if not na(nearestUnbrokenLowLine)
        line.set_x2(nearestUnbrokenLowLine, bar_index + 1)

    bool bosBullish = false
    bool bosBearish = false

    // Check for Break of Structure
    if not na(currentValidHigh) and not na(currentValidLow) and close > currentValidHigh and lookingForLow
        bosBullish := true
        currentHighIsBroken := true
        lastBosDirection := "bullish"
        ctfBullishBOS := ctfBullishBOS + 1

        // First, find the new low that led to this BOS
        [newLow, newLowBar] = findLowestBetween(currentValidHighBar, bar_index)

        if not na(newLow) and not na(newLowBar)
            // NOTE: CTF zone creation is handled in checkBrokenLevels() to ensure
            // zones are created for ALL broken levels, not just the state machine's current level

            // Store previous low before updating
            previousValidLow := currentValidLow
            previousValidLowBar := currentValidLowBar

            currentValidLow := newLow
            currentValidLowBar := newLowBar
            lookingForHigh := true
            lookingForLow := false
            currentLowIsBroken := false

            addLow(newLow, newLowBar, "strong", lowColor)
            mostRecentLowIndex := array.size(lows) - 1

    if not bosBullish and not na(currentValidLow) and not na(currentValidHigh) and close < currentValidLow and lookingForHigh
        bosBearish := true
        currentLowIsBroken := true
        lastBosDirection := "bearish"
        ctfBearishBOS := ctfBearishBOS + 1

        // First, find the new high that led to this BOS
        [newHigh, newHighBar] = findHighestBetween(currentValidLowBar, bar_index)

        if not na(newHigh) and not na(newHighBar)
            // NOTE: CTF zone creation is handled in checkBrokenLevels() to ensure
            // zones are created for ALL broken levels, not just the state machine's current level

            // Store previous high before updating
            previousValidHigh := currentValidHigh
            previousValidHighBar := currentValidHighBar

            currentValidHigh := newHigh
            currentValidHighBar := newHighBar
            lookingForLow := true
            lookingForHigh := false
            currentHighIsBroken := false

            addHigh(newHigh, newHighBar, "strong", highColor)
            mostRecentHighIndex := array.size(highs) - 1

    // Look for new valid low via breakout
    if not bosBullish and not bosBearish and lookingForLow
        if isBullishBreakout()
            [newLow, newLowBar] = findLowestBetween(currentValidHighBar, bar_index)

            if not na(newLow) and not na(newLowBar)
                currentValidLow := newLow
                currentValidLowBar := newLowBar
                lookingForHigh := true
                lookingForLow := false
                currentLowIsBroken := false

                levelType = getLowLevelType(lastBosDirection)
                addLow(newLow, newLowBar, levelType, lowColor)
                mostRecentLowIndex := array.size(lows) - 1

    // Look for new valid high via breakdown
    if not bosBullish and not bosBearish and lookingForHigh
        if isBearishBreakdown()
            [newHigh, newHighBar] = findHighestBetween(currentValidLowBar, bar_index)

            if not na(newHigh) and not na(newHighBar)
                currentValidHigh := newHigh
                currentValidHighBar := newHighBar
                lookingForLow := true
                lookingForHigh := false
                currentHighIsBroken := false

                levelType = getHighLevelType(lastBosDirection)
                addHigh(newHigh, newHighBar, levelType, highColor)
                mostRecentHighIndex := array.size(highs) - 1

    // Track LTF BOS for alert conditions
    if bosBullish
        ltfBosBullishSinceLastHTF := true
        ltfBosFlag := true

        // Check if bullish BOS is below 50% of HTF range
        if not na(pullback50Level) and close < pullback50Level
            ltfBosAtExtremeFlag := true

    if bosBearish
        ltfBosBearishSinceLastHTF := true
        ltfBosFlag := true

        // Check if bearish BOS is above 50% of HTF range
        if not na(pullback50Level) and close > pullback50Level
            ltfBosAtExtremeFlag := true

// ============================================================================
// HTF DATA AND LOGIC
// ============================================================================

[htfHigh, htfLow, htfOpen, htfClose] = request.security(syminfo.tickerid, htfTimeframe, [high, low, open, close], lookahead=barmerge.lookahead_off)
htfTime = request.security(syminfo.tickerid, htfTimeframe, time, lookahead=barmerge.lookahead_off)
bool htfNewCandle = ta.change(htfTime) != 0

// HTF helper functions (defined here because they need HTF data)
htfIsBearishBreakdown() =>
    htfClose < htfOpen and htfClose < htfLow[1]

htfIsBullishBreakout() =>
    htfClose > htfOpen and htfClose > htfHigh[1]

// HTF Initialization
// IMPORTANT: We need to set BOTH htfCurrentValidHigh AND htfCurrentValidLow
// Otherwise BOS detection fails because it requires both to be non-NA
if htfEnabled and not htfInitialized and bar_index > 0 and htfNewCandle
    if htfIsBearishBreakdown()
        // Find the highest high in the lookback period for initial valid high
        float initHigh = high
        int initHighBar = bar_index
        for i = 1 to math.min(bar_index, 200)
            if high[i] > initHigh
                initHigh := high[i]
                initHighBar := bar_index - i

        htfCurrentValidHigh := initHigh
        htfCurrentValidHighBar := initHighBar

        // Also set an initial valid low to current bar
        // This allows BOS detection to work immediately
        htfCurrentValidLow := low
        htfCurrentValidLowBar := bar_index

        htfInitialized := true
        htfLookingForLow := true

        // Initialize swing tracking for the NEW HTF candle - start with current bar
        htfSwingLow := low
        htfSwingLowBar := bar_index

        addHighHTF(initHigh, initHighBar, "strong", htfHighColor)
        htfMostRecentHighIndex := array.size(htfHighs) - 1

        // Also add the initial low level
        addLowHTF(low, bar_index, "strong", htfLowColor)
        htfMostRecentLowIndex := array.size(htfLows) - 1

// HTF main logic (only on new HTF candles)
// IMPORTANT: This must run BEFORE swing tracking updates, so we use the
// swing values from the PREVIOUS HTF candle, not contaminated by current bar

// Save the "most recent" indices BEFORE main logic runs, so checkBrokenLevelsHTF can use them
var int htfMostRecentHighIndexForZones = -1
var int htfMostRecentLowIndexForZones = -1

if htfEnabled and htfInitialized and htfNewCandle
    // Capture the indices before any updates
    htfMostRecentHighIndexForZones := htfMostRecentHighIndex
    htfMostRecentLowIndexForZones := htfMostRecentLowIndex

    // Reset HTF BOS flags
    htfBosBullish := false
    htfBosBearish := false

    // Check HTF BOS - zones are created here for IMMEDIATE breaks only
    // Use findLowestBetween/findHighestBetween for accurate swing detection
    if not na(htfCurrentValidHigh) and not na(htfCurrentValidLow) and htfClose > htfCurrentValidHigh and htfLookingForLow
        htfBosBullish := true
        htfCurrentHighIsBroken := true
        htfLastBosDirection := "bullish"
        htfBullishBOS := htfBullishBOS + 1

        // Find the actual lowest low between the last valid high and now
        [foundLow, foundLowBar] = findLowestBetween(htfCurrentValidHighBar, bar_index)

        // Debug: mark that we entered bullish BOS
        if showDebugLabel
            label.new(bar_index, high, "B-BOS", style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.tiny)

        if not na(foundLow) and not na(foundLowBar)
            // Store previous low
            htfPreviousValidLow := htfCurrentValidLow
            htfPreviousValidLowBar := htfCurrentValidLowBar

            htfCurrentValidLow := foundLow
            htfCurrentValidLowBar := foundLowBar

            addLowHTF(foundLow, foundLowBar, "strong", htfLowColor)
            htfMostRecentLowIndex := array.size(htfLows) - 1

            // Create DEMAND zone at this HTF low (immediate BOS)
            [zoneTop, zoneBottom, zoneLeftTime] = calculateZoneFromLow(foundLowBar)

            // Debug: show zone calculation results
            if showDebugLabel
                label.new(bar_index, low, "D:" + str.tostring(not na(zoneTop)) + "/" + str.tostring(not na(zoneBottom)) + "/" + str.tostring(not na(zoneLeftTime)), style=label.style_label_up, color=color.green, textcolor=color.white, size=size.tiny)

            if not na(zoneTop) and not na(zoneBottom) and not na(zoneLeftTime)
                // Check for duplicate zone
                bool isDuplicate = false
                if array.size(demandZones) > 0
                    for j = array.size(demandZones) - 1 to math.max(0, array.size(demandZones) - 20)
                        existingZone = array.get(demandZones, j)
                        if existingZone.leftTime == zoneLeftTime and existingZone.top == zoneTop and existingZone.bottom == zoneBottom
                            isDuplicate := true
                            break
                if not isDuplicate
                    newZone = Zone.new(zoneTop, zoneBottom, zoneLeftTime, time, false, false, bar_index)
                    array.push(demandZones, newZone)
                    demandZonesCreated := demandZonesCreated + 1
                    if showDebugLabel
                        label.new(bar_index, low * 0.999, "D+", style=label.style_label_up, color=color.lime, textcolor=color.black, size=size.tiny)

        // CRITICAL: Always update direction flags after BOS
        htfLookingForHigh := true
        htfLookingForLow := false
        htfCurrentLowIsBroken := false
        // Reset swing tracking for the NEW HTF candle - start with current bar
        htfSwingHigh := high
        htfSwingHighBar := bar_index

    if not htfBosBullish and not na(htfCurrentValidLow) and not na(htfCurrentValidHigh) and htfClose < htfCurrentValidLow and htfLookingForHigh
        htfBosBearish := true
        htfCurrentLowIsBroken := true
        htfLastBosDirection := "bearish"
        htfBearishBOS := htfBearishBOS + 1

        // Find the actual highest high between the last valid low and now
        [foundHigh, foundHighBar] = findHighestBetween(htfCurrentValidLowBar, bar_index)

        // Debug: mark that we entered bearish BOS
        if showDebugLabel
            label.new(bar_index, low, "S-BOS", style=label.style_label_up, color=color.orange, textcolor=color.white, size=size.tiny)

        if not na(foundHigh) and not na(foundHighBar)
            // Store previous high
            htfPreviousValidHigh := htfCurrentValidHigh
            htfPreviousValidHighBar := htfCurrentValidHighBar

            htfCurrentValidHigh := foundHigh
            htfCurrentValidHighBar := foundHighBar

            addHighHTF(foundHigh, foundHighBar, "strong", htfHighColor)
            htfMostRecentHighIndex := array.size(htfHighs) - 1

            // Create SUPPLY zone at this HTF high (immediate BOS)
            [zoneTop, zoneBottom, zoneLeftTime] = calculateZoneFromHigh(foundHighBar)

            // Debug: show zone calculation results
            if showDebugLabel
                label.new(bar_index, high, "S:" + str.tostring(not na(zoneTop)) + "/" + str.tostring(not na(zoneBottom)) + "/" + str.tostring(not na(zoneLeftTime)), style=label.style_label_down, color=color.red, textcolor=color.white, size=size.tiny)

            if not na(zoneTop) and not na(zoneBottom) and not na(zoneLeftTime)
                // Check for duplicate zone
                bool isDuplicate = false
                if array.size(supplyZones) > 0
                    for j = array.size(supplyZones) - 1 to math.max(0, array.size(supplyZones) - 20)
                        existingZone = array.get(supplyZones, j)
                        if existingZone.leftTime == zoneLeftTime and existingZone.top == zoneTop and existingZone.bottom == zoneBottom
                            isDuplicate := true
                            break
                if not isDuplicate
                    newZone = Zone.new(zoneTop, zoneBottom, zoneLeftTime, time, false, false, bar_index)
                    array.push(supplyZones, newZone)
                    supplyZonesCreated := supplyZonesCreated + 1
                    if showDebugLabel
                        label.new(bar_index, high * 1.001, "S+", style=label.style_label_down, color=color.maroon, textcolor=color.white, size=size.tiny)

        // CRITICAL: Always update direction flags after BOS
        htfLookingForLow := true
        htfLookingForHigh := false
        htfCurrentHighIsBroken := false
        // Reset swing tracking for the NEW HTF candle - start with current bar
        htfSwingLow := low
        htfSwingLowBar := bar_index

    // HTF breakout/breakdown
    // Use findLowestBetween/findHighestBetween like CTF does for accuracy
    if not htfBosBullish and not htfBosBearish and htfLookingForLow
        if htfIsBullishBreakout()
            // Find the actual lowest low between the last valid high and now
            [foundLow, foundLowBar] = findLowestBetween(htfCurrentValidHighBar, bar_index)
            if not na(foundLow) and not na(foundLowBar)
                htfCurrentValidLow := foundLow
                htfCurrentValidLowBar := foundLowBar
                htfLookingForHigh := true
                htfLookingForLow := false
                htfCurrentLowIsBroken := false

                levelType = getLowLevelType(htfLastBosDirection)
                addLowHTF(foundLow, foundLowBar, levelType, htfLowColor)
                htfMostRecentLowIndex := array.size(htfLows) - 1

                // Reset swing tracking for the NEW HTF candle - start with current bar
                htfSwingHigh := high
                htfSwingHighBar := bar_index

    if not htfBosBullish and not htfBosBearish and htfLookingForHigh
        if htfIsBearishBreakdown()
            // Find the actual highest high between the last valid low and now
            [foundHigh, foundHighBar] = findHighestBetween(htfCurrentValidLowBar, bar_index)
            if not na(foundHigh) and not na(foundHighBar)
                htfCurrentValidHigh := foundHigh
                htfCurrentValidHighBar := foundHighBar
                htfLookingForLow := true
                htfLookingForHigh := false
                htfCurrentHighIsBroken := false

                levelType = getHighLevelType(htfLastBosDirection)
                addHighHTF(foundHigh, foundHighBar, levelType, htfHighColor)
                htfMostRecentHighIndex := array.size(htfHighs) - 1

                // Reset swing tracking for the NEW HTF candle - start with current bar
                htfSwingLow := low
                htfSwingLowBar := bar_index

// Check HTF broken/swept levels - ONLY on new HTF candles
// This now also creates zones for every broken level
if htfEnabled and htfInitialized and htfNewCandle
    [bullLabels, bearLabels, demandFromLabels, supplyFromLabels, htfBullBos, htfBearBos] = checkBrokenLevelsHTF(htfHigh, htfLow, htfClose, htfMostRecentHighIndexForZones, htfMostRecentLowIndexForZones)
    htfBullishLabels := htfBullishLabels + bullLabels
    htfBearishLabels := htfBearishLabels + bearLabels
    demandZonesCreated := demandZonesCreated + demandFromLabels
    supplyZonesCreated := supplyZonesCreated + supplyFromLabels
    // Set HTF BOS alert flags
    if htfBullBos
        htfBullishBosFlag := true
    if htfBearBos
        htfBearishBosFlag := true

// HTF swing tracking - track actual LTF bars where HTF extremes occur
// IMPORTANT: This runs AFTER the htfNewCandle logic so the swing values
// from the previous HTF candle are used before being updated
if htfEnabled and htfInitialized
    if htfLookingForLow
        if na(htfSwingLow) or low < htfSwingLow
            htfSwingLow := low
            htfSwingLowBar := bar_index

    if htfLookingForHigh
        if na(htfSwingHigh) or high > htfSwingHigh
            htfSwingHigh := high
            htfSwingHighBar := bar_index

    // Update nearest unbroken levels (structure boundaries) - HTF
    int htfNewHighIdx = findNearestUnbrokenHigh(htfHighs)
    if htfNewHighIdx != htfNearestUnbrokenHighIndex or (htfNewHighIdx >= 0 and na(htfNearestUnbrokenHighLine))
        if not na(htfNearestUnbrokenHighLine)
            line.delete(htfNearestUnbrokenHighLine)
            htfNearestUnbrokenHighLine := na
        htfNearestUnbrokenHighIndex := htfNewHighIdx
        if htfNewHighIdx >= 0 and htfNewHighIdx != htfMostRecentHighIndex
            htfHighLevel = array.get(htfHighs, htfNewHighIdx)
            // Use bar_index instead of stored barIndex to avoid "too far" error
            htfNearestUnbrokenHighLine := line.new(bar_index, htfHighLevel.price, bar_index + 1, htfHighLevel.price, color=color.new(htfHighColor, 50), width=lineWidth + 1, extend=extend.right, style=line.style_dashed)
    if not na(htfNearestUnbrokenHighLine)
        line.set_x2(htfNearestUnbrokenHighLine, bar_index + 1)

    int htfNewLowIdx = findNearestUnbrokenLow(htfLows)
    if htfNewLowIdx != htfNearestUnbrokenLowIndex or (htfNewLowIdx >= 0 and na(htfNearestUnbrokenLowLine))
        if not na(htfNearestUnbrokenLowLine)
            line.delete(htfNearestUnbrokenLowLine)
            htfNearestUnbrokenLowLine := na
        htfNearestUnbrokenLowIndex := htfNewLowIdx
        if htfNewLowIdx >= 0 and htfNewLowIdx != htfMostRecentLowIndex
            htfLowLevel = array.get(htfLows, htfNewLowIdx)
            // Use bar_index instead of stored barIndex to avoid "too far" error
            htfNearestUnbrokenLowLine := line.new(bar_index, htfLowLevel.price, bar_index + 1, htfLowLevel.price, color=color.new(htfLowColor, 50), width=lineWidth + 1, extend=extend.right, style=line.style_dashed)
    if not na(htfNearestUnbrokenLowLine)
        line.set_x2(htfNearestUnbrokenLowLine, bar_index + 1)

// ============================================================================
// HTF2 (TRADING RANGE) DATA AND LOGIC
// ============================================================================

[htf2High, htf2Low, htf2Open, htf2Close] = request.security(syminfo.tickerid, htf2Timeframe, [high, low, open, close], lookahead=barmerge.lookahead_off)
htf2Time = request.security(syminfo.tickerid, htf2Timeframe, time, lookahead=barmerge.lookahead_off)
bool htf2NewCandle = ta.change(htf2Time) != 0

// HTF2 helper functions
htf2IsBearishBreakdown() =>
    htf2Close < htf2Open and htf2Close < htf2Low[1]

htf2IsBullishBreakout() =>
    htf2Close > htf2Open and htf2Close > htf2High[1]

// HTF2 Initialization - simplified to initialize on first HTF2 candle with enough history
if htf2Enabled and not htf2Initialized and bar_index > 200
    // Find the highest high in the lookback period for initial valid high
    float initHigh = high
    int initHighBar = bar_index
    for i = 1 to 200
        if high[i] > initHigh
            initHigh := high[i]
            initHighBar := bar_index - i

    // Find the lowest low in the lookback period for initial valid low
    float initLow = low
    int initLowBar = bar_index
    for i = 1 to 200
        if low[i] < initLow
            initLow := low[i]
            initLowBar := bar_index - i

    htf2CurrentValidHigh := initHigh
    htf2CurrentValidHighBar := initHighBar
    htf2CurrentValidLow := initLow
    htf2CurrentValidLowBar := initLowBar

    htf2Initialized := true
    htf2LookingForLow := true

    // Initialize swing tracking
    htf2SwingLow := initLow
    htf2SwingLowBar := initLowBar
    htf2SwingHigh := initHigh
    htf2SwingHighBar := initHighBar

    addHighHTF2(initHigh, initHighBar, "strong")
    htf2MostRecentHighIndex := array.size(htf2Highs) - 1

    addLowHTF2(initLow, initLowBar, "strong")
    htf2MostRecentLowIndex := array.size(htf2Lows) - 1

// HTF2 main logic (only on new HTF2 candles)
if htf2Enabled and htf2Initialized and htf2NewCandle
    // Check HTF2 BOS
    if not na(htf2CurrentValidHigh) and not na(htf2CurrentValidLow) and htf2Close > htf2CurrentValidHigh and htf2LookingForLow
        htf2CurrentHighIsBroken := true
        htf2LastBosDirection := "bullish"

        // Find the actual lowest low between the last valid high and now
        [foundLow, foundLowBar] = findLowestBetween(htf2CurrentValidHighBar, bar_index)

        if not na(foundLow) and not na(foundLowBar)
            htf2PreviousValidLow := htf2CurrentValidLow
            htf2PreviousValidLowBar := htf2CurrentValidLowBar

            htf2CurrentValidLow := foundLow
            htf2CurrentValidLowBar := foundLowBar

            addLowHTF2(foundLow, foundLowBar, "strong")
            htf2MostRecentLowIndex := array.size(htf2Lows) - 1

        htf2LookingForHigh := true
        htf2LookingForLow := false
        htf2CurrentLowIsBroken := false
        htf2SwingHigh := high
        htf2SwingHighBar := bar_index

    if not na(htf2CurrentValidLow) and not na(htf2CurrentValidHigh) and htf2Close < htf2CurrentValidLow and htf2LookingForHigh
        htf2CurrentLowIsBroken := true
        htf2LastBosDirection := "bearish"

        // Find the actual highest high between the last valid low and now
        [foundHigh, foundHighBar] = findHighestBetween(htf2CurrentValidLowBar, bar_index)

        if not na(foundHigh) and not na(foundHighBar)
            htf2PreviousValidHigh := htf2CurrentValidHigh
            htf2PreviousValidHighBar := htf2CurrentValidHighBar

            htf2CurrentValidHigh := foundHigh
            htf2CurrentValidHighBar := foundHighBar

            addHighHTF2(foundHigh, foundHighBar, "strong")
            htf2MostRecentHighIndex := array.size(htf2Highs) - 1

        htf2LookingForLow := true
        htf2LookingForHigh := false
        htf2CurrentHighIsBroken := false
        htf2SwingLow := low
        htf2SwingLowBar := bar_index

    // HTF2 breakout/breakdown (no BOS)
    if htf2LookingForLow
        if htf2IsBullishBreakout()
            [foundLow, foundLowBar] = findLowestBetween(htf2CurrentValidHighBar, bar_index)
            if not na(foundLow) and not na(foundLowBar)
                htf2CurrentValidLow := foundLow
                htf2CurrentValidLowBar := foundLowBar
                htf2LookingForHigh := true
                htf2LookingForLow := false
                htf2CurrentLowIsBroken := false

                levelType = getLowLevelType(htf2LastBosDirection)
                addLowHTF2(foundLow, foundLowBar, levelType)
                htf2MostRecentLowIndex := array.size(htf2Lows) - 1

                htf2SwingHigh := high
                htf2SwingHighBar := bar_index

    if htf2LookingForHigh
        if htf2IsBearishBreakdown()
            [foundHigh, foundHighBar] = findHighestBetween(htf2CurrentValidLowBar, bar_index)
            if not na(foundHigh) and not na(foundHighBar)
                htf2CurrentValidHigh := foundHigh
                htf2CurrentValidHighBar := foundHighBar
                htf2LookingForLow := true
                htf2LookingForHigh := false
                htf2CurrentHighIsBroken := false

                levelType = getHighLevelType(htf2LastBosDirection)
                addHighHTF2(foundHigh, foundHighBar, levelType)
                htf2MostRecentHighIndex := array.size(htf2Highs) - 1

                htf2SwingLow := low
                htf2SwingLowBar := bar_index

// Check HTF2 broken/swept levels - ONLY on new HTF2 candles
if htf2Enabled and htf2Initialized and htf2NewCandle
    [htf2DemandCreated, htf2SupplyCreated, htf2BullBos, htf2BearBos] = checkBrokenLevelsHTF2(htf2High, htf2Low, htf2Close, htf2MostRecentHighIndex, htf2MostRecentLowIndex)
    // Set HTF2 BOS alert flags
    if htf2BullBos
        htf2BullishBosFlag := true
    if htf2BearBos
        htf2BearishBosFlag := true

// HTF2 swing tracking
if htf2Enabled and htf2Initialized
    if htf2LookingForLow
        if na(htf2SwingLow) or low < htf2SwingLow
            htf2SwingLow := low
            htf2SwingLowBar := bar_index

    if htf2LookingForHigh
        if na(htf2SwingHigh) or high > htf2SwingHigh
            htf2SwingHigh := high
            htf2SwingHighBar := bar_index

    // Update nearest unbroken levels (structure boundaries) - HTF2
    int htf2NewHighIdx = findNearestUnbrokenHigh(htf2Highs)
    if htf2NewHighIdx != htf2NearestUnbrokenHighIndex or (htf2NewHighIdx >= 0 and na(htf2NearestUnbrokenHighLine))
        if not na(htf2NearestUnbrokenHighLine)
            line.delete(htf2NearestUnbrokenHighLine)
            htf2NearestUnbrokenHighLine := na
        htf2NearestUnbrokenHighIndex := htf2NewHighIdx
        if htf2NewHighIdx >= 0 and htf2NewHighIdx != htf2MostRecentHighIndex
            htf2HighLevel = array.get(htf2Highs, htf2NewHighIdx)
            // Use bar_index instead of stored barIndex to avoid "too far" error
            htf2NearestUnbrokenHighLine := line.new(bar_index, htf2HighLevel.price, bar_index + 1, htf2HighLevel.price, color=color.new(htf2HighColor, 50), width=lineWidth + 2, extend=extend.right, style=line.style_dashed)
    if not na(htf2NearestUnbrokenHighLine)
        line.set_x2(htf2NearestUnbrokenHighLine, bar_index + 1)

    int htf2NewLowIdx = findNearestUnbrokenLow(htf2Lows)
    if htf2NewLowIdx != htf2NearestUnbrokenLowIndex or (htf2NewLowIdx >= 0 and na(htf2NearestUnbrokenLowLine))
        if not na(htf2NearestUnbrokenLowLine)
            line.delete(htf2NearestUnbrokenLowLine)
            htf2NearestUnbrokenLowLine := na
        htf2NearestUnbrokenLowIndex := htf2NewLowIdx
        if htf2NewLowIdx >= 0 and htf2NewLowIdx != htf2MostRecentLowIndex
            htf2LowLevel = array.get(htf2Lows, htf2NewLowIdx)
            // Use bar_index instead of stored barIndex to avoid "too far" error
            htf2NearestUnbrokenLowLine := line.new(bar_index, htf2LowLevel.price, bar_index + 1, htf2LowLevel.price, color=color.new(htf2LowColor, 50), width=lineWidth + 2, extend=extend.right, style=line.style_dashed)
    if not na(htf2NearestUnbrokenLowLine)
        line.set_x2(htf2NearestUnbrokenLowLine, bar_index + 1)

// ============================================================================
// ALERT CONDITION CHECKING
// ============================================================================

// Detect LTF level sweeps
if initialized
    bool ltfHighJustSwept = false
    bool ltfLowJustSwept = false

    if mostRecentHighIndex >= 0
        highLevel = array.get(highs, mostRecentHighIndex)
        if highLevel.levelType == "swept" and ltfMostRecentHighPrevType != "swept"
            ltfHighJustSwept := true
            ltfSweptFlag := true
        ltfMostRecentHighPrevType := highLevel.levelType

    if mostRecentLowIndex >= 0
        lowLevel = array.get(lows, mostRecentLowIndex)
        if lowLevel.levelType == "swept" and ltfMostRecentLowPrevType != "swept"
            ltfLowJustSwept := true
            ltfSweptFlag := true
        ltfMostRecentLowPrevType := lowLevel.levelType

// HTF alert conditions (set at HTF candle close)
if htfEnabled and htfInitialized
    // Detect if HTF levels just became swept this bar
    bool htfHighJustSwept = false
    bool htfLowJustSwept = false

    if htfMostRecentHighIndex >= 0
        highLevel = array.get(htfHighs, htfMostRecentHighIndex)
        if highLevel.levelType == "swept" and htfMostRecentHighPrevType != "swept"
            htfHighJustSwept := true
        htfMostRecentHighPrevType := highLevel.levelType

    if htfMostRecentLowIndex >= 0
        lowLevel = array.get(htfLows, htfMostRecentLowIndex)
        if lowLevel.levelType == "swept" and htfMostRecentLowPrevType != "swept"
            htfLowJustSwept := true
        htfMostRecentLowPrevType := lowLevel.levelType

    // Always update 50% and 25% levels based on current HTF range
    if not na(htfCurrentValidHigh) and not na(htfCurrentValidLow)
        pullback50Level := (htfCurrentValidHigh + htfCurrentValidLow) / 2
        pullback25Level := htfCurrentValidLow + (htfCurrentValidHigh - htfCurrentValidLow) * 0.25

    // Check HTF alert conditions at HTF candle close
    if htfNewCandle
        // Store whether HTF BOS occurred
        bool htfBosOccurred = htfBosBullish or htfBosBearish

        // HTF Condition 1: HTF BOS
        if htfBosOccurred
            htfBosFlag := true

            // HTF Condition 2: HTF BOS + LTF BOS same direction
            if (htfBosBullish and ltfBosBullishSinceLastHTF) or (htfBosBearish and ltfBosBearishSinceLastHTF)
                htfBosLtfBosFlag := true

        // HTF Condition 3: HTF Swept
        if htfHighJustSwept or htfLowJustSwept
            htfSweptFlag := true

            // HTF Condition 4: HTF Swept + LTF BOS in reversal direction
            if (htfHighJustSwept and ltfBosBearishSinceLastHTF) or (htfLowJustSwept and ltfBosBullishSinceLastHTF)
                htfSweptLtfBosFlag := true

        // Reset LTF BOS tracking flags for next HTF candle
        ltfBosBullishSinceLastHTF := false
        ltfBosBearishSinceLastHTF := false

// Check for 50% pullback
if not na(pullback50Level)
    float tolerance = pullback50Level * 0.001
    if (high >= pullback50Level and low <= pullback50Level) or
       (close >= pullback50Level - tolerance and close <= pullback50Level + tolerance)
        pullback50Flag := true

// Check for 25% pullback
if not na(pullback25Level)
    float tolerance = pullback25Level * 0.001
    if (high >= pullback25Level and low <= pullback25Level) or
       (close >= pullback25Level - tolerance and close <= pullback25Level + tolerance)
        pullback25Flag := true

// ============================================================================
// UPDATE LEVEL STATES (Ensure consistency on every bar)
// ============================================================================

// Update current timeframe level states
if initialized
    // Find most recent BOS in highs array
    int brokenHighIdx = -1
    if array.size(highs) > 0
        for i = array.size(highs) - 1 to 0
            highLevel = array.get(highs, i)
            if highLevel.levelType == "broken"
                brokenHighIdx := i
                break

    // Find most recent BOS in lows array
    int brokenLowIdx = -1
    if array.size(lows) > 0
        for i = array.size(lows) - 1 to 0
            lowLevel = array.get(lows, i)
            if lowLevel.levelType == "broken"
                brokenLowIdx := i
                break

    // Determine which BOS is most recent and update states accordingly
    if brokenHighIdx >= 0 or brokenLowIdx >= 0
        if brokenHighIdx >= 0 and (brokenLowIdx < 0 or brokenHighIdx > brokenLowIdx)
            lastBosDirection := "bullish"

            if mostRecentHighIndex >= 0
                currentHigh = array.get(highs, mostRecentHighIndex)
                if currentHigh.levelType != "broken" and currentHigh.levelType != "swept"
                    currentHigh.levelType := "weak"

            if mostRecentLowIndex >= 0
                currentLow = array.get(lows, mostRecentLowIndex)
                if currentLow.levelType != "broken" and currentLow.levelType != "swept"
                    currentLow.levelType := "strong"

        else if brokenLowIdx >= 0
            lastBosDirection := "bearish"

            if mostRecentLowIndex >= 0
                currentLow = array.get(lows, mostRecentLowIndex)
                if currentLow.levelType != "broken" and currentLow.levelType != "swept"
                    currentLow.levelType := "weak"

            if mostRecentHighIndex >= 0
                currentHigh = array.get(highs, mostRecentHighIndex)
                if currentHigh.levelType != "broken" and currentHigh.levelType != "swept"
                    currentHigh.levelType := "strong"

// Update HTF level states
if htfEnabled and htfInitialized
    int htfBrokenHighIdx = -1
    if array.size(htfHighs) > 0
        for i = array.size(htfHighs) - 1 to 0
            highLevel = array.get(htfHighs, i)
            if highLevel.levelType == "broken"
                htfBrokenHighIdx := i
                break

    int htfBrokenLowIdx = -1
    if array.size(htfLows) > 0
        for i = array.size(htfLows) - 1 to 0
            lowLevel = array.get(htfLows, i)
            if lowLevel.levelType == "broken"
                htfBrokenLowIdx := i
                break

    if htfBrokenHighIdx >= 0 or htfBrokenLowIdx >= 0
        if htfBrokenHighIdx >= 0 and (htfBrokenLowIdx < 0 or htfBrokenHighIdx > htfBrokenLowIdx)
            htfLastBosDirection := "bullish"

            if htfMostRecentHighIndex >= 0
                currentHigh = array.get(htfHighs, htfMostRecentHighIndex)
                if currentHigh.levelType != "broken" and currentHigh.levelType != "swept"
                    currentHigh.levelType := "weak"

            if htfMostRecentLowIndex >= 0
                currentLow = array.get(htfLows, htfMostRecentLowIndex)
                if currentLow.levelType != "broken" and currentLow.levelType != "swept"
                    currentLow.levelType := "strong"

        else if htfBrokenLowIdx >= 0
            htfLastBosDirection := "bearish"

            if htfMostRecentLowIndex >= 0
                currentLow = array.get(htfLows, htfMostRecentLowIndex)
                if currentLow.levelType != "broken" and currentLow.levelType != "swept"
                    currentLow.levelType := "weak"

            if htfMostRecentHighIndex >= 0
                currentHigh = array.get(htfHighs, htfMostRecentHighIndex)
                if currentHigh.levelType != "broken" and currentHigh.levelType != "swept"
                    currentHigh.levelType := "strong"

// Update HTF2 (Trading Range) level states
if htf2Enabled and htf2Initialized
    int htf2BrokenHighIdx = -1
    if array.size(htf2Highs) > 0
        for i = array.size(htf2Highs) - 1 to 0
            highLevel = array.get(htf2Highs, i)
            if highLevel.levelType == "broken"
                htf2BrokenHighIdx := i
                break

    int htf2BrokenLowIdx = -1
    if array.size(htf2Lows) > 0
        for i = array.size(htf2Lows) - 1 to 0
            lowLevel = array.get(htf2Lows, i)
            if lowLevel.levelType == "broken"
                htf2BrokenLowIdx := i
                break

    if htf2BrokenHighIdx >= 0 or htf2BrokenLowIdx >= 0
        if htf2BrokenHighIdx >= 0 and (htf2BrokenLowIdx < 0 or htf2BrokenHighIdx > htf2BrokenLowIdx)
            htf2LastBosDirection := "bullish"

            if htf2MostRecentHighIndex >= 0
                currentHigh = array.get(htf2Highs, htf2MostRecentHighIndex)
                if currentHigh.levelType != "broken" and currentHigh.levelType != "swept"
                    currentHigh.levelType := "weak"

            if htf2MostRecentLowIndex >= 0
                currentLow = array.get(htf2Lows, htf2MostRecentLowIndex)
                if currentLow.levelType != "broken" and currentLow.levelType != "swept"
                    currentLow.levelType := "strong"

        else if htf2BrokenLowIdx >= 0
            htf2LastBosDirection := "bearish"

            if htf2MostRecentLowIndex >= 0
                currentLow = array.get(htf2Lows, htf2MostRecentLowIndex)
                if currentLow.levelType != "broken" and currentLow.levelType != "swept"
                    currentLow.levelType := "weak"

            if htf2MostRecentHighIndex >= 0
                currentHigh = array.get(htf2Highs, htf2MostRecentHighIndex)
                if currentHigh.levelType != "broken" and currentHigh.levelType != "swept"
                    currentHigh.levelType := "strong"

// ============================================================================
// ARRAY TRUNCATION (Performance)
// ============================================================================

// CTF Highs truncation
if array.size(highs) > 30
    oldHigh = array.get(highs, 0)
    if not na(oldHigh.levelLine)
        line.delete(oldHigh.levelLine)
    array.shift(highs)
    mostRecentHighIndex := math.max(-1, mostRecentHighIndex - 1)
    nearestUnbrokenHighIndex := math.max(-1, nearestUnbrokenHighIndex - 1)
    if nearestUnbrokenHighIndex < 0 and not na(nearestUnbrokenHighLine)
        line.delete(nearestUnbrokenHighLine)
        nearestUnbrokenHighLine := na

// CTF Lows truncation
if array.size(lows) > 30
    oldLow = array.get(lows, 0)
    if not na(oldLow.levelLine)
        line.delete(oldLow.levelLine)
    array.shift(lows)
    mostRecentLowIndex := math.max(-1, mostRecentLowIndex - 1)
    nearestUnbrokenLowIndex := math.max(-1, nearestUnbrokenLowIndex - 1)
    if nearestUnbrokenLowIndex < 0 and not na(nearestUnbrokenLowLine)
        line.delete(nearestUnbrokenLowLine)
        nearestUnbrokenLowLine := na

// HTF Highs truncation
if array.size(htfHighs) > 30
    oldHigh = array.get(htfHighs, 0)
    if not na(oldHigh.levelLine)
        line.delete(oldHigh.levelLine)
    array.shift(htfHighs)
    htfMostRecentHighIndex := math.max(-1, htfMostRecentHighIndex - 1)
    htfNearestUnbrokenHighIndex := math.max(-1, htfNearestUnbrokenHighIndex - 1)
    if htfNearestUnbrokenHighIndex < 0 and not na(htfNearestUnbrokenHighLine)
        line.delete(htfNearestUnbrokenHighLine)
        htfNearestUnbrokenHighLine := na

// HTF Lows truncation
if array.size(htfLows) > 30
    oldLow = array.get(htfLows, 0)
    if not na(oldLow.levelLine)
        line.delete(oldLow.levelLine)
    array.shift(htfLows)
    htfMostRecentLowIndex := math.max(-1, htfMostRecentLowIndex - 1)
    htfNearestUnbrokenLowIndex := math.max(-1, htfNearestUnbrokenLowIndex - 1)
    if htfNearestUnbrokenLowIndex < 0 and not na(htfNearestUnbrokenLowLine)
        line.delete(htfNearestUnbrokenLowLine)
        htfNearestUnbrokenLowLine := na

// HTF2 Highs truncation
if array.size(htf2Highs) > 30
    oldHigh = array.get(htf2Highs, 0)
    if not na(oldHigh.levelLine)
        line.delete(oldHigh.levelLine)
    array.shift(htf2Highs)
    htf2MostRecentHighIndex := math.max(-1, htf2MostRecentHighIndex - 1)
    htf2NearestUnbrokenHighIndex := math.max(-1, htf2NearestUnbrokenHighIndex - 1)
    if htf2NearestUnbrokenHighIndex < 0 and not na(htf2NearestUnbrokenHighLine)
        line.delete(htf2NearestUnbrokenHighLine)
        htf2NearestUnbrokenHighLine := na

// HTF2 Lows truncation
if array.size(htf2Lows) > 30
    oldLow = array.get(htf2Lows, 0)
    if not na(oldLow.levelLine)
        line.delete(oldLow.levelLine)
    array.shift(htf2Lows)
    htf2MostRecentLowIndex := math.max(-1, htf2MostRecentLowIndex - 1)
    htf2NearestUnbrokenLowIndex := math.max(-1, htf2NearestUnbrokenLowIndex - 1)
    if htf2NearestUnbrokenLowIndex < 0 and not na(htf2NearestUnbrokenLowLine)
        line.delete(htf2NearestUnbrokenLowLine)
        htf2NearestUnbrokenLowLine := na

// Remove old broken zones to keep arrays clean
// NOTE: Disabled automatic removal - let size limit handle cleanup
// if array.size(demandZones) > 0
//     for i = array.size(demandZones) - 1 to 0
//         zone = array.get(demandZones, i)
//         if zone.broken and (time - zone.rightTime) > (100 * (time - time[1]))
//             array.remove(demandZones, i)

// if array.size(supplyZones) > 0
//     for i = array.size(supplyZones) - 1 to 0
//         zone = array.get(supplyZones, i)
//         if zone.broken and (time - zone.rightTime) > (100 * (time - time[1]))
//             array.remove(supplyZones, i)

// if array.size(htfDemandZones) > 0
//     for i = array.size(htfDemandZones) - 1 to 0
//         zone = array.get(htfDemandZones, i)
//         if zone.broken and (time - zone.rightTime) > (100 * (time - time[1]))
//             array.remove(htfDemandZones, i)

// if array.size(htfSupplyZones) > 0
//     for i = array.size(htfSupplyZones) - 1 to 0
//         zone = array.get(htfSupplyZones, i)
//         if zone.broken and (time - zone.rightTime) > (100 * (time - time[1]))
//             array.remove(htfSupplyZones, i)

// Zone array size limiting is now handled at insertion time in addDemandZone/addSupplyZone

// ============================================================================
// PLOTS AND LABELS
// ============================================================================

plot(currentValidHigh, "Current Valid High", color=color.new(highColor, 80), linewidth=1, style=plot.style_stepline)
plot(currentValidLow, "Current Valid Low", color=color.new(lowColor, 80), linewidth=1, style=plot.style_stepline)
plot(htfEnabled ? htfCurrentValidHigh : na, "HTF Valid High", color=color.new(htfHighColor, 80), linewidth=1, style=plot.style_stepline)
plot(htfEnabled ? htfCurrentValidLow : na, "HTF Valid Low", color=color.new(htfLowColor, 80), linewidth=1, style=plot.style_stepline)

// Update labels for current levels
if initialized and not na(currentValidHigh) and mostRecentHighIndex >= 0
    if not na(currentHighLabel)
        label.delete(currentHighLabel)

    highLevel = array.get(highs, mostRecentHighIndex)
    string labelText = na
    color labelColor = highColor

    if highLevel.levelType == "broken"
        labelText := timeframe.period + " Broken High"
        labelColor := color.new(color.red, 0)
    else if highLevel.levelType == "weak"
        labelText := timeframe.period + " Weak High"
    else if highLevel.levelType == "swept"
        labelText := timeframe.period + " Swept High"
    else
        labelText := timeframe.period + " Strong High"

    currentHighLabel := label.new(bar_index + 5, currentValidHigh,
                                   text=labelText,
                                   style=label.style_label_left,
                                   color=labelColor,
                                   textcolor=color.white,
                                   size=size.small)

if initialized and not na(currentValidLow) and mostRecentLowIndex >= 0
    if not na(currentLowLabel)
        label.delete(currentLowLabel)

    lowLevel = array.get(lows, mostRecentLowIndex)
    string labelText = na
    color labelColor = lowColor

    if lowLevel.levelType == "broken"
        labelText := timeframe.period + " Broken Low"
        labelColor := color.new(color.green, 0)
    else if lowLevel.levelType == "weak"
        labelText := timeframe.period + " Weak Low"
    else if lowLevel.levelType == "swept"
        labelText := timeframe.period + " Swept Low"
    else
        labelText := timeframe.period + " Strong Low"

    currentLowLabel := label.new(bar_index + 5, currentValidLow,
                                  text=labelText,
                                  style=label.style_label_left,
                                  color=labelColor,
                                  textcolor=color.white,
                                  size=size.small)

// HTF labels
if htfEnabled and htfInitialized and not na(htfCurrentValidHigh) and htfMostRecentHighIndex >= 0
    if not na(htfCurrentHighLabel)
        label.delete(htfCurrentHighLabel)

    highLevel = array.get(htfHighs, htfMostRecentHighIndex)
    string labelText = na
    color labelColor = htfHighColor

    if highLevel.levelType == "broken"
        labelText := htfTimeframe + " Broken High"
        labelColor := color.new(color.orange, 0)
    else if highLevel.levelType == "weak"
        labelText := htfTimeframe + " Weak High"
    else if highLevel.levelType == "swept"
        labelText := htfTimeframe + " Swept High"
    else
        labelText := htfTimeframe + " Strong High"

    htfCurrentHighLabel := label.new(bar_index + 20, htfCurrentValidHigh,
                                      text=labelText,
                                      style=label.style_label_left,
                                      color=labelColor,
                                      textcolor=color.white,
                                      size=size.small)

if htfEnabled and htfInitialized and not na(htfCurrentValidLow) and htfMostRecentLowIndex >= 0
    if not na(htfCurrentLowLabel)
        label.delete(htfCurrentLowLabel)

    lowLevel = array.get(htfLows, htfMostRecentLowIndex)
    string labelText = na
    color labelColor = htfLowColor

    if lowLevel.levelType == "broken"
        labelText := htfTimeframe + " Broken Low"
        labelColor := color.new(color.blue, 0)
    else if lowLevel.levelType == "weak"
        labelText := htfTimeframe + " Weak Low"
    else if lowLevel.levelType == "swept"
        labelText := htfTimeframe + " Swept Low"
    else
        labelText := htfTimeframe + " Strong Low"

    htfCurrentLowLabel := label.new(bar_index + 20, htfCurrentValidLow,
                                     text=labelText,
                                     style=label.style_label_left,
                                     color=labelColor,
                                     textcolor=color.white,
                                     size=size.small)

// HTF2 (Trading Range) labels - black with white text
if htf2Enabled and htf2Initialized and not na(htf2CurrentValidHigh) and htf2MostRecentHighIndex >= 0 and htf2MostRecentHighIndex < array.size(htf2Highs)
    // Delete old label
    label.delete(htf2CurrentHighLabel)

    highLevel = array.get(htf2Highs, htf2MostRecentHighIndex)
    string labelText = na

    if highLevel.levelType == "broken"
        labelText := htf2Timeframe + " Broken High"
    else if highLevel.levelType == "weak"
        labelText := htf2Timeframe + " Weak High"
    else if highLevel.levelType == "swept"
        labelText := htf2Timeframe + " Swept High"
    else
        labelText := htf2Timeframe + " Strong High"

    htf2CurrentHighLabel := label.new(bar_index + 5, htf2CurrentValidHigh,
                                      text=labelText,
                                      style=label.style_label_down,
                                      color=color.black,
                                      textcolor=color.white,
                                      size=size.normal)

if htf2Enabled and htf2Initialized and not na(htf2CurrentValidLow) and htf2MostRecentLowIndex >= 0 and htf2MostRecentLowIndex < array.size(htf2Lows)
    // Delete old label
    label.delete(htf2CurrentLowLabel)

    lowLevel = array.get(htf2Lows, htf2MostRecentLowIndex)
    string labelText = na

    if lowLevel.levelType == "broken"
        labelText := htf2Timeframe + " Broken Low"
    else if lowLevel.levelType == "weak"
        labelText := htf2Timeframe + " Weak Low"
    else if lowLevel.levelType == "swept"
        labelText := htf2Timeframe + " Swept Low"
    else
        labelText := htf2Timeframe + " Strong Low"

    htf2CurrentLowLabel := label.new(bar_index + 5, htf2CurrentValidLow,
                                     text=labelText,
                                     style=label.style_label_up,
                                     color=color.black,
                                     textcolor=color.white,
                                     size=size.normal)

// Nearest unbroken level labels (structure boundaries)
// CTF nearest unbroken high
if nearestUnbrokenHighIndex >= 0 and nearestUnbrokenHighIndex < array.size(highs) and nearestUnbrokenHighIndex != mostRecentHighIndex
    if not na(nearestUnbrokenHighLabel)
        label.delete(nearestUnbrokenHighLabel)

    highLevel = array.get(highs, nearestUnbrokenHighIndex)
    string labelText = timeframe.period + " Unbroken High"
    if highLevel.levelType == "swept"
        labelText := timeframe.period + " Swept High (Unbroken)"

    nearestUnbrokenHighLabel := label.new(bar_index + 5, highLevel.price,
                                          text=labelText,
                                          style=label.style_label_left,
                                          color=color.new(highColor, 50),
                                          textcolor=color.white,
                                          size=size.small)
else
    if not na(nearestUnbrokenHighLabel)
        label.delete(nearestUnbrokenHighLabel)
        nearestUnbrokenHighLabel := na

// CTF nearest unbroken low
if nearestUnbrokenLowIndex >= 0 and nearestUnbrokenLowIndex < array.size(lows) and nearestUnbrokenLowIndex != mostRecentLowIndex
    if not na(nearestUnbrokenLowLabel)
        label.delete(nearestUnbrokenLowLabel)

    lowLevel = array.get(lows, nearestUnbrokenLowIndex)
    string labelText = timeframe.period + " Unbroken Low"
    if lowLevel.levelType == "swept"
        labelText := timeframe.period + " Swept Low (Unbroken)"

    nearestUnbrokenLowLabel := label.new(bar_index + 5, lowLevel.price,
                                         text=labelText,
                                         style=label.style_label_left,
                                         color=color.new(lowColor, 50),
                                         textcolor=color.white,
                                         size=size.small)
else
    if not na(nearestUnbrokenLowLabel)
        label.delete(nearestUnbrokenLowLabel)
        nearestUnbrokenLowLabel := na

// HTF nearest unbroken high
if htfEnabled and htfNearestUnbrokenHighIndex >= 0 and htfNearestUnbrokenHighIndex < array.size(htfHighs) and htfNearestUnbrokenHighIndex != htfMostRecentHighIndex
    if not na(htfNearestUnbrokenHighLabel)
        label.delete(htfNearestUnbrokenHighLabel)

    highLevel = array.get(htfHighs, htfNearestUnbrokenHighIndex)
    string labelText = htfTimeframe + " Unbroken High"
    if highLevel.levelType == "swept"
        labelText := htfTimeframe + " Swept High (Unbroken)"

    htfNearestUnbrokenHighLabel := label.new(bar_index + 20, highLevel.price,
                                              text=labelText,
                                              style=label.style_label_left,
                                              color=color.new(htfHighColor, 50),
                                              textcolor=color.white,
                                              size=size.small)
else
    if not na(htfNearestUnbrokenHighLabel)
        label.delete(htfNearestUnbrokenHighLabel)
        htfNearestUnbrokenHighLabel := na

// HTF nearest unbroken low
if htfEnabled and htfNearestUnbrokenLowIndex >= 0 and htfNearestUnbrokenLowIndex < array.size(htfLows) and htfNearestUnbrokenLowIndex != htfMostRecentLowIndex
    if not na(htfNearestUnbrokenLowLabel)
        label.delete(htfNearestUnbrokenLowLabel)

    lowLevel = array.get(htfLows, htfNearestUnbrokenLowIndex)
    string labelText = htfTimeframe + " Unbroken Low"
    if lowLevel.levelType == "swept"
        labelText := htfTimeframe + " Swept Low (Unbroken)"

    htfNearestUnbrokenLowLabel := label.new(bar_index + 20, lowLevel.price,
                                             text=labelText,
                                             style=label.style_label_left,
                                             color=color.new(htfLowColor, 50),
                                             textcolor=color.white,
                                             size=size.small)
else
    if not na(htfNearestUnbrokenLowLabel)
        label.delete(htfNearestUnbrokenLowLabel)
        htfNearestUnbrokenLowLabel := na

// HTF2 nearest unbroken high
if htf2Enabled and htf2NearestUnbrokenHighIndex >= 0 and htf2NearestUnbrokenHighIndex < array.size(htf2Highs) and htf2NearestUnbrokenHighIndex != htf2MostRecentHighIndex
    if not na(htf2NearestUnbrokenHighLabel)
        label.delete(htf2NearestUnbrokenHighLabel)

    highLevel = array.get(htf2Highs, htf2NearestUnbrokenHighIndex)
    string labelText = htf2Timeframe + " Unbroken High"
    if highLevel.levelType == "swept"
        labelText := htf2Timeframe + " Swept High (Unbroken)"

    htf2NearestUnbrokenHighLabel := label.new(bar_index + 35, highLevel.price,
                                               text=labelText,
                                               style=label.style_label_down,
                                               color=color.new(htf2HighColor, 50),
                                               textcolor=color.white,
                                               size=size.small)
else
    if not na(htf2NearestUnbrokenHighLabel)
        label.delete(htf2NearestUnbrokenHighLabel)
        htf2NearestUnbrokenHighLabel := na

// HTF2 nearest unbroken low
if htf2Enabled and htf2NearestUnbrokenLowIndex >= 0 and htf2NearestUnbrokenLowIndex < array.size(htf2Lows) and htf2NearestUnbrokenLowIndex != htf2MostRecentLowIndex
    if not na(htf2NearestUnbrokenLowLabel)
        label.delete(htf2NearestUnbrokenLowLabel)

    lowLevel = array.get(htf2Lows, htf2NearestUnbrokenLowIndex)
    string labelText = htf2Timeframe + " Unbroken Low"
    if lowLevel.levelType == "swept"
        labelText := htf2Timeframe + " Swept Low (Unbroken)"

    htf2NearestUnbrokenLowLabel := label.new(bar_index + 35, lowLevel.price,
                                              text=labelText,
                                              style=label.style_label_up,
                                              color=color.new(htf2LowColor, 50),
                                              textcolor=color.white,
                                              size=size.small)
else
    if not na(htf2NearestUnbrokenLowLabel)
        label.delete(htf2NearestUnbrokenLowLabel)
        htf2NearestUnbrokenLowLabel := na

// Swept level labels - clear all
for lbl in sweptHighLabels
    label.delete(lbl)
array.clear(sweptHighLabels)
for lbl in sweptLowLabels
    label.delete(lbl)
array.clear(sweptLowLabels)
for lbl in htfSweptHighLabels
    label.delete(lbl)
array.clear(htfSweptHighLabels)
for lbl in htfSweptLowLabels
    label.delete(lbl)
array.clear(htfSweptLowLabels)

// ============================================================================
// ZONE ENTRY DETECTION AND BOS COUNTING FOR ALERTS
// ============================================================================

// Helper: find index of unbroken zone containing price, or -1 if none
findZoneContainingPrice(array<Zone> zones) =>
    int result = -1
    if array.size(zones) > 0
        for i = array.size(zones) - 1 to 0
            zone = array.get(zones, i)
            if not zone.broken and close >= zone.bottom and close <= zone.top
                result := i
                break
    result

// Check zone entries and set flags (HTF and HTF2 only - CTF zones less useful for alerts)
int htfDemandIdx = htfEnabled ? findZoneContainingPrice(demandZones) : -1
int htfSupplyIdx = htfEnabled ? findZoneContainingPrice(supplyZones) : -1
int htf2DemandIdx = htf2Enabled ? findZoneContainingPrice(htf2DemandZones) : -1
int htf2SupplyIdx = htf2Enabled ? findZoneContainingPrice(htf2SupplyZones) : -1

// Zone entry tracking - HTF demand
if htfDemandIdx >= 0 and not inHtfDemandZone
    inHtfDemandZone := true
    activeHtfDemandZoneIdx := htfDemandIdx
    ctfBullishBosCountSinceHtfDemand := 0
    htfDemandEntryFlag := true

// Zone entry tracking - HTF supply
if htfSupplyIdx >= 0 and not inHtfSupplyZone
    inHtfSupplyZone := true
    activeHtfSupplyZoneIdx := htfSupplyIdx
    ctfBearishBosCountSinceHtfSupply := 0
    htfSupplyEntryFlag := true

// Zone entry tracking - HTF2 demand
if htf2DemandIdx >= 0 and not inHtf2DemandZone
    inHtf2DemandZone := true
    activeHtf2DemandZoneIdx := htf2DemandIdx
    ctfBullishBosCountSinceHtf2Demand := 0
    htfBullishBosCountSinceHtf2Demand := 0
    htf2DemandEntryFlag := true

// Zone entry tracking - HTF2 supply
if htf2SupplyIdx >= 0 and not inHtf2SupplyZone
    inHtf2SupplyZone := true
    activeHtf2SupplyZoneIdx := htf2SupplyIdx
    ctfBearishBosCountSinceHtf2Supply := 0
    htfBearishBosCountSinceHtf2Supply := 0
    htf2SupplyEntryFlag := true

// Check if active zones got broken - reset tracking
if inHtfDemandZone and activeHtfDemandZoneIdx >= 0 and activeHtfDemandZoneIdx < array.size(demandZones)
    if array.get(demandZones, activeHtfDemandZoneIdx).broken
        inHtfDemandZone := false
        activeHtfDemandZoneIdx := -1
        ctfBullishBosCountSinceHtfDemand := 0
if inHtfSupplyZone and activeHtfSupplyZoneIdx >= 0 and activeHtfSupplyZoneIdx < array.size(supplyZones)
    if array.get(supplyZones, activeHtfSupplyZoneIdx).broken
        inHtfSupplyZone := false
        activeHtfSupplyZoneIdx := -1
        ctfBearishBosCountSinceHtfSupply := 0
if inHtf2DemandZone and activeHtf2DemandZoneIdx >= 0 and activeHtf2DemandZoneIdx < array.size(htf2DemandZones)
    if array.get(htf2DemandZones, activeHtf2DemandZoneIdx).broken
        inHtf2DemandZone := false
        activeHtf2DemandZoneIdx := -1
        ctfBullishBosCountSinceHtf2Demand := 0
        htfBullishBosCountSinceHtf2Demand := 0
if inHtf2SupplyZone and activeHtf2SupplyZoneIdx >= 0 and activeHtf2SupplyZoneIdx < array.size(htf2SupplyZones)
    if array.get(htf2SupplyZones, activeHtf2SupplyZoneIdx).broken
        inHtf2SupplyZone := false
        activeHtf2SupplyZoneIdx := -1
        ctfBearishBosCountSinceHtf2Supply := 0
        htfBearishBosCountSinceHtf2Supply := 0

// Count BOS events after zone entry
if inHtfDemandZone and ctfBullishBosFlag
    ctfBullishBosCountSinceHtfDemand += 1
    firstCtfBullishBosAfterHtfDemandFlag := ctfBullishBosCountSinceHtfDemand == 1
    secondCtfBullishBosAfterHtfDemandFlag := ctfBullishBosCountSinceHtfDemand == 2
if inHtfSupplyZone and ctfBearishBosFlag
    ctfBearishBosCountSinceHtfSupply += 1
    firstCtfBearishBosAfterHtfSupplyFlag := ctfBearishBosCountSinceHtfSupply == 1
    secondCtfBearishBosAfterHtfSupplyFlag := ctfBearishBosCountSinceHtfSupply == 2
if inHtf2DemandZone and ctfBullishBosFlag
    ctfBullishBosCountSinceHtf2Demand += 1
    firstCtfBullishBosAfterHtf2DemandFlag := ctfBullishBosCountSinceHtf2Demand == 1
    secondCtfBullishBosAfterHtf2DemandFlag := ctfBullishBosCountSinceHtf2Demand == 2
if inHtf2SupplyZone and ctfBearishBosFlag
    ctfBearishBosCountSinceHtf2Supply += 1
    firstCtfBearishBosAfterHtf2SupplyFlag := ctfBearishBosCountSinceHtf2Supply == 1
    secondCtfBearishBosAfterHtf2SupplyFlag := ctfBearishBosCountSinceHtf2Supply == 2
if inHtf2DemandZone and htfBullishBosFlag
    htfBullishBosCountSinceHtf2Demand += 1
    firstHtfBullishBosAfterHtf2DemandFlag := htfBullishBosCountSinceHtf2Demand == 1
if inHtf2SupplyZone and htfBearishBosFlag
    htfBearishBosCountSinceHtf2Supply += 1
    firstHtfBearishBosAfterHtf2SupplyFlag := htfBearishBosCountSinceHtf2Supply == 1

// ============================================================================
// ALERT CONDITIONS
// ============================================================================

// HTF Alert Conditions (legacy)
alertcondition(htfBosFlag, title="HTF BOS", message="HTF Break of Structure occurred on {{ticker}}")
alertcondition(htfBosLtfBosFlag, title="HTF BOS + LTF BOS Same Direction", message="HTF and LTF both broke structure in same direction on {{ticker}}")
alertcondition(htfSweptFlag, title="HTF Swept", message="HTF level swept on {{ticker}}")
alertcondition(htfSweptLtfBosFlag, title="HTF Swept + LTF BOS Reversal", message="HTF level swept followed by LTF reversal BOS on {{ticker}}")

// Pullback Alert Conditions
alertcondition(pullback50Flag, title="50% Pullback", message="Price touched 50% level on {{ticker}}")
alertcondition(pullback25Flag, title="25% Pullback (Low 50% Mark)", message="Price touched 25% level (low 50% mark) on {{ticker}}")

// LTF Alert Conditions (legacy)
alertcondition(ltfBosFlag, title="LTF BOS", message="LTF Break of Structure occurred on {{ticker}}")
alertcondition(ltfSweptFlag, title="LTF Swept", message="LTF level swept on {{ticker}}")
alertcondition(ltfBosAtExtremeFlag, title="LTF BOS at HTF Extreme", message="LTF BOS occurred at HTF extreme (bullish below 50% or bearish above 50%) on {{ticker}}")

// ============================================================================
// NEW ALERT CONDITIONS - BOS Events by Timeframe
// ============================================================================

// CTF BOS Alerts
alertcondition(ctfBullishBosFlag, title="CTF Bullish BOS", message="CTF Bullish Break of Structure occurred on {{ticker}}")
alertcondition(ctfBearishBosFlag, title="CTF Bearish BOS", message="CTF Bearish Break of Structure occurred on {{ticker}}")

// HTF BOS Direction-Specific Alerts
alertcondition(htfBullishBosFlag, title="HTF Bullish BOS", message="HTF Bullish Break of Structure occurred on {{ticker}}")
alertcondition(htfBearishBosFlag, title="HTF Bearish BOS", message="HTF Bearish Break of Structure occurred on {{ticker}}")

// HTF2 BOS Alerts
alertcondition(htf2BullishBosFlag, title="HTF2 Bullish BOS", message="HTF2 Bullish Break of Structure occurred on {{ticker}}")
alertcondition(htf2BearishBosFlag, title="HTF2 Bearish BOS", message="HTF2 Bearish Break of Structure occurred on {{ticker}}")

// ============================================================================
// NEW ALERT CONDITIONS - Zone Entry (HTF and HTF2 only)
// ============================================================================

// HTF Zone Entry Alerts
alertcondition(htfDemandEntryFlag, title="HTF Demand Zone Entry", message="Price entered HTF Demand Zone on {{ticker}}")
alertcondition(htfSupplyEntryFlag, title="HTF Supply Zone Entry", message="Price entered HTF Supply Zone on {{ticker}}")

// HTF2 Zone Entry Alerts
alertcondition(htf2DemandEntryFlag, title="HTF2 Demand Zone Entry", message="Price entered HTF2 Demand Zone on {{ticker}}")
alertcondition(htf2SupplyEntryFlag, title="HTF2 Supply Zone Entry", message="Price entered HTF2 Supply Zone on {{ticker}}")

// ============================================================================
// NEW ALERT CONDITIONS - BOS After Zone Entry
// ============================================================================

// CTF BOS after entering HTF zone (bullish for demand, bearish for supply)
alertcondition(firstCtfBullishBosAfterHtfDemandFlag, title="1st CTF Bull BOS in HTF Demand", message="First CTF Bullish BOS after entering HTF Demand Zone on {{ticker}}")
alertcondition(secondCtfBullishBosAfterHtfDemandFlag, title="2nd CTF Bull BOS in HTF Demand", message="Second CTF Bullish BOS after entering HTF Demand Zone on {{ticker}}")
alertcondition(firstCtfBearishBosAfterHtfSupplyFlag, title="1st CTF Bear BOS in HTF Supply", message="First CTF Bearish BOS after entering HTF Supply Zone on {{ticker}}")
alertcondition(secondCtfBearishBosAfterHtfSupplyFlag, title="2nd CTF Bear BOS in HTF Supply", message="Second CTF Bearish BOS after entering HTF Supply Zone on {{ticker}}")

// CTF BOS after entering HTF2 zone
alertcondition(firstCtfBullishBosAfterHtf2DemandFlag, title="1st CTF Bull BOS in HTF2 Demand", message="First CTF Bullish BOS after entering HTF2 Demand Zone on {{ticker}}")
alertcondition(secondCtfBullishBosAfterHtf2DemandFlag, title="2nd CTF Bull BOS in HTF2 Demand", message="Second CTF Bullish BOS after entering HTF2 Demand Zone on {{ticker}}")
alertcondition(firstCtfBearishBosAfterHtf2SupplyFlag, title="1st CTF Bear BOS in HTF2 Supply", message="First CTF Bearish BOS after entering HTF2 Supply Zone on {{ticker}}")
alertcondition(secondCtfBearishBosAfterHtf2SupplyFlag, title="2nd CTF Bear BOS in HTF2 Supply", message="Second CTF Bearish BOS after entering HTF2 Supply Zone on {{ticker}}")

// HTF BOS after entering HTF2 zone
alertcondition(firstHtfBullishBosAfterHtf2DemandFlag, title="1st HTF Bull BOS in HTF2 Demand", message="First HTF Bullish BOS after entering HTF2 Demand Zone on {{ticker}}")
alertcondition(firstHtfBearishBosAfterHtf2SupplyFlag, title="1st HTF Bear BOS in HTF2 Supply", message="First HTF Bearish BOS after entering HTF2 Supply Zone on {{ticker}}")

// Reset all alert flags at end of bar
htfBosFlag := false
htfBosLtfBosFlag := false
htfSweptFlag := false
htfSweptLtfBosFlag := false
pullback50Flag := false
pullback25Flag := false
ltfBosFlag := false
ltfSweptFlag := false
ltfBosAtExtremeFlag := false

// Reset new BOS alert flags
ctfBullishBosFlag := false
ctfBearishBosFlag := false
htfBullishBosFlag := false
htfBearishBosFlag := false
htf2BullishBosFlag := false
htf2BearishBosFlag := false

// Reset zone entry alert flags (HTF and HTF2 only)
htfDemandEntryFlag := false
htfSupplyEntryFlag := false
htf2DemandEntryFlag := false
htf2SupplyEntryFlag := false

// Reset BOS after zone entry alert flags
// CTF BOS after HTF zone entry
firstCtfBullishBosAfterHtfDemandFlag := false
firstCtfBearishBosAfterHtfSupplyFlag := false
secondCtfBullishBosAfterHtfDemandFlag := false
secondCtfBearishBosAfterHtfSupplyFlag := false
// CTF BOS after HTF2 zone entry
firstCtfBullishBosAfterHtf2DemandFlag := false
firstCtfBearishBosAfterHtf2SupplyFlag := false
secondCtfBullishBosAfterHtf2DemandFlag := false
secondCtfBearishBosAfterHtf2SupplyFlag := false
// HTF BOS after HTF2 zone entry
firstHtfBullishBosAfterHtf2DemandFlag := false
firstHtfBearishBosAfterHtf2SupplyFlag := false

// ============================================================================
// ZONE RENDERING - Only on last bar for performance
// ============================================================================

// Render zones only on the last bar
var int demandZonesRendered = 0
var int supplyZonesRendered = 0
var int htfDemandZonesRendered = 0
var int htfSupplyZonesRendered = 0
var int demandSkipped = 0
var int supplySkipped = 0
var array<int> demandZoneTimes = array.new<int>()
var array<int> supplyZoneTimes = array.new<int>()

// Use user-configured max zones per side

// Helper function to render zones from an array
// Returns [rendered, iterations, arraySize]
renderZones(array<Zone> zones, color bgColor, color borderColor, int borderWidth, int maxZones, bool showBroken) =>
    int rendered = 0
    int iterations = 0
    int arrSize = array.size(zones)
    if arrSize > 0
        for i = arrSize - 1 to 0
            iterations := iterations + 1
            if rendered >= maxZones
                break
            zone = array.get(zones, i)
            if zone.broken and not showBroken
                continue
            if not na(zone.leftTime) and not na(zone.top) and not na(zone.bottom)
                // If extendBrokenZones is true, always extend to current time
                // Otherwise, broken zones stop at their rightTime
                zoneEndTime = (zone.broken and not extendBrokenZones) ? zone.rightTime : time
                box.new(zone.leftTime, zone.top, zoneEndTime, zone.bottom, bgcolor=bgColor, border_color=borderColor, border_width=borderWidth, xloc=xloc.bar_time)
                rendered := rendered + 1
    [rendered, iterations, arrSize]

if barstate.islast
    // Delete all existing boxes
    for bx in box.all
        bx.delete()

    // Render all zone types
    int ctfDemandRendered = 0
    int ctfSupplyRendered = 0
    int ctfDemandIter = 0
    int ctfSupplyIter = 0
    if showCtfZones
        [r1, i1, s1] = renderZones(ctfDemandZones, ctfDemandZoneColor, ctfDemandZoneBorderColor, 1, maxZonesPerSide, showBrokenCtfZones)
        ctfDemandRendered := r1
        ctfDemandIter := i1
        [r2, i2, s2] = renderZones(ctfSupplyZones, ctfSupplyZoneColor, ctfSupplyZoneBorderColor, 1, maxZonesPerSide, showBrokenCtfZones)
        ctfSupplyRendered := r2
        ctfSupplyIter := i2
    if showHtfZones
        [r3, i3, s3] = renderZones(demandZones, demandZoneColor, demandZoneBorderColorInput, 1, maxZonesPerSide, showBrokenHtfZones)
        demandZonesRendered := r3
        [r4, i4, s4] = renderZones(supplyZones, supplyZoneColor, supplyZoneBorderColorInput, 1, maxZonesPerSide, showBrokenHtfZones)
        supplyZonesRendered := r4
    if showHtf2Zones and htf2Enabled
        renderZones(htf2DemandZones, htf2DemandZoneColor, htf2DemandZoneBorderColor, 2, maxZonesPerSide, showBrokenHtf2Zones)
        renderZones(htf2SupplyZones, htf2SupplyZoneColor, htf2SupplyZoneBorderColor, 2, maxZonesPerSide, showBrokenHtf2Zones)

    // Debug labels showing zone counts and BOS events
    if showDebugLabel
        var label debugLabel = na
        label.delete(debugLabel)

        // Count broken zones
        int brokenDemand = 0
        int brokenSupply = 0
        if array.size(demandZones) > 0
            for i = 0 to array.size(demandZones) - 1
                if array.get(demandZones, i).broken
                    brokenDemand := brokenDemand + 1
        if array.size(supplyZones) > 0
            for i = 0 to array.size(supplyZones) - 1
                if array.get(supplyZones, i).broken
                    brokenSupply := brokenSupply + 1

        // Count CTF zones with valid data
        int ctfDemandValid = 0
        int ctfSupplyValid = 0
        if array.size(ctfDemandZones) > 0
            for i = 0 to array.size(ctfDemandZones) - 1
                z = array.get(ctfDemandZones, i)
                if not na(z.leftTime) and not na(z.top) and not na(z.bottom)
                    ctfDemandValid := ctfDemandValid + 1
        if array.size(ctfSupplyZones) > 0
            for i = 0 to array.size(ctfSupplyZones) - 1
                z = array.get(ctfSupplyZones, i)
                if not na(z.leftTime) and not na(z.top) and not na(z.bottom)
                    ctfSupplyValid := ctfSupplyValid + 1

        // Count CTF broken zones
        int ctfDemandBroken = 0
        int ctfSupplyBroken = 0
        if array.size(ctfDemandZones) > 0
            for i = 0 to array.size(ctfDemandZones) - 1
                if array.get(ctfDemandZones, i).broken
                    ctfDemandBroken := ctfDemandBroken + 1
        if array.size(ctfSupplyZones) > 0
            for i = 0 to array.size(ctfSupplyZones) - 1
                if array.get(ctfSupplyZones, i).broken
                    ctfSupplyBroken := ctfSupplyBroken + 1

        // Get info about CTF demand zones - check multiple recent ones
        string newestZoneInfo = "none"
        int zeroHeightCount = 0
        float avgHeight = 0.0
        if array.size(ctfDemandZones) > 0
            float totalHeight = 0.0
            for i = 0 to array.size(ctfDemandZones) - 1
                Zone z = array.get(ctfDemandZones, i)
                float h = z.top - z.bottom
                totalHeight := totalHeight + h
                if h < 0.0001
                    zeroHeightCount := zeroHeightCount + 1
            avgHeight := totalHeight / array.size(ctfDemandZones)
            // Show last 3 zones
            int lastIdx = array.size(ctfDemandZones) - 1
            Zone z1 = array.get(ctfDemandZones, lastIdx)
            newestZoneInfo := str.tostring(z1.top, "#.#####") + "/" + str.tostring(z1.bottom, "#.#####")

        string debugText = "ZONE DEBUG v15:\n"
        debugText := debugText + "Highs: " + str.tostring(array.size(highs)) + ", Lows: " + str.tostring(array.size(lows)) + "\n"
        debugText := debugText + "CTF BOS: " + str.tostring(ctfBullishBOS) + " bull / " + str.tostring(ctfBearishBOS) + " bear\n"
        debugText := debugText + "CTF D created: " + str.tostring(ctfDemandZonesCreated) + ", NA: " + str.tostring(ctfDemandSkippedNa) + ", dupe: " + str.tostring(ctfDemandSkippedDupe) + "\n"
        debugText := debugText + "CTF D in array: " + str.tostring(array.size(ctfDemandZones)) + ", S: " + str.tostring(array.size(ctfSupplyZones)) + "\n"
        debugText := debugText + "Rendered: " + str.tostring(ctfDemandRendered) + " D / " + str.tostring(ctfSupplyRendered) + " S"

        debugLabel := label.new(bar_index, high, debugText,
                               style=label.style_label_down,
                               color=color.yellow,
                               textcolor=color.black,
                               size=size.small)
