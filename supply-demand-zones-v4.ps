// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© scientificbest

//@version=5
indicator("Supply & Demand Zones V4 (Beta) [SB]", "S&D Zones V4 [SB]", overlay = true
  , max_bars_back = 5000 
  , max_lines_count  = 500
  , max_labels_count = 500
  , max_boxes_count  = 500)

////////////////////////////////////////////////////////////////////////////////
//// Inputs
////////////////////////////////////////////////////////////////////////////////
grp1 = 'Zone Detection Parameters'
grp2 = 'Display Settings'
grp3 = 'Colors'

// Zone Detection
src 								= input.source(close, title='Source', group=grp1)
src_vol 							= input.string('No', title='Use volume as the source?', group=grp1, options=['No', 'Volume', 'VolumeDiff'], tooltip='If enabled, will use volume as the source, so the Source parameter above will be ignored.')
period 								= input.int(80, title='Lookback Period', minval=1, maxval=500, group=grp1, tooltip='This is the number of bars that will be sampled to detect outliers in the "Source" data.') + 1
limit_second 						= input.float(13, title='Significance threshold', minval=0, step=0.05, group=grp1, tooltip='This value is used as a threshold for detecting outliers in the "Source" data, which should identify significant "strong moves" in the price action. Generally speaking, the higher the value, the fewer zones will be detected. However, those zone tend to be higher quality. You probably want a value between 0.5 and 2.5')
minMoveToZoneRatioInput				= input.float(1.1, title='Minimum move to zone ratio', minval=0, step=0.05, group=grp1, tooltip='This is the minimum ratio of the intial "strong move" to the zone size. If the move is smaller than this ratio, the zone will not be plotted. This roughly translates into the minimum risk reward ratio for the trade, but it also correlates with zone strength. Since this only refers to the "explosive" part of the move, you probably want a value between 0.25 and 1.5.')
maxNumberOfZonesInput				= input.int(120, title='Max number of zones', minval=1, group=grp1, tooltip='This is the maximum number of zones that will be plotted on the chart. If the number of zones exceeds this value, the oldest zones will be removed from the chart. Keep in mind the maximum number of boxes that can be plotted by a single indicator is 500, so if the total number of zones AND strong moves plotted exceeds 500, some of the boxes will fail to render.')

// Display
showZonesInput						= input.bool(true, title="Show Zones", group=grp2, tooltip='If enabled, will display the zones on the chart.')
showStrongMovesInput				= input.bool(false, title="Show Strong Moves", group=grp2, tooltip='If enabled, will display the strong moves on the chart.')
changeColorOnTouchedInput			= input.bool(true, title="Change Color On Touched", group=grp2, tooltip='If enabled, will change the color of the zone when it is touched.')
brokenWhenTouchedInput				= input.bool(false, title="Zones Are Broken When Touched", group=grp2, tooltip='If enabled, the zone will be considered broken when it is touched. If disabled, the zone will only be considered broken when it is crossed.')

// Colors
supplyZoneColorInput 				= input.color(color.new(color.red, 70), title="Supply Zone Color", group=grp3)
supplyZoneBorderColorInput 			= input.color(color.new(color.red, 50), title="Supply Zone Border Color", group=grp3)
supplyStrongMoveColorInput 			= input.color(color.new(color.orange, 80), title="Supply Strong Move Color", group=grp3)
supplyStrongMoveBorderColorInput	= input.color(color.new(color.orange, 50), title="Supply Strong Move Border Color", group=grp3)
demandZoneColorInput 				= input.color(color.new(color.green, 70), title="Demand Zone Color", group=grp3)
demandZoneBorderColorInput 			= input.color(color.new(color.green, 50), title="Demand Zone Border Color", group=grp3)
demandStrongMoveColorInput 			= input.color(color.new(color.blue, 80), title="Demand Strong Move Color", group=grp3)
demandStrongMoveBorderColorInput	= input.color(color.new(color.blue, 50), title="Demand Strong Move Border Color", group=grp3)
zoneTouchedColorInput 				= input.color(color.new(color.gray, 80), title="Zone Touched Color", group=grp3)

// DATA LOADING
float source = switch src_vol // make sure to use REAL tabs, because when tapping the TAB key, this may add 4 spaces instead, and then for some mysterious reason the switch won't work!
	"No" => src
	'Volume' => math.sign(ta.change(close)) * volume // volume is often using the sign of the price change to show which of the bulls or bears won, here this equation is from the Net Volume indicator but also mirrors the Vol native indicator
	'VolumeDiff' => volume

// CALCULATIONS
diff = src_vol == 'Volume' ? source : source[0] - math.avg(source[1], source[1], source[2])

sample = array.new<float>(period, 0.0)
for i = 0 to period - 1
	array.set(sample, i, diff[i])

sampleAvg = array.avg(sample)
sampleStdDev = array.stdev(sample, false) 

// Z-score
z = (diff - sampleAvg) / (sampleStdDev / math.sqrt(period) )

// Get absolute value so we plot all columns on the same direction (also used to uncolor bars lower than significance)
z_abs = math.abs(z)

limit_first = ta.highest(z_abs, period) / 2

type ZoneScore
	float strengthOfMove = na
	float timeAtZone = na
	float freshness = na
	float riskReward = na
	float originality = na
	float htfOverlappingZone = na

method total(ZoneScore score) =>
	score.strengthOfMove + score.timeAtZone + score.freshness + score.riskReward + score.originality + score.htfOverlappingZone

type StrongMove
	int dir = na
	int startLoc = na
	int endLoc = na
	float startPrice = na
	float endPrice = na
	float totalChange = na
	float highPrice = na
	float lowPrice = na
	int numberOfBars = na

type Zone
	int dir = na
	float top = na
	float btm = na
	int startLoc = na
	int endLoc = na
	StrongMove strongMove = na
	ZoneScore score = na
	bool crossed = false
	int crossedLoc = na
	bool touched = false
	int touchedLoc = na
	bool breaker = false
	bool brokeOpposingZone = false

// Variables
var supplyZones = array.new<Zone>(0)
var demandZones = array.new<Zone>(0)
var unbrokenSupplyZones = array.new<Zone>(0)
var unbrokenDemandZones = array.new<Zone>(0)

method getStrengthOfMove(Zone zone, int swingLength) =>
	zone.top - zone.btm

method getTimeAtZone(Zone zone, int minBars, int maxBars) =>
	minMaxDiff = maxBars - minBars
	bucketSize = minMaxDiff / 3
	b1 = math.floor(minBars + bucketSize)
	b2 = math.floor(minBars + (bucketSize * 2))
	b3 = maxBars
	bars = zone.endLoc - zone.startLoc
	score = bars > minBars and bars < b1 ? 3 : bars > b1 and bars < b2 ? 2 : bars > b2 and bars < b3 ? 1 : 0
	zone.score.timeAtZone := score
	zone

getLeadingDownCandles(startOffset) =>
	var leadingCandles = 0
	for i = startOffset to startOffset + 10
		if close[i] > open[i]
			leadingCandles := leadingCandles + 1
		else
			break
	leadingCandles


ma2 = ta.sma(close, 3)
maChange = ma2 - ma2[1]
candleBodyChange = close - open
candleBodyRange = math.abs(open - close)
candleRange = high - low
candleBodyUp = close > open
candleBodyDown = close < open
candleBodyHigh = close > open ? close : open
candleBodyLow = close > open ? open : close
topWickMidpoint = math.avg(high, candleBodyHigh)
btmWickMidpoint = math.avg(low, candleBodyLow)

var recentZoneCreationList = array.new<int>(0)
var recentZoneCrossedList = array.new<int>(0)
var Zone mostRecentSupplyZone = na
var Zone mostRecentDemandZone = na

var bool supplyZoneCreated = false
var bool demandZoneCreated = false
var float supplyZoneCreatedTop = na
var float supplyZoneCreatedBtm = na
var float demandZoneCreatedTop = na
var float demandZoneCreatedBtm = na

var bool supplyZoneCrossed = false
var bool demandZoneCrossed = false
var float supplyZoneCrossedTop = na
var float supplyZoneCrossedBtm = na
var float demandZoneCrossedTop = na
var float demandZoneCrossedBtm = na

var bool supplyZoneTouched = false
var bool demandZoneTouched = false
var float supplyZoneTouchedTop = na
var float supplyZoneTouchedBtm = na
var float demandZoneTouchedTop = na
var float demandZoneTouchedBtm = na


identifySupplyZone() =>
	var StrongMove move = na
	var Zone zone = na
	var bool hasExplosiveCandle = false
	var float maxDeviation = 0
	prevZone = array.size(supplyZones) > 0 ? array.get(supplyZones, 0) : na
	prevMove = not na(prevZone) ? prevZone.strongMove : na
	prevMoveInProgress = not na(prevMove) ? prevMove.endLoc >= bar_index - 1 : false
	prevClose = close[1]

	/////////////////////////////////////////
	// Get StrongMove
	/////////////////////////////////////////
	if z_abs > limit_first and candleBodyDown
		maxDeviation := math.max(z_abs, maxDeviation)
		move := StrongMove.new(dir=-1, startLoc=bar_index, endLoc=bar_index, startPrice=math.max(close[1], open), endPrice=close, totalChange=0, highPrice=math.max(close[1], high), lowPrice=low, numberOfBars=0)
		for i = 0 to 40
			explosiveCandle = z_abs[i] > limit_second and candleBodyDown[i] and candleBodyRange[i] / candleRange[i] > 0.4
			strongCandle = z_abs[i] > limit_first and z_abs[i] < limit_second and candleBodyDown[i]
			if explosiveCandle // or strongCandle
				maxDeviation := math.max(z_abs[i], maxDeviation)
				move.startLoc := move.startLoc - 1
				move.startPrice := math.max(close[i + 1], open[i])
				move.highPrice := math.max(move.highPrice, close[i + 1], high[i])
				move.lowPrice := math.min(move.lowPrice, low[i])
				move.totalChange := move.endPrice - move.startPrice
				move.numberOfBars := move.numberOfBars + 1
				hasExplosiveCandle := true
			else
				break
		if not hasExplosiveCandle
			move := na
		else if prevMoveInProgress
			array.shift(supplyZones)
		halfMaxDeviation = maxDeviation / 2
	/////////////////////////////////////////
	// Get Zone
	/////////////////////////////////////////
		if not na(move)
			prevZone := array.size(supplyZones) > 0 ? array.get(supplyZones, 0) : na
			if na(zone)
				zone := Zone.new(dir=-1, top=math.max(move.highPrice, high[move.numberOfBars]), btm=math.min(move.startPrice, low[move.numberOfBars]), startLoc=move.startLoc - 1, endLoc=move.endLoc, strongMove=move, score=ZoneScore.new(strengthOfMove=0, timeAtZone=0, freshness=0, riskReward=0, originality=0, htfOverlappingZone=0), crossed=false, crossedLoc=na, touched=false, touchedLoc=na)
	
	if not na(move) and not na(zone)
		if zone.endLoc - zone.startLoc > 0 and (zone.btm - move.endPrice) / (zone.top - zone.btm) > minMoveToZoneRatioInput
			array.unshift(supplyZones, zone)
		else
			zone := na
			move := na
	
	if not na(zone)
		array.unshift(unbrokenSupplyZones, zone)

	if array.size(supplyZones) > maxNumberOfZonesInput
		array.pop(supplyZones)
	if array.size(unbrokenSupplyZones) > maxNumberOfZonesInput
		array.pop(unbrokenSupplyZones)

	result = zone
	zone := na
	move := na
	hasExplosiveCandle := false
	maxDeviation := 0
	result


identifyDemandZone() =>
	var StrongMove move = na
	var Zone zone = na
	var bool hasExplosiveCandle = false
	var float maxDeviation = 0
	prevZone = array.size(demandZones) > 0 ? array.get(demandZones, 0) : na
	prevMove = not na(prevZone) ? prevZone.strongMove : na
	prevMoveInProgress = not na(prevMove) ? prevMove.endLoc >= bar_index - 1 : false

	/////////////////////////////////////////
	// Get StrongMove
	/////////////////////////////////////////
	if z_abs > limit_first and candleBodyUp
		maxDeviation := math.max(z_abs, maxDeviation)
		move := StrongMove.new(dir=1, startLoc=bar_index, endLoc=bar_index, startPrice=math.min(close[1], open), endPrice=close, totalChange=0, highPrice=high, lowPrice=math.min(close[1], low), numberOfBars=0)
		for i = 0 to 40
			explosiveCandle = z_abs[i] > limit_second and candleBodyUp[i] and candleBodyRange[i] / candleRange[i] > 0.4
			strongCandle = z_abs[i] > limit_first and z_abs[i] < limit_second and candleBodyUp[i]
			if explosiveCandle // or strongCandle
				maxDeviation := math.max(z_abs[i], maxDeviation)
				move.startLoc := move.startLoc - 1
				move.startPrice := math.min(close[i + 1], open[i])
				move.highPrice := math.max(move.highPrice, high[i])
				move.lowPrice := math.min(move.lowPrice, close[i + 1], low[i])
				move.totalChange := move.endPrice - move.startPrice
				move.numberOfBars := move.numberOfBars + 1
				hasExplosiveCandle := true
			else
				break
		if not hasExplosiveCandle
			move := na
		else if prevMoveInProgress
			array.shift(demandZones)
		halfMaxDeviation = maxDeviation / 2
	/////////////////////////////////////////
	// Get Zone
	/////////////////////////////////////////
		if not na(move)
			prevZone := array.size(demandZones) > 0 ? array.get(demandZones, 0) : na
			if na(zone)
				zone := Zone.new(dir=1, top=math.max(move.startPrice, high[move.numberOfBars]), btm=math.min(move.lowPrice, low[move.numberOfBars]), startLoc=move.startLoc - 1, endLoc=move.endLoc, strongMove=move, score=ZoneScore.new(strengthOfMove=0, timeAtZone=0, freshness=0, riskReward=0, originality=0, htfOverlappingZone=0), crossed=false, crossedLoc=na, touched=false, touchedLoc=na)

	if not na(move) and not na(zone)
		if zone.endLoc - zone.startLoc > 0 and (move.endPrice - zone.top) / (zone.top - zone.btm) > minMoveToZoneRatioInput
			array.unshift(demandZones, zone)
		else
			zone := na
			move := na
	
	if not na(zone)
		array.unshift(unbrokenDemandZones, zone)

	if array.size(demandZones) > maxNumberOfZonesInput
		array.pop(demandZones)
	if array.size(unbrokenDemandZones) > maxNumberOfZonesInput
		array.pop(unbrokenDemandZones)

	result = zone
	zone := na
	move := na
	hasExplosiveCandle := false
	maxDeviation := 0
	result



displayStrongMove(StrongMove move, color strongMoveCss, color strongMoveBorderCss)=>
    if showStrongMovesInput and bar_index - move.startLoc < 4000
	    box.new(move.startLoc, move.highPrice, move.endLoc + 1, move.lowPrice , bgcolor = strongMoveCss, border_color = strongMoveBorderCss)

displayZone(Zone zn, color zoneCss, color zoneBorderCss, color strongMoveCss, color strongMoveBorderCss)=>
	if showZonesInput and bar_index - zn.startLoc < 4000
		zoneEnd = brokenWhenTouchedInput ? (zn.touched ? zn.touchedLoc : last_bar_index) : (zn.crossed ? zn.crossedLoc : last_bar_index)
	    box.new(zn.startLoc, zn.top, zoneEnd + 1, zn.btm , bgcolor = changeColorOnTouchedInput and zn.touched ? zoneTouchedColorInput : zoneCss, border_color = zoneBorderCss)
		displayStrongMove(zn.strongMove, strongMoveCss, strongMoveBorderCss)

displayZoneList(array<Zone> zoneList, color zoneCss, color zoneBorderCss, color strongMoveCss, color strongMoveBorderCss) => 
	if barstate.islast
		if zoneList.size() > 0
			for i = 0 to zoneList.size() - 1
				zn = zoneList.get(i)
				displayZone(zn, zoneCss, zoneBorderCss, strongMoveCss, strongMoveBorderCss)

displayStrongMoveList(array<StrongMove> moveList, color strongMoveCss, color strongMoveBorderCss) => 
	if barstate.islast
		if moveList.size() > 0
			for i = 0 to moveList.size() - 1
				move = moveList.get(i)
				displayStrongMove(move, strongMoveCss, strongMoveBorderCss)

//-----------------------------------------------------------------------------}
// Main
//-----------------------------------------------------------------------------}
sZone = identifySupplyZone()
dZone = identifyDemandZone()
if not na(sZone)
	supplyZoneCreated := true
	supplyZoneCreatedTop := sZone.top
	supplyZoneCreatedBtm := sZone.btm
if not na(dZone)
	demandZoneCreated := true
	demandZoneCreatedTop := dZone.top
	demandZoneCreatedBtm := dZone.btm

if array.size(supplyZones) > 0
	for i = 0 to array.size(supplyZones) - 1
		zn = array.get(supplyZones, i)
		if zn.endLoc < bar_index and zn.dir == -1
			if not zn.crossed and high > zn.top
				zn.crossed := true
				zn.crossedLoc := bar_index
				supplyZoneCrossed := true
				supplyZoneCrossedTop := zn.top
				supplyZoneCrossedBtm := zn.btm
				array.unshift(recentZoneCrossedList, 1)
			if not zn.touched and high > zn.btm
				zn.touched := true
				zn.touchedLoc := bar_index
				supplyZoneTouched := true
				supplyZoneTouchedTop := zn.top
				supplyZoneTouchedBtm := zn.btm
		if zn.endLoc < bar_index and zn.dir == 1 
			if not zn.crossed and low < zn.btm
				zn.crossed := true
				zn.crossedLoc := bar_index
				supplyZoneCrossed := true
				supplyZoneCrossedTop := zn.top
				supplyZoneCrossedBtm := zn.btm
				array.unshift(recentZoneCrossedList, -1)
			if not zn.touched and low < zn.top
				zn.touched := true
				zn.touchedLoc := bar_index
				supplyZoneTouched := true
				supplyZoneTouchedTop := zn.top
				supplyZoneTouchedBtm := zn.btm
		if array.size(recentZoneCrossedList) > 10
			array.pop(recentZoneCrossedList)

if array.size(demandZones) > 0
	for i = 0 to array.size(demandZones) - 1
		zn = array.get(demandZones, i)
		if zn.endLoc < bar_index and zn.dir == -1
			if not zn.crossed and high > zn.top
				zn.crossed := true
				zn.crossedLoc := bar_index
				supplyZoneCrossed := true
				supplyZoneCrossedTop := zn.top
				supplyZoneCrossedBtm := zn.btm
				array.unshift(recentZoneCrossedList, 1)
			if not zn.touched and high > zn.btm
				zn.touched := true
				zn.touchedLoc := bar_index
				supplyZoneTouched := true
				supplyZoneTouchedTop := zn.top
				supplyZoneTouchedBtm := zn.btm
		if zn.endLoc < bar_index and zn.dir == 1
			if not zn.crossed and low < zn.btm
				zn.crossed := true
				zn.crossedLoc := bar_index
				demandZoneCrossed := true
				demandZoneCrossedTop := zn.top
				demandZoneCrossedBtm := zn.btm
				array.unshift(recentZoneCrossedList, -1)
			if not zn.touched and low < zn.top
				zn.touched := true
				zn.touchedLoc := bar_index
				demandZoneTouched := true
				demandZoneTouchedTop := zn.top
				demandZoneTouchedBtm := zn.btm
		if array.size(recentZoneCrossedList) > 10
			array.pop(recentZoneCrossedList)

//-----------------------------------------------------------------------------}
// Plotting
//-----------------------------------------------------------------------------}
for bx in box.all
	bx.delete()

for l in line.all
	l.delete()

displayZoneList(supplyZones, supplyZoneColorInput, supplyZoneBorderColorInput, supplyStrongMoveColorInput, supplyStrongMoveBorderColorInput)
displayZoneList(demandZones, demandZoneColorInput, demandZoneBorderColorInput, demandStrongMoveColorInput, demandStrongMoveBorderColorInput)

//-----------------------------------------------------------------------------}
// Alerts
//-----------------------------------------------------------------------------}

plot(supplyZoneCreatedTop, title = "Supply Zone Created Top", display=display.none)
plot(supplyZoneCreatedBtm, title = "Supply Zone Created Bottom", display=display.none)
plot(demandZoneCreatedTop, title = "Demand Zone Created Top", display=display.none)
plot(demandZoneCreatedBtm, title = "Demand Zone Created Bottom", display=display.none)

plot(supplyZoneCrossedTop, title = "Supply Zone Crossed Top", display=display.none)
plot(supplyZoneCrossedBtm, title = "Supply Zone Crossed Bottom", display=display.none)
plot(demandZoneCrossedTop, title = "Demand Zone Crossed Top", display=display.none)
plot(demandZoneCrossedBtm, title = "Demand Zone Crossed Bottom", display=display.none)

plot(supplyZoneTouchedTop, title = "Supply Zone Touched Top", display=display.none)
plot(supplyZoneTouchedBtm, title = "Supply Zone Touched Bottom", display=display.none)
plot(demandZoneTouchedTop, title = "Demand Zone Touched Top", display=display.none)
plot(demandZoneTouchedBtm, title = "Demand Zone Touched Bottom", display=display.none)

alertcondition(supplyZoneCreated, title = "Supply Zone Created", message = 'Supply Zone Created, Top: {{plot("Supply Zone Created Top")}}, Bottom: {{plot("Supply Zone Created Bottom")}}')
alertcondition(demandZoneCreated, title = "Demand Zone Created", message = 'Demand Zone Created, Top: {{plot("Demand Zone Created Top")}}, Bottom: {{plot("Demand Zone Created Bottom")}}')
alertcondition(supplyZoneCrossed, title = "Supply Zone Crossed", message = 'Supply Zone Crossed, Top: {{plot("Supply Zone Crossed Top")}}, Bottom: {{plot("Supply Zone Crossed Bottom")}}')
alertcondition(demandZoneCrossed, title = "Demand Zone Crossed", message = 'Demand Zone Crossed, Top: {{plot("Demand Zone Crossed Top")}}, Bottom: {{plot("Demand Zone Crossed Bottom")}}')
alertcondition(supplyZoneTouched, title = "Supply Zone Touched", message = 'Supply Zone Touched, Top: {{plot("Supply Zone Touched Top")}}, Bottom: {{plot("Supply Zone Touched Bottom")}}')
alertcondition(demandZoneTouched, title = "Demand Zone Touched", message = 'Demand Zone Touched, Top: {{plot("Demand Zone Touched Top")}}, Bottom: {{plot("Demand Zone Touched Bottom")}}')

supplyZoneCreated := false
supplyZoneCreatedTop := na
supplyZoneCreatedBtm := na

supplyZoneCrossed := false
supplyZoneCrossedTop := na
supplyZoneCrossedBtm := na

supplyZoneTouched := false
supplyZoneTouchedTop := na
supplyZoneTouchedBtm := na

demandZoneCreated := false
demandZoneCreatedTop := na
demandZoneCreatedBtm := na

demandZoneCrossed := false
demandZoneCrossedTop := na
demandZoneCrossedBtm := na

demandZoneTouched := false
demandZoneTouchedTop := na
demandZoneTouchedBtm := na
